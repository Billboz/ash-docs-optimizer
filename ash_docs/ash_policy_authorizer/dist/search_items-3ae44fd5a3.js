searchNodes=[{"doc":"An authorization extension for ash resources. For more information, see AshPolicyAuthorizer.Authorizer","ref":"AshPolicyAuthorizer.html","title":"AshPolicyAuthorizer","type":"module"},{"doc":"","ref":"AshPolicyAuthorizer.html#default_access_type/1","title":"AshPolicyAuthorizer.default_access_type/1","type":"function"},{"doc":"","ref":"AshPolicyAuthorizer.html#describe_resource/1","title":"AshPolicyAuthorizer.describe_resource/1","type":"function"},{"doc":"Whether or not ash policy authorizer is configured to show policy breakdowns in error messages","ref":"AshPolicyAuthorizer.html#log_policy_breakdowns/0","title":"AshPolicyAuthorizer.log_policy_breakdowns/0","type":"function"},{"doc":"","ref":"AshPolicyAuthorizer.html#policies/1","title":"AshPolicyAuthorizer.policies/1","type":"function"},{"doc":"Whether or not ash policy authorizer is configured to show policy breakdowns in error messages","ref":"AshPolicyAuthorizer.html#show_policy_breakdowns?/0","title":"AshPolicyAuthorizer.show_policy_breakdowns?/0","type":"function"},{"doc":"A utility to determine if a given query/changeset would pass authorization. This is still experimental.","ref":"AshPolicyAuthorizer.html#strict_check/3","title":"AshPolicyAuthorizer.strict_check/3","type":"function"},{"doc":"","ref":"AshPolicyAuthorizer.html#t:request/0","title":"AshPolicyAuthorizer.request/0","type":"type"},{"doc":"An authorization extension for ash resources. To add this extension to a resource, add it to the list of authorizers like so: use Ash.Resource , ... , authorizers : [ AshPolicyAuthorizer.Authorizer ] DSL Documenation Table of Contents policies policy authorize_if forbid_if authorize_unless forbid_unless bypass authorize_if forbid_if authorize_unless forbid_unless policies A section for declaring authorization policies. Each policy that applies must pass independently in order for the request to be authorized. policy authorize_if forbid_if authorize_unless forbid_unless bypass authorize_if forbid_if authorize_unless forbid_unless Examples: policies do # Anything you can use in a condition, you can use in a check, and vice-versa # This policy applies if the actor is a super_user # Addtionally, this policy is declared as a `bypass`. That means that this check is allowed to fail without # failing the whole request, and that if this check *passes*, the entire request passes. bypass actor_attribute_equals ( :super_user , true ) do authorize_if always ( ) end # This will likely be a common occurrence. Specifically, policies that apply to all read actions policy action_type ( :read ) do # unless the actor is an active user, forbid their request forbid_unless actor_attribute_equals ( :active , true ) # if the record is marked as public, authorize the request authorize_if attribute ( :public , true ) # if the actor is related to the data via that data&#39;s `owner` relationship, authorize the request authorize_if relates_to_actor_via ( :owner ) end end Imports: AshPolicyAuthorizer.Check.BuiltInChecks Ash.Filter.TemplateHelpers :default_access_type - The default access type of policies for this resource. See the access type on individual policies for more information. The default value is :filter . policy A policy has a name, a condition, and a list of checks. Checks apply logically in the order they are specified, from top to bottom. If no check explicitly authorizes the request, then the request is forbidden. This means that, if you want to &quot;blacklist&quot; instead of &quot;whitelist&quot;, you likely want to add an authorize_if always() at the bottom of your policy, like so: policy action_type ( :read ) do forbid_if not_logged_in ( ) forbid_if user_is_denylisted ( ) forbid_if user_is_in_denylisted_group ( ) authorize_if always ( ) end If the policy should always run, use the always() check, like so: policy always ( ) do ... end authorize_if forbid_if authorize_unless forbid_unless Introspection Target: AshPolicyAuthorizer.Policy :description - A description for the policy, used when explaining authorization results :access_type - There are three choices for access_type: :strict - authentication uses only the request context, failing when unknown. :filter - this is probably what you want. Automatically removes unauthorized data by altering the request filter. :runtime - tries to add a filter before the query, but if it cannot, it fetches the records and checks authorization. Be careful with runtime checks, as they can potentially cause a given scenario to fetch all records of a resource, because it can't figure out a common filter between all of the possible scenarios. Use sparingly, if at all. :condition - A check or list of checks that must be true in order for this policy to apply. If the policy does not apply, it is not run, and some other policy will need to authorize the request. If no policies apply, the request is forbidden. If multiple policies apply, they must each authorize the request. authorize_if If the check is true, the request is authorized, otherwise run remaining checks. Introspection Target: AshPolicyAuthorizer.Policy.Check Examples: authorize_if logged_in ( ) authorize_if actor_attribute_matches_record ( :group , :group ) :check - Required. A check is a tuple of {module, keyword} . The module must implement the AshPolicyAuthorizer.Check behaviour. Generally, you won't be passing {module, opts} , but will use one of the provided functions that return that, like always() or actor_attribute_matches_record(:foo, :bar) . To make custom ones define a module that implements the AshPolicyAuthorizer.Check behaviour, put a convenience function in that module that returns {module, opts}, and import that into your resource. defmodule MyResource do use Ash.Resource , authorizers : [ AshPolicyAuthorizer.Authorizer ] import MyCustomCheck policies do ... policy do authorize_if my_custom_check ( :foo ) end end end :name - A short name or description for the check, used when explaining authorization results forbid_if If the check is true, the request is forbidden, otherwise run remaining checks. Introspection Target: AshPolicyAuthorizer.Policy.Check Examples: forbid_if not_logged_in ( ) forbid_if actor_attribute_matches_record ( :group , :blacklisted_groups ) :check - Required. A check is a tuple of {module, keyword} . The module must implement the AshPolicyAuthorizer.Check behaviour. Generally, you won't be passing {module, opts} , but will use one of the provided functions that return that, like always() or actor_attribute_matches_record(:foo, :bar) . To make custom ones define a module that implements the AshPolicyAuthorizer.Check behaviour, put a convenience function in that module that returns {module, opts}, and import that into your resource. defmodule MyResource do use Ash.Resource , authorizers : [ AshPolicyAuthorizer.Authorizer ] import MyCustomCheck policies do ... policy do authorize_if my_custom_check ( :foo ) end end end :name - A short name or description for the check, used when explaining authorization results authorize_unless If the check is false, the request is authorized, otherwise run remaining checks. Introspection Target: AshPolicyAuthorizer.Policy.Check Examples: authorize_unless not_logged_in ( ) authorize_unless actor_attribute_matches_record ( :group , :blacklisted_groups ) :check - Required. A check is a tuple of {module, keyword} . The module must implement the AshPolicyAuthorizer.Check behaviour. Generally, you won't be passing {module, opts} , but will use one of the provided functions that return that, like always() or actor_attribute_matches_record(:foo, :bar) . To make custom ones define a module that implements the AshPolicyAuthorizer.Check behaviour, put a convenience function in that module that returns {module, opts}, and import that into your resource. defmodule MyResource do use Ash.Resource , authorizers : [ AshPolicyAuthorizer.Authorizer ] import MyCustomCheck policies do ... policy do authorize_if my_custom_check ( :foo ) end end end :name - A short name or description for the check, used when explaining authorization results forbid_unless If the check is true, the request is forbidden, otherwise run remaining checks. Introspection Target: AshPolicyAuthorizer.Policy.Check Examples: forbid_unless logged_in ( ) forbid_unless actor_attribute_matches_record ( :group , :group ) :check - Required. A check is a tuple of {module, keyword} . The module must implement the AshPolicyAuthorizer.Check behaviour. Generally, you won't be passing {module, opts} , but will use one of the provided functions that return that, like always() or actor_attribute_matches_record(:foo, :bar) . To make custom ones define a module that implements the AshPolicyAuthorizer.Check behaviour, put a convenience function in that module that returns {module, opts}, and import that into your resource. defmodule MyResource do use Ash.Resource , authorizers : [ AshPolicyAuthorizer.Authorizer ] import MyCustomCheck policies do ... policy do authorize_if my_custom_check ( :foo ) end end end :name - A short name or description for the check, used when explaining authorization results bypass A policy that, if passed, will skip all following policies. If failed, authorization moves on to the next policy authorize_if forbid_if authorize_unless forbid_unless Introspection Target: AshPolicyAuthorizer.Policy :description - A description for the policy, used when explaining authorization results :access_type - There are three choices for access_type: :strict - authentication uses only the request context, failing when unknown. :filter - this is probably what you want. Automatically removes unauthorized data by altering the request filter. :runtime - tries to add a filter before the query, but if it cannot, it fetches the records and checks authorization. Be careful with runtime checks, as they can potentially cause a given scenario to fetch all records of a resource, because it can't figure out a common filter between all of the possible scenarios. Use sparingly, if at all. :condition - A check or list of checks that must be true in order for this policy to apply. If the policy does not apply, it is not run, and some other policy will need to authorize the request. If no policies apply, the request is forbidden. If multiple policies apply, they must each authorize the request. authorize_if If the check is true, the request is authorized, otherwise run remaining checks. Introspection Target: AshPolicyAuthorizer.Policy.Check Examples: authorize_if logged_in ( ) authorize_if actor_attribute_matches_record ( :group , :group ) :check - Required. A check is a tuple of {module, keyword} . The module must implement the AshPolicyAuthorizer.Check behaviour. Generally, you won't be passing {module, opts} , but will use one of the provided functions that return that, like always() or actor_attribute_matches_record(:foo, :bar) . To make custom ones define a module that implements the AshPolicyAuthorizer.Check behaviour, put a convenience function in that module that returns {module, opts}, and import that into your resource. defmodule MyResource do use Ash.Resource , authorizers : [ AshPolicyAuthorizer.Authorizer ] import MyCustomCheck policies do ... policy do authorize_if my_custom_check ( :foo ) end end end :name - A short name or description for the check, used when explaining authorization results forbid_if If the check is true, the request is forbidden, otherwise run remaining checks. Introspection Target: AshPolicyAuthorizer.Policy.Check Examples: forbid_if not_logged_in ( ) forbid_if actor_attribute_matches_record ( :group , :blacklisted_groups ) :check - Required. A check is a tuple of {module, keyword} . The module must implement the AshPolicyAuthorizer.Check behaviour. Generally, you won't be passing {module, opts} , but will use one of the provided functions that return that, like always() or actor_attribute_matches_record(:foo, :bar) . To make custom ones define a module that implements the AshPolicyAuthorizer.Check behaviour, put a convenience function in that module that returns {module, opts}, and import that into your resource. defmodule MyResource do use Ash.Resource , authorizers : [ AshPolicyAuthorizer.Authorizer ] import MyCustomCheck policies do ... policy do authorize_if my_custom_check ( :foo ) end end end :name - A short name or description for the check, used when explaining authorization results authorize_unless If the check is false, the request is authorized, otherwise run remaining checks. Introspection Target: AshPolicyAuthorizer.Policy.Check Examples: authorize_unless not_logged_in ( ) authorize_unless actor_attribute_matches_record ( :group , :blacklisted_groups ) :check - Required. A check is a tuple of {module, keyword} . The module must implement the AshPolicyAuthorizer.Check behaviour. Generally, you won't be passing {module, opts} , but will use one of the provided functions that return that, like always() or actor_attribute_matches_record(:foo, :bar) . To make custom ones define a module that implements the AshPolicyAuthorizer.Check behaviour, put a convenience function in that module that returns {module, opts}, and import that into your resource. defmodule MyResource do use Ash.Resource , authorizers : [ AshPolicyAuthorizer.Authorizer ] import MyCustomCheck policies do ... policy do authorize_if my_custom_check ( :foo ) end end end :name - A short name or description for the check, used when explaining authorization results forbid_unless If the check is true, the request is forbidden, otherwise run remaining checks. Introspection Target: AshPolicyAuthorizer.Policy.Check Examples: forbid_unless logged_in ( ) forbid_unless actor_attribute_matches_record ( :group , :group ) :check - Required. A check is a tuple of {module, keyword} . The module must implement the AshPolicyAuthorizer.Check behaviour. Generally, you won't be passing {module, opts} , but will use one of the provided functions that return that, like always() or actor_attribute_matches_record(:foo, :bar) . To make custom ones define a module that implements the AshPolicyAuthorizer.Check behaviour, put a convenience function in that module that returns {module, opts}, and import that into your resource. defmodule MyResource do use Ash.Resource , authorizers : [ AshPolicyAuthorizer.Authorizer ] import MyCustomCheck policies do ... policy do authorize_if my_custom_check ( :foo ) end end end :name - A short name or description for the check, used when explaining authorization results A resource can be given a set of policies, which are enforced on each call to a resource action. For reads, policies can be configured to filter out data that the actor shouldn't see, as opposed to resulting in a forbidden error. See the policy writing guide for practical examples. Policies are solved/managed via a boolean satisfiability solver. To read more about boolean satisfiability, see this page: https://en.wikipedia.org/wiki/Boolean_satisfiability_problem. At the end of the day, however, it is not necessary to understand exactly how Ash takes your authorization requirements and determines if a request is allowed. The important thing to understand is that Ash may or may not run any/all of your authorization rules as they may be deemed unnecessary. As such, authorization checks should have no side effects. Ideally, the checks built-in to ash should cover the bulk of your needs.","ref":"AshPolicyAuthorizer.Authorizer.html","title":"AshPolicyAuthorizer.Authorizer","type":"module"},{"doc":"","ref":"AshPolicyAuthorizer.Authorizer.html#t:t/0","title":"AshPolicyAuthorizer.Authorizer.t/0","type":"type"},{"doc":"The global authorization checks built into ash","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html","title":"AshPolicyAuthorizer.Check.BuiltInChecks","type":"module"},{"doc":"This check is true when the action name matches the provided action name","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#action/1","title":"AshPolicyAuthorizer.Check.BuiltInChecks.action/1","type":"function"},{"doc":"This check is true when the action type matches the provided type","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#action_type/1","title":"AshPolicyAuthorizer.Check.BuiltInChecks.action_type/1","type":"function"},{"doc":"This check is true when the value of the specified attribute equals the specified value","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#actor_attribute_equals/2","title":"AshPolicyAuthorizer.Check.BuiltInChecks.actor_attribute_equals/2","type":"function"},{"doc":"This check always passes","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#always/0","title":"AshPolicyAuthorizer.Check.BuiltInChecks.always/0","type":"function"},{"doc":"This check is true when a field on the record matches a specific filter","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#attribute/2","title":"AshPolicyAuthorizer.Check.BuiltInChecks.attribute/2","type":"function"},{"doc":"This check is true when attribute changes correspond to the provided options. Provide a keyword list of options or just an atom representing the attribute. For example: # if you are changing both first name and last name changing_attributes ( [ :first_name , :last_name ] ) # if you are changing first name to fred changing_attributes ( first_name : [ to : &quot;fred&quot; ] ) # if you are changing last name from bob changing_attributes ( last_name : [ from : &quot;bob&quot; ] ) # if you are changing :first_name at all, last_name from &quot;bob&quot; and middle name from &quot;tom&quot; to &quot;george&quot; changing_attributes ( [ :first_name , last_name : [ from : &quot;bob&quot; ] , middle_name : [ from : &quot;tom&quot; , to : &quot; george ] ] )","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#changing_attributes/1","title":"AshPolicyAuthorizer.Check.BuiltInChecks.changing_attributes/1","type":"function"},{"doc":"This check is true when the specified relationship is changing","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#changing_relationship/1","title":"AshPolicyAuthorizer.Check.BuiltInChecks.changing_relationship/1","type":"function"},{"doc":"This check is true when the specified relationships are changing","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#changing_relationships/1","title":"AshPolicyAuthorizer.Check.BuiltInChecks.changing_relationships/1","type":"function"},{"doc":"this check never passes","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#never/0","title":"AshPolicyAuthorizer.Check.BuiltInChecks.never/0","type":"function"},{"doc":"This check passes if the data relates to the actor via the specified relationship or path of relationships","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#relates_to_actor_via/1","title":"AshPolicyAuthorizer.Check.BuiltInChecks.relates_to_actor_via/1","type":"function"},{"doc":"This check is true when the specified relationship is being changed to the current actor","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#relating_to_actor/1","title":"AshPolicyAuthorizer.Check.BuiltInChecks.relating_to_actor/1","type":"function"},{"doc":"This check is true when the field is being selected and false when it is not","ref":"AshPolicyAuthorizer.Check.BuiltInChecks.html#selecting/1","title":"AshPolicyAuthorizer.Check.BuiltInChecks.selecting/1","type":"function"},{"doc":"The check module used for expr s in policies","ref":"AshPolicyAuthorizer.Check.Expression.html","title":"AshPolicyAuthorizer.Check.Expression","type":"module"},{"doc":"Callback implementation for AshPolicyAuthorizer.Check.auto_filter/3 .","ref":"AshPolicyAuthorizer.Check.Expression.html#auto_filter/3","title":"AshPolicyAuthorizer.Check.Expression.auto_filter/3","type":"function"},{"doc":"","ref":"AshPolicyAuthorizer.Check.Expression.html#auto_filter_not/3","title":"AshPolicyAuthorizer.Check.Expression.auto_filter_not/3","type":"function"},{"doc":"Callback implementation for AshPolicyAuthorizer.Check.check/4 .","ref":"AshPolicyAuthorizer.Check.Expression.html#check/4","title":"AshPolicyAuthorizer.Check.Expression.check/4","type":"function"},{"doc":"Callback implementation for AshPolicyAuthorizer.FilterCheck.reject/1 .","ref":"AshPolicyAuthorizer.Check.Expression.html#reject/1","title":"AshPolicyAuthorizer.Check.Expression.reject/1","type":"function"},{"doc":"Callback implementation for AshPolicyAuthorizer.Check.strict_check/3 .","ref":"AshPolicyAuthorizer.Check.Expression.html#strict_check/3","title":"AshPolicyAuthorizer.Check.Expression.strict_check/3","type":"function"},{"doc":"","ref":"AshPolicyAuthorizer.Check.Expression.html#strict_check_context/1","title":"AshPolicyAuthorizer.Check.Expression.strict_check_context/1","type":"function"},{"doc":"Callback implementation for AshPolicyAuthorizer.Check.type/0 .","ref":"AshPolicyAuthorizer.Check.Expression.html#type/0","title":"AshPolicyAuthorizer.Check.Expression.type/0","type":"function"},{"doc":"A behaviour for declaring checks, which can be used to easily construct authorization rules. If a check can be expressed simply as a function of the actor, or the context of the request, see AshPolicyAuthorizer.SimpleCheck for an easy way to write that check. If a check can be expressed simply with a filter statement, see AshPolicyAuthorizer.FilterCheck for an easy way to write that check.","ref":"AshPolicyAuthorizer.Check.html","title":"AshPolicyAuthorizer.Check","type":"behaviour"},{"doc":"An optional callback, that allows the check to work with policies set to access_type :filter Return a keyword list filter that will be applied to the query being made, and will scope the results to match the rule","ref":"AshPolicyAuthorizer.Check.html#c:auto_filter/3","title":"AshPolicyAuthorizer.Check.auto_filter/3","type":"callback"},{"doc":"An optional callback, hat allows the check to work with policies set to access_type :runtime Takes a list of records, and returns {:ok, true} if they are all authorized, or {:ok, list} containing the list of records that are authorized. You can also just return the whole list, {:ok, true} is just a shortcut. Can also return {:error, error} if something goes wrong","ref":"AshPolicyAuthorizer.Check.html#c:check/4","title":"AshPolicyAuthorizer.Check.check/4","type":"callback"},{"doc":"","ref":"AshPolicyAuthorizer.Check.html#defines_auto_filter?/1","title":"AshPolicyAuthorizer.Check.defines_auto_filter?/1","type":"function"},{"doc":"","ref":"AshPolicyAuthorizer.Check.html#defines_check?/1","title":"AshPolicyAuthorizer.Check.defines_check?/1","type":"function"},{"doc":"Describe the check in human readable format, given the options","ref":"AshPolicyAuthorizer.Check.html#c:describe/1","title":"AshPolicyAuthorizer.Check.describe/1","type":"callback"},{"doc":"Strict checks should be cheap, and should never result in external calls (like database or api) It should return {:ok, true} if it can tell that the request is authorized, and {:ok, false} if it can tell that it is not. If unsure, it should return {:ok, :unknown}","ref":"AshPolicyAuthorizer.Check.html#c:strict_check/3","title":"AshPolicyAuthorizer.Check.strict_check/3","type":"callback"},{"doc":"The type fo the check :manual checks must be written by hand as standard check modules :filter checks can use AshPolicyAuthorizer.FilterCheck for simplicity :simple checks can use AshPolicyAuthorizer.SimpleCheck for simplicity","ref":"AshPolicyAuthorizer.Check.html#c:type/0","title":"AshPolicyAuthorizer.Check.type/0","type":"callback"},{"doc":"","ref":"AshPolicyAuthorizer.Check.html#t:authorizer/0","title":"AshPolicyAuthorizer.Check.authorizer/0","type":"type"},{"doc":"","ref":"AshPolicyAuthorizer.Check.html#t:check_type/0","title":"AshPolicyAuthorizer.Check.check_type/0","type":"type"},{"doc":"","ref":"AshPolicyAuthorizer.Check.html#t:options/0","title":"AshPolicyAuthorizer.Check.options/0","type":"type"},{"doc":"A type of check that is represented by a filter statement That filter statement can be templated, currently only supporting {:_actor, field} which will replace that portion of the filter with the appropriate field value from the actor and {:_actor, :_primary_key} which will replace the value with a keyword list of the primary key fields of an actor to their values, like [id: 1] . If the actor is not present {:_actor, field} becomes nil , and {:_actor, :_primary_key} becomes false . You can customize what the &quot;negative&quot; filter looks like by defining reject/1 . This is important for filters over related data. For example, given an owner relationship and a data layer like ash_postgres where column != NULL does not evaluate to true (see postgres docs on NULL for more): # The opposite of ` owner . id == 1 ` # in most cases is not ` not ( owner . id == 1 ) ` # because in postgres that would be `NOT (owner.id = NULL)` in cases where there was no owner # A better opposite would be ` owner . id != 1 or is_nil ( owner . id ) ` # alternatively ` not ( owner . id == 1 ) or is_nil ( owner . id ) ` By being able to customize the reject filter, you can use related filters in your policies. Without it, they will likely have undesired effects.","ref":"AshPolicyAuthorizer.FilterCheck.html","title":"AshPolicyAuthorizer.FilterCheck","type":"behaviour"},{"doc":"","ref":"AshPolicyAuthorizer.FilterCheck.html#c:filter/1","title":"AshPolicyAuthorizer.FilterCheck.filter/1","type":"callback"},{"doc":"","ref":"AshPolicyAuthorizer.FilterCheck.html#is_filter_check?/1","title":"AshPolicyAuthorizer.FilterCheck.is_filter_check?/1","type":"function"},{"doc":"","ref":"AshPolicyAuthorizer.FilterCheck.html#c:reject/1","title":"AshPolicyAuthorizer.FilterCheck.reject/1","type":"callback"},{"doc":"","ref":"AshPolicyAuthorizer.FilterCheck.html#t:options/0","title":"AshPolicyAuthorizer.FilterCheck.options/0","type":"type"},{"doc":"A type of check that operates only on request context, never on the data Simply define match?/3 , which gets the actor, request context, and opts, and returns true or false","ref":"AshPolicyAuthorizer.SimpleCheck.html","title":"AshPolicyAuthorizer.SimpleCheck","type":"behaviour"},{"doc":"Whether or not the request matches the check","ref":"AshPolicyAuthorizer.SimpleCheck.html#c:match?/3","title":"AshPolicyAuthorizer.SimpleCheck.match?/3","type":"callback"},{"doc":"","ref":"AshPolicyAuthorizer.SimpleCheck.html#t:authorizer/0","title":"AshPolicyAuthorizer.SimpleCheck.authorizer/0","type":"type"},{"doc":"","ref":"AshPolicyAuthorizer.SimpleCheck.html#t:options/0","title":"AshPolicyAuthorizer.SimpleCheck.options/0","type":"type"},{"doc":"Raised when authorization for an action fails","ref":"AshPolicyAuthorizer.Forbidden.html","title":"AshPolicyAuthorizer.Forbidden","type":"exception"},{"doc":"Print a report of an authorization failure Options: :help_text? : Defaults to true. Displays help text at the top of the policy breakdown.","ref":"AshPolicyAuthorizer.Forbidden.html#report/2","title":"AshPolicyAuthorizer.Forbidden.report/2","type":"function"},{"doc":"Writing Policies Policies determine what actions on a resource are permitted for a given actor. You can specify an actor using the code api via the actor option, like so: MyApp.MyApi . read ( MyResource , actor : current_user )","ref":"writing_policies.html","title":"Writing Policies","type":"extras"},{"doc":"Before we jump into the guide, it is critical to understand that the policy code doesn't actually do anything in the classic sense. It simply builds up a set of policies that are stored for use later. The checker that reads those policies and authorizes requests may run all, some of, or none of your checks, depending on the details of the request being authorized.","ref":"writing_policies.html#important","title":"Writing Policies - Important!","type":"extras"},{"doc":"To see what checks are built-in, see AshPolicyAuthorizer.Check.BuiltInChecks The Simplest Policy Lets start with the simplest policy set: policies do policy always ( ) do authorize_if always ( ) end end Here, we have a single policy. The first argument to policy is the &quot;condition&quot;. If the condition is true, then the policy appolies to the request. If a given policy applies, then one of the checks inside the policy must authorize that policy. Every policy that applies to a given request must each be authorized for a request to be authorized. Within this policy we have a single check, declared with authorize_if . Checks logically apply from top to bottom, based on their check type. In this case, we'd read the policy as &quot;this policy always applies, and authorizes always&quot;. There are four check types, all of which do what they sound like they do: authorize_if - if the check is true, the policy is authorized. authorize_unless - if the check is false, the policy is authorized. forbid_if - if the check is true, the policy is forbidden. forbid_unless - if the check is false, the policy is forbidden. In each case, if the policy is not authorized or forbidden, the flow moves to the next check. A realistic policy In this example, we use some of the provided built in checks. policies do # Anything you can use in a condition, you can use in a check, and vice-versa # This policy applies if the actor is a super_user # Addtionally, this policy is declared as a `bypass`. That means that this check is allowed to fail without # failing the whole request, and that if this check *passes*, the entire request passes. bypass actor_attribute_equals ( :super_user , true ) do authorize_if always ( ) end # This will likely be a common occurrence. Specifically, policies that apply to all read actions policy action_type ( :read ) do # unless the actor is an active user, forbid their request forbid_unless actor_attribute_equals ( :active , true ) # if the record is marked as public, authorize the request authorize_if attribute ( :public , true ) # if the actor is related to the data via that data&#39;s `owner` relationship, authorize the request authorize_if relates_to_actor_via ( :owner ) end end Access Type The default access type is :filter . In most cases this will be all you need. In the example above, if a user made a request for all instances of the resource, it wouldn't actually return a forbidden error. It simply attaches the appropriate filter to fetch data that the user can see. If the actor attribute active was false , then the request would be forbidden (because there is no data for which they can pass this policy). However, if active is true , the authorizer would attach the following filter to the request: [ or : [ [ public : true ] , [ owner : actor ( :_primary_key ) ] ] ] To understand what actor(:_primary_key) means, see the Filter Templates section in Ash.Filter To change this behavior, use access_type :strict . With access_type :strict you will force the request to fail unless a filter was provided to yield the appropriate data. In this case, any filter that is a subset of the authorization filter would work. For example: [public: true] , or [owner: [id: current_user.id]] . Additionally, some checks have more expensive components that can't be checked before the request is run. To enable those, use the access_type :runtime . This is stil relatively experimental, but this will attempt to run as much of your checks in a strict fashion, and attach as many things as filters as possible, before running the expensive portion of the checks (defined on the check as AshPolicyAuthorizer.Check.check/4 ) Custom checks See AshPolicyAuthorizer.Check for more inforamtion on writing custom checks, which you will likely need at some point when the built in checks are insufficient More More will need to be written, as questions arise.","ref":"writing_policies.html#guide","title":"Writing Policies - Guide","type":"extras"},{"doc":"Policy Breakdowns","ref":"policy_breakdowns.html","title":"Policy Breakdowns","type":"extras"},{"doc":"Policy breakdowns can be fetched on demand for a given forbidden error (either an Ash.Error.Forbidden that contains one ore more AshPolicyAuthorizer.Forbidden errors, or an AshPolicyAuthorizer.Forbidden error itself), via AshPolicyAuthorizer.Forbidden.report/2 . Here is an example policy breakdown from ash_policy_authorizer tests: Policy Breakdown A check status of `?` implies that the solver did not need to determine that check. Some checks may look like they failed when in reality there was simply no need to check them. Look for policies with `âœ˜` and `âœ“` in check statuses. A check with a `â¬‡` means that it didn't determine if the policy was authorized or forbidden, and so moved on to the next check. `ðŸŒŸ` and `â›”` mean that the check was responsible for producing an authorized or forbidden (respectively) status. If no check results in a status (they all have `â¬‡`) then the policy is assumed to have failed. In some cases, however, the policy may have just been ignored, as described above. Admins and managers can create posts | â›”: authorize if: actor.admin == true | âœ˜ | â¬‡ authorize if: actor.manager == true | âœ˜ | â¬‡ To remove the help text, you can pass the help_text?: false option, which would leave you with: Policy Breakdown Admins and managers can create posts | â›”: authorize if: actor.admin == true | âœ˜ | â¬‡ authorize if: actor.manager == true | âœ˜ | â¬‡","ref":"policy_breakdowns.html#explanation","title":"Policy Breakdowns - Explanation","type":"extras"},{"doc":"IMPORTANT WARNING The following configuration should only ever be used in development mode! Instructions For security reasons, authorization errors don't include any extra information, aside from forbidden . To have authorization errors include a policy breakdown (without help text) use the following config. config :ash_policy_authorizer , show_policy_breakdowns? : true","ref":"policy_breakdowns.html#including-in-error-message","title":"Policy Breakdowns - Including in error message","type":"extras"},{"doc":"It is generally safe to log authorization error details, even in production. This can be very helpful when investigating certain classes of issue. To have ash_policy_authorizer automatically log each authorization failure, use config :ash_policy_authorizer , log_policy_breakdowns : :error # Use whatever log level you&#39;d like to use here","ref":"policy_breakdowns.html#logging","title":"Policy Breakdowns - Logging","type":"extras"}]