searchData={"items":[{"type":"module","title":"AshPagify","doc":"AshPagify is an Elixir library designed to easily add full-text search, scoping, filtering,\nordering, and pagination APIs for the [Ash Framework](https://hexdocs.pm/ash).\n\nIt takes concepts from `Flop`, `Flop.Phoenix`, `Ash` and `AshPhoenix.FilterForm` and\ncombines them into a single library.\n\nIt's main purpose is to provide functions to convert user input for full-text search, scoping,\nfiltering, ordering, and pagination into the following data structures:\n\n1. `AshPagify.Meta` a struct holding information of a db query result.\n2. query parameters for url building and to restore the query parameters from the url.\n3. a basic map syntax which for example can be stored in a session or database (and restore\n  the information from it).\n\nFurther, it provides headless components to build sortable tables and pagination links in your\nPhoenix LiveView with the `AshPagify.Components` module. Finally, it provides a simple way to build\nfilter forms for your LiveView with the `AshPagify.FilterForm` struct.","ref":"AshPagify.html"},{"type":"module","title":"Examples - AshPagify","doc":"```elixir\nash_pagify = %AshPagify{\n  search: \"Post 1\",\n  scopes: %{role: :admin},\n  filters: %{\"comments_count\" => %{\"gt\" => 2}},\n  filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"},\n  order_by: :name,\n  limit: 10,\n  offset: 0\n}\nopts = [full_text_search: [tsvector: :custom_tsvector]]\n\nAshPagify.query_to_filters_map(Post, ash_pagify, opts).filters\n%{\n  \"__full_text_search\" => %{\n    \"search\" => \"Post 1\",\n    \"tsvector\" => \"custom_tsvector\"\n  },\n  \"and\" => [\n    %{\"comments_count\" => %{\"gt\" => 2}},\n    %{\"name\" => %{\"eq\" => \"Post 1\"}},\n    %{\"author\" => \"John\"}\n  ]\n}\n\nAshPagify.Components.build_path(\"/posts\", ash_pagify, opts)\n\"/posts?search=Post+1&limit=10&scopes[role]=admin&filter_form[field]=name&filter_form[operator]=eq&filter_form[value]=Post+1&order_by[]=name\"\n```","ref":"AshPagify.html#module-examples"},{"type":"module","title":"Features - AshPagify","doc":"- **Full-text search**: AshPagify supports full-text search using the `tsvector` column in PostgreSQL.\n- **Offset-based pagination**: AshPagify uses `OFFSET` and `LIMIT` to paginate your queries.\n- **Scoping**: Apply predefined filters to your queries using a simple map syntax.\n- **Filtering**: Apply user-input filters to your queries using a simple map syntax. Allows complex data filtering using multiple conditions, operators, and fields. Also incooperates with `AshPhoenix.FilterForm` to provide a simple way to build complex filter user interfaces.\n- **Sorting**: Sort your queries by multiple fields and any directions.\n- **UI helpers and URL builders**: AshPagify provides a `AshPagify.Meta` struct with information about the current page, total pages, and more. This information can be used to build pagination links in your UI. Further, `AshPagify` provides the `AshPagify.Components` module with headless table and pagination components to easily build sortable tables and pagination links in your Phoenix LiveView. The `AshPagify.FilterForm` module provides a simple way to build filter forms for your LiveView.","ref":"AshPagify.html#module-features"},{"type":"module","title":"Overview - AshPagify","doc":"- [Examples](#examples)\n- [Features](#features)\n- [Installation](#installation)\n- [Global configuration](#global-configuration)\n- [Resource configuration](#resource-configuration)\n- [LiveView configuration](#liveview-configuration)\n  - [LiveView streams](#liveview-streams)\n  - [Replace invalid params](#replace-invalid-params)\n  - [Custom read action](#custom-read-action)\n- [Full-text search](#full-text-search)\n- [Sortable tables and pagination](#sortable-tables-and-pagination)\n- [Parameter format](#parameter-format)\n  - [Search query](#search-query)\n  - [Pagination](#pagination)\n  - [Scoping](#scoping)\n  - [Filter forms](#filter-forms)\n  - [Ordering](#ordering)\n  - [Internal parameters](#internal-parameters)\n- [Release Management](#release-management)","ref":"AshPagify.html#module-overview"},{"type":"module","title":"Installation - AshPagify","doc":"AshPagify requires the following dependencies to be installed:\n\n- `Ash` - The main library for building queries.\n- `ash_phoenix` - The Phoenix integration for Ash.\n- `AshPostgres` - The PostgreSQL integration for Ash.\n- `AshUUID` - The UUID integration for Ash.\n- `Phoenix` - The Phoenix web framework.\n\nThen simply add `ash_pagify` to your list of dependencies in `mix.exs` and run\n`mix deps.get`:\n\n```elixir\ndef deps do\n  [\n    {:ash_pagify, \"~> 1.0.2\"}\n  ]\nend\n```","ref":"AshPagify.html#module-installation"},{"type":"module","title":"Global configuration - AshPagify","doc":"You can set some global options like the default_limit via the application\nenvironment. All global options can be overridden by passing them directly to\nthe functions.\n\n```elixir\nconfig :ash_pagify,\n  default_limit: 50,\n  max_limit: 1000,\n  replace_invalid_params?: true,\n  ash_pagify_scopes: %{\n    role: [\n      %{name: :all, filter: nil},\n      %{name: :admin, filter: %{role: \"admin\"}},\n      %{name: :user, filter: %{role: \"user\"}}\n    ]\n  },\n  reset_on_filter?: true,\n  full_text_search: [\n    negation: true,\n    prefix: true,\n    any_word: false\n  ]\n```\n\nSee `t:AshPagify.option/0` for a description of all available options.","ref":"AshPagify.html#module-global-configuration"},{"type":"module","title":"Resource configuration - AshPagify","doc":"You need to add the `pagination macro` call to the action of the resource that you\nwant to be paginated. The macro call is used to set the default limit, offset and\nother options for the pagination.\n\nFurthermore, you can define scopes in the resource module. Scopes are predefined\nfilters that can be applied to the query.\n\nWe allow full-text search using the `tsvector` column in PostgreSQL. To enable full-text search,\nyou need to either `use AshPagify.Tsearch` in your module or implement the `full_text_search`,\n`full_text_search_rank`, `tsquery`, and `tsvector` calculations as described in `AshPagify.Tsearch`\n(tsvector calculation  is always mandatory).\n\n```elixir\ndefmodule YourApp.Resource.Post\n  # only required if you want to implement full-text search\n  use AshPagify.Tsearch\n  require Ash.Expr\n\n  @default_limit 15\n  def default_limit, do: @default_limit\n\n  @ash_pagify_scopes %{\n    role: [\n      %{name: :all, filter: nil},\n      %{name: :admin, filter: %{author: \"John\"}},\n      %{name: :user, filter: %{author: \"Doe\"}}\n    ]\n  }\n  def ash_pagify_scopes, do: @ash_pagify_scopes\n\n  actions do\n    read :read do\n      #...\n      pagination offset?: true,\n                default_limit: @default_limit,\n                countable: true,\n                required?: false\n    end\n  end\n\n  calculations do\n    # provide your default `tsvector` calculation for full-text search\n    calculate :tsvector,\n              AshPostgres.Tsvector,\n              expr(\n                fragment(\n                  \"to_tsvector('simple', coalesce(?, '')) || to_tsvector('simple', coalesce(?, ''))\",\n                  name,\n                  title\n                )\n              ),\n              public?: true\n  end\n  #...\nend\n```","ref":"AshPagify.html#module-resource-configuration"},{"type":"module","title":"LiveView configuration - AshPagify","doc":"In your LiveView, fetch the data and assign it alongside the meta data to the socket.\n\n```elixir\ndefmodule YourAppWeb.PostLive.IndexLive do\n  use YourAppWeb, :live_view\n\n  alias YourApp.Resource.Post\n\n  @impl true\n  def handle_params(params, _, socket) do\n    case Post.list_posts(params) do\n      {:ok, {posts, meta}} ->\n        {:noreply, assign(socket, %{posts: posts, meta: meta})}\n      {:error, _meta} ->\n        # This will reset invalid parameters. Alternatively, you can assign\n        # only the meta and render the errors, or assign the validated params,\n        # or you can ignore the error case entirely.\n        {:noreply, push_navigate(socket, to: ~p\"/posts\")}\n    end\n  end\n\n  defp list_posts(params, opts \\\\ []) do\n    AshPagify.validate_and_run(Post, params, opts)\n  end\nend\n```","ref":"AshPagify.html#module-liveview-configuration"},{"type":"module","title":"LiveView streams - AshPagify","doc":"To use LiveView streams, you can change your `handle_params/3` function as follows:\n\n```elixir\ndef handle_params(params, _, socket) do\n  case Post.list_posts(params) do\n    {:noreply,\n        socket\n        |> assign(:meta, meta)\n        |> stream(:posts, posts, reset: true)}\n  # ...\n  end\nend\n```","ref":"AshPagify.html#module-liveview-streams"},{"type":"module","title":"Replace invalid params - AshPagify","doc":"To replace invalid ash_pagify parameters with their default values, you can use the `replace_invalid_params?` option. You can change your `handle_params/3` function as follows:\n\n```elixir\ndef handle_params(params, _, socket) do\n  case Post.list_posts(params, replace_invalid_params?: true) do\n      {:ok, {posts, meta}} ->\n        {:noreply, assign(socket, %{posts: posts, meta: meta})}\n      {:error, meta} ->\n        valid_path = AshPagify.Components.build_path(~p\"/posts\", meta.params)\n        {:noreply, push_navigate(socket, to: valid_path)}\n  # ...\n  end\nend\n```","ref":"AshPagify.html#module-replace-invalid-params"},{"type":"module","title":"Custom read action - AshPagify","doc":"If the `:action` option is set (to perform a custom read action), the fourth argument\n`args` will be passed to the action as arguments.\n\n```elixir\n%Ash.Page.Offset{count: count} = AshPagify.all(Comment, %AshPagify{}, [action: :by_post], post.id)\n```","ref":"AshPagify.html#module-custom-read-action"},{"type":"module","title":"Full-text search - AshPagify","doc":"We allow full-text search using the `tsvector` column in PostgreSQL. To enable full-text search,\nyou need to either `use AshPagify.Tsearch` in your module or implement the `full_text_search`,\n`full_text_search_rank`, `tsquery`, and `tsvector` calculations as described in `AshPagify.Tsearch`\n(tsvector calculation  is always mandatory).\n\n```elixir\n# provide the default tsvector calculation for full-text search\ncalculate :tsvector,\n          AshPostgres.Tsvector,\n          expr(\n            fragment(\n              \"to_tsvector('simple', coalesce(?, '')) || to_tsvector('simple', coalesce(?, ''))\",\n              name,\n              title\n            )\n          ),\n          public?: true\n```\n\nOr if you want to use a generated tsvector column, you can replace the fields\npart with the name of your generated tsvector column:\n\n```elixir\n# use a tsvector column from the database\ncalculate :tsvector, AshPostgres.Tsvector, expr(tsv), public?: true\n```\n\nYou can also configure `dynamic` tsvectors based on user input. Have a look at the\n`AshPagify.Tsearch` module for more information.\n\nOnce configured, you can use the `search` parameter to apply full-text search.","ref":"AshPagify.html#module-full-text-search"},{"type":"module","title":"Sortable tables and pagination - AshPagify","doc":"To add a sortable table and pagination links, you can add the following to your template:\n\n```elixir\n Posts \n\n \n  <:col :let={post} label=\"Name\" field={:name}><%= post.name %></:col>\n  <:col :let={post} label=\"Author\" field={:author}><%= post.author %></:col>\n \n\n \n```\n\nIn this context, path points to the current route, and AshPagify Components appends\nfull-text search, pagination, scoping, filtering, and sorting parameters to it.\nYou can use verified routes, route helpers, or custom path builder functions.\nYou'll find explanations for the different formats in the documentation for\n`AshPagify.Components.build_path/3`.\n\nNote that the field attribute in the `:col` slot is optional. If set and the\ncorresponding field in the resource is defined as sortable, the table header for\nthat column will be interactive, allowing users to sort by that column. However,\nif the field isn't defined as sortable, or if the field attribute is omitted, or\nset to `nil` or `false`, the table header will not be clickable.\n\nYou also have the option to pass a `Phoenix.LiveView.JS` command instead of or\nin addition to a path. For more details, please refer to the component\ndocumentation.","ref":"AshPagify.html#module-sortable-tables-and-pagination"},{"type":"module","title":"Parameter format - AshPagify","doc":"The AshPagify library requires parameters to be provided in a specific format as a map.\nThis map can be translated into a URL query parameter string, typically for use in a\nweb framework like Phoenix.\n\nThe following parameters are encoded as strings and handled by the library:\n\n- `search` - A string to search for in the full-text search column or in the searchable fields.\n- `limit` - The number of records to return.\n- `offset` - The number of records to skip.\n- `scopes` - A map of predefined filters to apply to the query.\n- `filter_form` - A map of filters provided by the `AshPagify.FilterForm` module.\n- `order_by` - A list of fields to order by.","ref":"AshPagify.html#module-parameter-format"},{"type":"module","title":"Search query - AshPagify","doc":"You can search for a string in a full-text search column.\n\n```elixir\n%{search: \"John\"}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?search=John\n```\n\nYou can use the `AshPagify.set_search/3` function to set the search query in the\n`AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.set_search(%AshPagify{}, \"John\")\n```","ref":"AshPagify.html#module-search-query"},{"type":"module","title":"Pagination - AshPagify","doc":"You can specify an offset to start from and a limit to the number of results.\n\n```elixir\n%{offset: 100, limit: 20}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?offset=100&limit=20\n```\n\nYou can use the `AshPagify.set_offset/2` and `AshPagify.set_limit/3` functions to set\nthe offset and limit in the `AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.set_offset(%AshPagify{}, 100)\nash_pagify = AshPagify.set_limit(ash_pagify, 20)\n```","ref":"AshPagify.html#module-pagination"},{"type":"module","title":"Scoping - AshPagify","doc":"To apply predefined filters to a query, you can set the `:scopes` parameter. `:scopes`\nshould be a map of predefined filters (maps) available in your resource. The filter name\nis used to look up the predefined filter. If the filter is found, it is applied to\nthe query. If the filter is not found, an error is raised.\n\n```elixir\n%{scopes: %{role: :admin}}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?scopes[role]=admin\n```\n\nYou can use the `AshPagify.set_scope/3` function to set the scopes in the `AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.set_scope(%AshPagify{}, %{role: :admin})\n```","ref":"AshPagify.html#module-scoping"},{"type":"module","title":"Filter forms - AshPagify","doc":"Filter forms can be passed as a map of filter conditions. Usually, this map is generated\nby a filter form component using the `AshPagify.FilterForm` module. `AshPagify.FilterForm.params_for_query/2`\ncan be used to convert the form filter map into a query map.\n\n```elixir\n%{filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?filter_form[name][eq]=Post%201\n```\n\nYou can use the `AshPagify.set_filter_form/3` function to set the filter form in the `AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.set_filter_form(%AshPagify{}, %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"})\n```\n\nCheck the `AshPhoenix.FilterForm` documentation for more information.\nSee `Ash.Query.filter/2` for a list of all available filter operators.","ref":"AshPagify.html#module-filter-forms"},{"type":"module","title":"Ordering - AshPagify","doc":"To add an ordering clause to a query, you need to set the `:order_by`\nparameter. `:order_by` should be a list of fields, aggregates, or calculations\navailable in your resource. The order direction can be set by adding\none of the following prefixes to the field name:\n\n- `\"\"` or `+` for ascending order\n- `-` for descending order\n- `++` for ascending order with nulls first\n- `--` for descending order with nulls last\n\nIf no order directions are given, `:asc` is used as default.\n\n```elixir\n%{order_by: [\"name\", \"--author\"]}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?order_by=[]name&oder_by[]=--author\n```\n\nYou can use the `AshPagify.push_order/3` function to set the order by clause in the `AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.push_order(%AshPagify{}, \"name\")\n```","ref":"AshPagify.html#module-ordering"},{"type":"module","title":"Internal parameters - AshPagify","doc":"AshPagify is designed to manage parameters that come from the user side. While it is\npossible to alter those parameters and append extra filters upon receiving them,\nit is advisable to clearly differentiate parameters coming from outside and the\nparameters that your application adds internally.\n\nConsider the scenario where you need to scope a query based on the current user.\nIn this case, it is better to create a separate function that introduces the\nnecessary filter clauses:\n\n```elixir\ndef list_posts(%{} = params, %User{} = current_user) do\n  Post\n  |> scope(current_user)\n  |> AshPagify.validate_and_run(params)\nend\n\ndefp scope(query, %User{role: :admin}), do: query\ndefp scope(query, %User{id: user_id}), do: Ash.Query.filter_input(query, %{user_id: ^user_id})\n```\n\nIf you need to add extra filters that are only used internally and aren't exposed to the user,\nyou can pass them as a separate argument. This same argument can be used to override certain\noptions depending on the context in which the function is called.\n\n```elixir\ndef list_posts(%{} = params, opts \\\\\\\\ [], %User{} = current_user) do\n  ash_pagify_opts =\n    opts\n    |> Keyword.put(:max_limit, 10)\n    |> Keyword.put(:default_limit, 10)\n    |> Keyword.put(:replace_invalid_params?, true)\n\n  Post\n  |> scope(current_user)\n  |> apply_filters(opts)\n  |> AshPagify.validate_and_run(params, ash_pagify_opts)\nend\n\ndefp scope(query, %User{role: :admin}), do: query\ndefp scope(query, %User{id: user_id}), do: Ash.Query.filter_input(query, %{user_id: ^user_id})\n\ndefp apply_filters(query, opts) do\n  Enum.reduce(opts, query, fn\n    {:updated_at, dt}, query -> Ash.Query.filter_input(query, %{updated_at: dt})\n    _, query -> query\n  end)\nend\n```\n\nWith this approach, you maintain a clean separation between user-driven parameters and\nsystem-driven parameters, leading to more maintainable and less error-prone code. Please be\naware that in most cases it is better to use `Ash.Policy` to manage access control. This\nexample is just to illustrate the concept.\n\nUnder the hood, the `AshPagify.validate_and_run/4` or `AshPagify.validate_and_run!/4` functions\njust call `AshPagify.validate/2` and `AshPagify.run/4`, which in turn calls `AshPagify.all/4` and\n`AshPagify.meta/3`.\n\nSee `AshPagify.Meta` for descriptions of the meta fields.\n\nAlternatively, you may separate parameter validation and data fetching into different\nsteps using the `AshPagify.validate/2`, `AshPagify.validate!/2`, and `AshPagify.run/4` functions.\nThis allows you to manipulate the validated parameters, to modify the query depending on\nthe parameters, or to move the parameter validation to a different layer of your application.\n\n```elixir\nwith {:ok, ash_pagify} <- AshPagify.validate(Post, params) do\n  {:ok, {results, meta}} = AshPagify.run(Post, ash_pagify)\nend\n```\n\nThe aforementioned functions internally call the lower-level functions `AshPagify.all/4` and\n`AshPagify.meta/3`. If you have advanced requirements, you might prefer to use these functions\ndirectly. However, it's important to note that these lower-level functions do not validate\nthe parameters. If parameters are generated based on user input, they should always be\nvalidated first using `AshPagify.validate/2` or `AshPagify.validate!/2` to ensure safe execution.","ref":"AshPagify.html#module-internal-parameters"},{"type":"module","title":"Release Management - AshPagify","doc":"We use [git_opts](https://hexdocs.pm/git_ops/readme.html) to manage our releases. To create a new release, run:\n\n```bash\nmix git_ops.release\n```\n\nThis will bump the version, create a new tag, and push the changes to the repository. The GitHub action will then build and publish the new version to Hex.","ref":"AshPagify.html#module-release-management"},{"type":"function","title":"AshPagify.active_scope?/2","doc":"Helper function to check if a scope is active in a AshPagify struct.","ref":"AshPagify.html#active_scope?/2"},{"type":"function","title":"Examples - AshPagify.active_scope?/2","doc":"iex> active_scope?(%AshPagify{scopes: %{status: :active}}, %{status: :active})\n    true\n\n    iex> active_scope?(%AshPagify{scopes: %{status: :active}}, %{status: :inactive})\n    false\n\n    iex> active_scope?(%AshPagify{scopes: %{status: :active}}, %{role: :admin})\n    false\n\n    iex> active_scope?(%AshPagify{}, %{role: :admin})\n    false","ref":"AshPagify.html#active_scope?/2-examples"},{"type":"function","title":"AshPagify.all/4","doc":"Returns an `t:Ash.Page.Offset.t/0` struct from the given `t:Ash.Query.t/0` or `t:Ash.Resource.t/0`\nwith the given `t:AshPagify.t/0` parameters and `t:Keyword.t/0` options.\n\nThe `opts` keyword list is used to pass additional options to the query engine.\nIt should conform to the list of valid options at `Ash.read/2`.\n\n- `AshPagify.search` is used to apply full-text search to the query.\n- `Paigfy.scopes` are used to apply predefined filters to the query.\n- `AshPagify.filter_form` is used to apply filters generated by the `AshPhoenix.FilterForm` module.\n- `AshPagify.filters` and `AshPagify.order_by` are used to filter and order the query.\n- `AshPagify.limit` and `AshPagify.offset` are used to paginate the query.\n\nThe user input parameters are represented by the `t:AshPagify.t/0` type. Any `nil` values\nwill be ignored.\n\nIf the `:action` option is set (to perform a custom read action), the fourth argument\n`args` will be passed to the action as arguments.","ref":"AshPagify.html#all/4"},{"type":"function","title":"Examples - AshPagify.all/4","doc":"iex> alias AshPagify.Factory.Post\n    iex> %Ash.Page.Offset{results: r} =  AshPagify.all(Post, %AshPagify{filters: %{name: \"inexistent\"}})\n    iex> r\n    []\n\nOr with an initial query:\n\n    iex> alias AshPagify.Factory.Post\n    iex> q = Ash.Query.filter_input(Post, %{name: \"inexistent\"})\n    iex> %Ash.Page.Offset{results: r} = AshPagify.all(q, %AshPagify{})\n    iex> r\n    []\n\nOr with a custom read action:\n    iex> alias AshPagify.Factory.Post\n    iex> alias AshPagify.Factory.Comment\n    iex> Comment.read!() |> Enum.count()\n    9\n    iex> ash_pagify = %AshPagify{limit: 1, filters: %{name: \"Post 1\"}}\n    iex> %Ash.Page.Offset{results: posts} = AshPagify.all(Post, ash_pagify)\n    iex> post = hd(posts)\n    iex> %Ash.Page.Offset{count: count} = AshPagify.all(Comment, %AshPagify{}, [action: :by_post], post.id)\n    iex> count\n    2\n\nOr with scopes:\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{scopes: %{role: :admin}}\n    iex> %Ash.Page.Offset{count: count} = AshPagify.all(Post, ash_pagify)\n    iex> count\n    1\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#all/4-examples"},{"type":"function","title":"AshPagify.coerce_order_by/1","doc":"Transforms the given `order_by` parameter into a list of tuples with\nthe field and the default :asc direction.","ref":"AshPagify.html#coerce_order_by/1"},{"type":"function","title":"Examples - AshPagify.coerce_order_by/1","doc":"iex> coerce_order_by(nil)\n    []\n    iex> coerce_order_by([])\n    []\n    iex> coerce_order_by(:name)\n    [name: :asc]\n    iex> coerce_order_by(\"name\")\n    [name: :asc]\n    iex> coerce_order_by({:name, :asc})\n    [name: :asc]\n    iex> coerce_order_by([name: :asc, age: :desc])\n    [name: :asc, age: :desc]","ref":"AshPagify.html#coerce_order_by/1-examples"},{"type":"function","title":"AshPagify.concat_sort/2","doc":"Transforms the given `order_by` parameter into a list of strings (user input domain).","ref":"AshPagify.html#concat_sort/2"},{"type":"function","title":"AshPagify.count/3","doc":"Returns the total count of entries matching the full-text search, filters, filter_form,\nand scopes conditions in the given `t:Ash.Query.t/0` or `t:Ash.Resource.t/0` with the\ngiven `t:AshPagify.t/0` parameters and `t:Keyword.t/0` options.\n\nThe pagination and ordering options are disregarded.\n\n    iex> alias AshPagify.Factory.Post\n    iex> AshPagify.count(Post, %AshPagify{})\n    3\n\nYou can override the default query by passing the `:count_query` option. This\ndoesn't make a lot of sense when you use `count/3` directly, but allows you to\noptimize the count query when you use one of the `run/4`,\n`validate_and_run/4` and `validate_and_run!/4` functions.\n\n    query = some expensive query\n    count_query = Ash.Query.new(Post)\n    AshPagify.count(Post, %AshPagify{}, count_query: count_query)\n\nThe full-text search and various filter parameters of the given AshPagify are applied\nto the custom count query.\n\nIf for some reason you already have the count, you can pass it as the `:count`\noption.\n\n    count(query, %AshPagify{}, count: 42, for: Post)\n\nIf you pass both the `:count` and the `:count_query` options, the `:count`\noption will take precedence.\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine. Or you can use `AshPagify.validate_and_run/4` or\n`AshPagify.validate_and_run!/4` instead of this function.","ref":"AshPagify.html#count/3"},{"type":"function","title":"AshPagify.current_order/2","doc":"Returns the current order direction for the given field.","ref":"AshPagify.html#current_order/2"},{"type":"function","title":"Examples - AshPagify.current_order/2","doc":"iex> ash_pagify = %AshPagify{order_by: [name: :desc, age: :asc]}\n    iex> current_order(ash_pagify, :name)\n    :desc\n    iex> current_order(ash_pagify, :age)\n    :asc\n    iex> current_order(ash_pagify, :species)\n    nil\n\nIf the field is not an atom, the function will return `nil`.\n\n    iex> ash_pagify = %AshPagify{order_by: [name: :desc]}\n    iex> current_order(ash_pagify, \"name\")\n    nil\n\nIf `AshPagify.order_by` is nil, the function will return `nil`.\n\n    iex> current_order(%AshPagify{}, :name)\n    nil","ref":"AshPagify.html#current_order/2-examples"},{"type":"function","title":"AshPagify.extract_full_text_search/1","doc":"Extracts the full-text search setting from the filters map and returns a tuple of the filters map\nwithout the full-text search setting and the full-text search setting.\n\nThe full-text search setting is stored under the key `\"__full_text_search\"` in the\nfilters map (on in the `and` or `or` base of the filters_map). If the full-text\nsearch setting is not found, the function will return the filters map as is.","ref":"AshPagify.html#extract_full_text_search/1"},{"type":"function","title":"AshPagify.filter/2","doc":"Applies the `filter` parameter of a `t:AshPagify.t/0` to an `t:Ash.Query.t/0`.\n\nUsed by `AshPagify.query/2`. See `Ash.Query.filter/2` for more information.\n\nFor a completed list of filter operators, see `Ash.Filter`.\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#filter/2"},{"type":"function","title":"Examples - AshPagify.filter/2","doc":"iex> alias AshPagify.Factory.Post\n      iex> q = Ash.Query.new(Post)\n      iex> ash_pagify = %AshPagify{filters: %{name: \"foo\"}}\n      iex> filter(q, ash_pagify)\n      #Ash.Query >\n\nOr multiple filters:\n\n      iex> alias AshPagify.Factory.Post\n      iex> q = Ash.Query.new(Post)\n      iex> ash_pagify = %AshPagify{filters: %{name: \"foo\", id: \"1\"}}\n      iex> filter(q, ash_pagify)\n      #Ash.Query >\n\nOr by relation:\n\n      iex> alias AshPagify.Factory.Post\n      iex> q = Ash.Query.new(Post)\n      iex> ash_pagify = %AshPagify{filters: %{comments: %{body: \"foo\"}}}\n      iex> filter(q, ash_pagify)\n      #Ash.Query >","ref":"AshPagify.html#filter/2-examples"},{"type":"function","title":"AshPagify.filter_form/2","doc":"Applies the `filter_form` parameter of a `t:AshPagify.t/0` to an `t:Ash.Query.t/0`.\n\nUsed by `AshPagify.query/2`. See `AshPhoenix.FilterForm` for more information.\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#filter_form/2"},{"type":"function","title":"Examples - AshPagify.filter_form/2","doc":"iex> alias AshPagify.Factory.Post\n    iex> q = Ash.Query.new(Post)\n    iex> ash_pagify = %AshPagify{filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}}\n    iex> filter_form(q, ash_pagify)\n    #Ash.Query >","ref":"AshPagify.html#filter_form/2-examples"},{"type":"function","title":"AshPagify.filter_form_to_filter_map/2","doc":"Transforms the `filter_form` parameter of a `t:AshPagify.t/0` into a filter map.\n\nUsed by `AshPagify.filter_form/2`. See `AshPhoenix.FilterForm` for more information.\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#filter_form_to_filter_map/2"},{"type":"function","title":"Examples - AshPagify.filter_form_to_filter_map/2","doc":"iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}}\n    iex> filter_form_to_filter_map(Post, ash_pagify.filter_form)\n    %{\"and\" => [%{\"name\" => %{\"eq\" => \"Post 1\"}}]}","ref":"AshPagify.html#filter_form_to_filter_map/2-examples"},{"type":"function","title":"AshPagify.get_index/2","doc":"Finds the current index of a field in the `order_by` list.\n\nFollowing rules are applied:\n\n- if the `order_by` is `nil`, `nil` is returned\n- if the `order_by` is an atom or a binary, `nil` is returned\n- if the `order_by` is a tuple, `nil` is returned\n- if the `order_by` is a list, the index of the field is returned","ref":"AshPagify.html#get_index/2"},{"type":"function","title":"AshPagify.get_option/3","doc":"Returns the option with the given key.\n\nThe look-up order is:\n\n1. the keyword list passed as the second argument\n2. the Ash.Resource resource, if the passed list includes the `:for` option\n3. the application environment\n4. the AshPagify default value if defined\n5. the default passed as the last argument\n\nFor the `:ash_pagify_scopes` option, the function will deep merge the options\nin reverse order (keyword overrides resource, resource overrides global, etc.)","ref":"AshPagify.html#get_option/3"},{"type":"function","title":"Examples for `:ash_pagify_scopes` - AshPagify.get_option/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> opts = [\n    ...>   ash_pagify_scopes: %{\n    ...>     role: [\n    ...>       %{name: :user, filter: %{name: \"changed\"}},\n    ...>       %{name: :other, filter: %{name: \"other\"}}\n    ...>     ],\n    ...>     status: [\n    ...>       %{name: :all, filter: nil, default?: true},\n    ...>       %{name: :active, filter: %{age: %{lt: 10}}},\n    ...>       %{name: :inactive, filter: %{age: %{gte: 10}}}\n    ...>     ]\n    ...>   },\n    ...>   for: Post\n    ...> ]\n    iex> get_option(:ash_pagify_scopes, opts, %{\n    ...>   role: [\n    ...>     %{name: :default, filter: %{author: \"Default\"}}\n    ...>   ]\n    ...> })\n    %{\n      role: [\n        %{name: :admin, filter: %{author: \"John\"}},\n        %{name: :user, filter: %{name: \"changed\"}},\n        %{name: :other, filter: %{name: \"other\"}},\n        %{name: :default, filter: %{author: \"Default\"}}\n      ],\n      status: [\n        %{name: :inactive, filter: %{age: %{gte: 10}}},\n        %{name: :all, filter: nil, default?: true},\n        %{name: :active, filter: %{age: %{lt: 10}}}\n      ]\n    }","ref":"AshPagify.html#get_option/3-examples-for-ash_pagify_scopes"},{"type":"function","title":"AshPagify.get_order_direction/2","doc":"Returns the current order direction for the given index and `AshPagify.order_by`.\n\nFollowing rules are applied:\n\n- if the `order_by` is `nil`, `nil` is returned\n- if the `order_by` is an atom or a binary, `:asc` is returned\n- if the `order_by` is a tuple, the second element of the tuple is returned\n- if the index is out of bounds, `nil` is returned\n- if the `order_by` is a list, the direction of the element at the given index\nis returned","ref":"AshPagify.html#get_order_direction/2"},{"type":"function","title":"AshPagify.merge_filters/2","doc":"Merges the given filters with the filters of a AshPagify struct.\n\nIf the filter already exists, it will be replaced with the new value. If the\nfilter does not exist, it will be added to the filters map.\n\nIn order to merge the filters, the filters are first prepared by calling `prepare_filters/1`.\nThis function will ensure that the filters are in the correct format for merging\n(e.g. keys are strings).\n\nIf the filters are in the correct format, the filters are merged using `Misc.deep_merge/2`.\nAfter merging, the filters are cleaned up by removing empty lists.","ref":"AshPagify.html#merge_filters/2"},{"type":"function","title":"Examples - AshPagify.merge_filters/2","doc":"iex> merge_filters(%AshPagify{filters: %{name: \"foo\"}}, %{name: \"bar\"})\n    %AshPagify{filters: %{\"and\" => [%{\"name\" => \"bar\"}]}}\n\n    iex> merge_filters(%AshPagify{filters: %{name: \"foo\"}}, %{age: 10})\n    %AshPagify{filters: %{\"and\" => [%{\"name\" => \"foo\"}, %{\"age\" => 10}]}}\n\n    iex> merge_filters(%AshPagify{filters: %{\"or\" => [%{name: \"foo\"}]}}, %{age: 10})\n    %AshPagify{filters: %{\"or\" => [%{\"name\" => \"foo\"}], \"and\" => [%{\"age\" => 10}]}}\n\n    iex> merge_filters(%AshPagify{filters: %{\"or\" => [%{name: \"foo\"}]}}, %{\"or\" => [%{age: 10}]})\n    %AshPagify{filters: %{\"or\" => [%{\"name\" => \"foo\"}, %{\"age\" => 10}]}}","ref":"AshPagify.html#merge_filters/2-examples"},{"type":"function","title":"AshPagify.meta/3","doc":"Returns meta information for the given query and ash_pagify that can be used for\nbuilding the pagination links.","ref":"AshPagify.html#meta/3"},{"type":"function","title":"Examples - AshPagify.meta/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{limit: 2, offset: 1, order_by: [name: :asc, comments_count: :desc_nils_last]}\n    iex> page = AshPagify.all(Post, ash_pagify)\n    iex> AshPagify.meta(page, ash_pagify)\n    %AshPagify.Meta{\n      current_limit: 2,\n      current_offset: 1,\n      current_page: 2,\n      default_scopes: %{status: :all},\n      has_next_page?: false,\n      has_previous_page?: true,\n      next_offset: nil,\n      opts: [],\n      ash_pagify: %AshPagify{filters: nil, limit: 2, offset: 1, order_by: [name: :asc, comments_count: :desc_nils_last]},\n      previous_offset: 0,\n      resource: Post,\n      total_count: 3,\n      total_pages: 2\n    }\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#meta/3-examples"},{"type":"function","title":"AshPagify.order_by/2","doc":"Applies the `order_by` parameter of a `t:AshPagify.t/0` to an `t:Ash.Query.t/0`.\n\nUsed by `AshPagify.query/2`. See `Ash.Query.sort/3` for more information.\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#order_by/2"},{"type":"function","title":"Examples - AshPagify.order_by/2","doc":"iex> alias AshPagify.Factory.Post\n      iex> q = Ash.Query.new(Post)\n      iex> ash_pagify = %AshPagify{order_by: [\"name\"]}\n      iex> order_by(q, ash_pagify)\n      #Ash.Query \n\nOr descending order nulls last:\n      iex> alias AshPagify.Factory.Post\n      iex> q = Ash.Query.new(Post)\n      iex> ash_pagify = %AshPagify{order_by: [name: :desc_nils_last]}\n      iex> order_by(q, ash_pagify)\n      #Ash.Query \n\nOr multiple fields:\n      iex> alias AshPagify.Factory.Post\n      iex> q = Ash.Query.new(Post)\n      iex> ash_pagify = %AshPagify{order_by: [\"name\", \"id\"]}\n      iex> order_by(q, ash_pagify)\n      #Ash.Query \n\nOr by calculation:\n      iex> alias AshPagify.Factory.Post\n      iex> q = Ash.Query.new(Post)\n      iex> ash_pagify = %AshPagify{order_by: [\"comments_count\"]}\n      iex> order_by(q, ash_pagify)\n      #Ash.Query","ref":"AshPagify.html#order_by/2-examples"},{"type":"function","title":"AshPagify.page/2","doc":"Returns a keyword list with the `limit`, `offset` and `count` parameters\nfrom the given `t:AshPagify.t/0` parameter.\n\nThe `count` parameter is set to `true` by default. To disable counting the\ntotal number of records, set `count: false` in the optional page keyword list.","ref":"AshPagify.html#page/2"},{"type":"function","title":"Examples - AshPagify.page/2","doc":"iex> ash_pagify = %AshPagify{limit: 10, offset: 20}\n    iex> page(ash_pagify)\n    [count: true, offset: 20, limit: 10]\n\nOr disable counting:\n\n    iex> ash_pagify = %AshPagify{limit: 10, offset: 20}\n    iex> page(ash_pagify, count: false)\n    [count: false, offset: 20, limit: 10]","ref":"AshPagify.html#page/2-examples"},{"type":"function","title":"AshPagify.paginate/3","doc":"Adds clauses for pagination to the resulting keyword list from the given\n`t:AshPagify.t/0` parameter.\n\nThe `count` parameter is set to `true` by default. To disable counting the\ntotal number of records, set `page: [:count, false]` in the opts keyword list.\n\nIf the `limit` or `offset` fields are `nil`, the default limit and offset\nvalues will be used.\n\nIf the resource itself provides a default limit, it will be used instead of\nthe default limit provided by AshPagify.","ref":"AshPagify.html#paginate/3"},{"type":"function","title":"Examples - AshPagify.paginate/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{limit: 10, offset: 20}\n    iex> paginate(Post, ash_pagify)\n    [page: [count: true, offset: 20, limit: 10]]\n\nOr disable counting:\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{limit: 10, offset: 20}\n    iex> paginate(Post, ash_pagify, page: [count: false])\n    [page: [count: false, offset: 20, limit: 10]]\n\nOr without the offset parameter:\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{limit: 8}\n    iex> paginate(Post, ash_pagify)\n    [page: [count: true, offset: 0, limit: 8]]\n\nOr without the limit parameter. The default limit from Post will be used:\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{offset: 5}\n    iex> paginate(Post, ash_pagify)\n    [page: [count: true, offset: 5, limit: 15]]\n\nOr without the limit parameter. The default limit from AshPagify will be used if no\ndefault limit is provided by the resource:\n\n    iex> alias AshPagify.Factory.Comment\n    iex> ash_pagify = %AshPagify{offset: 5}\n    iex> paginate(Comment, ash_pagify)\n    [page: [count: true, offset: 5, limit: 25]]\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#paginate/3-examples"},{"type":"function","title":"AshPagify.parse/3","doc":"Adds clauses for full-text search, scoping, filtering, ordering and pagination to an `t:Ash.Query.t/0`\nor `t:Ash.Resource.t/0` from the given `t:AshPagify.t/0` parameters and `t:Keyword.t/0` options.\n\nThe keyword list `opts` is used to pass additional options to the query engine.\nIt shoud conform to the list of valid options at `Ash.read/2`. Furthermore\nthe `t:AshPagify.option/0` library options are supported.\n\nWe take the keyword list `opts` and return a keyword list callback according to\n`Ash.read/2` but with the __:query__ keyword also within the list.\n\n- `AshPagify.search` is used to apply full-text search to the query.\n- `Paigfy.scopes` are used to apply predefined filters to the query.\n- `AshPagify.filter_form` is used to apply filters generated by the `AshPhoenix.FilterForm` module.\n- `AshPagify.filters` and `AshPagify.order_by` are used to filter and order the query.\n- `AshPagify.limit` and `AshPagify.offset` are used to paginate the query.\n\nThe user input parameters are represented by the `t:AshPagify.t/0` type. Any `nil` values\nwill be ignored.","ref":"AshPagify.html#parse/3"},{"type":"function","title":"Examples - AshPagify.parse/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{limit: 10, offset: 20, filters: %{name: \"foo\"}, order_by: [\"name\"]}\n    iex> [page, {:query, query}] = parse(Post, ash_pagify)\n    iex> page\n    {:page, [count: true, offset: 20, limit: 10]}\n    iex> query\n    #Ash.Query , sort: [{\"name\", :asc}]>\n\nOr to disable counting:\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{limit: 10, offset: 20, filters: %{name: \"foo\"}, order_by: [\"name\"]}\n    iex> [page, {:query, query}] = parse(Post, ash_pagify, page: [count: false])\n    iex> page\n    {:page, [count: false, offset: 20, limit: 10]}\n    iex> query\n    #Ash.Query , sort: [{\"name\", :asc}]>\n\nSorting only:\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{order_by: [\"name\"]}\n    iex> [page, {:query, query}] = parse(Post, ash_pagify)\n    iex> page\n    {:page, [count: true, offset: 0, limit: 15]}\n    iex> query\n    #Ash.Query \n\nFiltering only:\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{filters: %{name: \"foo\"}}\n    iex> [page, {:query, query}] = parse(Post, ash_pagify)\n    iex> page\n    {:page, [count: true, offset: 0, limit: 15]}\n    iex> query\n    #Ash.Query >\n\nPagination only:\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{limit: 10, offset: 20}\n    iex> [page, {:query, query}] = parse(Post, ash_pagify)\n    iex> page\n    {:page, [count: true, offset: 20, limit: 10]}\n    iex> query\n    #Ash.Query \n\nScoping only:\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{scopes: %{role: :admin}}\n    iex> [page, {:query, query}] = parse(Post, ash_pagify)\n    iex> page\n    {:page, [count: true, offset: 0, limit: 15]}\n    iex> query\n    #Ash.Query >\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#parse/3-examples"},{"type":"function","title":"AshPagify.prefix_to_order/1","doc":"Transforms the given field with order prefix into an `t:Ash.Sort.sort_order/t`.","ref":"AshPagify.html#prefix_to_order/1"},{"type":"function","title":"Examples - AshPagify.prefix_to_order/1","doc":"iex> AshPagify.prefix_to_order(\"name\")\n    :asc\n    iex> AshPagify.prefix_to_order(\"-name\")\n    :desc\n    iex> AshPagify.prefix_to_order(\"++name\")\n    :asc_nils_first\n    iex> AshPagify.prefix_to_order(\"--name\")\n    :desc_nils_last\n    iex> AshPagify.prefix_to_order(\"+name\")\n    :asc","ref":"AshPagify.html#prefix_to_order/1-examples"},{"type":"function","title":"AshPagify.push_order/3","doc":"Updates the `order_by` value of a `AshPagify` struct.\n\n- If the field is not in the current `order_by` value, it will be prepended to\n  the list. By default, the order direction for the field will be set to\n  `:asc`.\n- If the field is already at the front of the `order_by` list, the order\n  direction will be reversed.\n- If the field is already in the list, but not at the front, it will be moved\n  to the front and the order direction will be set to `:asc` (or the custom\n  asc direction supplied in the `:directions` option).\n- If the `:directions` option --a 2-element tuple-- is passed, the first and\n  second elements will be used as custom sort declarations for ascending and\n  descending, respectively.","ref":"AshPagify.html#push_order/3"},{"type":"function","title":"Examples - AshPagify.push_order/3","doc":"iex> ash_pagify = push_order(%AshPagify{}, :name)\n    iex> ash_pagify.order_by\n    [name: :asc]\n    iex> ash_pagify = push_order(ash_pagify, :age)\n    iex> ash_pagify.order_by\n    [age: :asc, name: :asc]\n    iex> ash_pagify = push_order(ash_pagify, :age)\n    iex> ash_pagify.order_by\n    [age: :desc, name: :asc]\n    iex> ash_pagify = push_order(ash_pagify, :species)\n    iex> ash_pagify.order_by\n    [species: :asc, age: :desc, name: :asc]\n    iex> ash_pagify = push_order(ash_pagify, :age)\n    iex> ash_pagify.order_by\n    [age: :asc, species: :asc, name: :asc]\n\nBy default, the function toggles between `:asc` and `:desc`. You can override\nthis with the `:directions` option.\n\n    iex> directions = {:asc_nils_first, :desc_nils_last}\n    iex> ash_pagify = push_order(%AshPagify{}, :ttfb, directions: directions)\n    iex> ash_pagify.order_by\n    [ttfb: :asc_nils_first]\n    iex> ash_pagify = push_order(ash_pagify, :ttfb, directions: directions)\n    iex> ash_pagify.order_by\n    [ttfb: :desc_nils_last]\n\nThis also allows you to sort in descending order initially.\n\n    iex> directions = {:desc, :asc}\n    iex> ash_pagify = push_order(%AshPagify{}, :ttfb, directions: directions)\n    iex> ash_pagify.order_by\n    [ttfb: :desc]\n    iex> ash_pagify = push_order(ash_pagify, :ttfb, directions: directions)\n    iex> ash_pagify.order_by\n    [ttfb: :asc]\n\nIf a string is passed as the second argument, it will be converted to an atom\nusing `String.to_existing_atom/1`. If the atom does not exist, the `AshPagify`\nstruct will be returned unchanged.\n\n    iex> ash_pagify = push_order(%AshPagify{}, \"name\")\n    iex> ash_pagify.order_by\n    [name: :asc]\n    iex> ash_pagify = push_order(%AshPagify{}, \"this_atom_does_not_exist\")\n    iex> ash_pagify.order_by\n    nil\n\nIf the `order_by` is either an atom or a binary, the function will return the coerced `order_by` value.\n\n    iex> ash_pagify = push_order(%AshPagify{order_by: \"author\"}, :name)\n    iex> ash_pagify.order_by\n    [name: :asc, author: :asc]\n    iex> ash_pagify = push_order(%AshPagify{order_by: :author}, \"name\")\n    iex> ash_pagify.order_by\n    [name: :asc, author: :asc]\n\nIf the `:limit_order_by` option is passed, the `order_by` will be limited to the given number of fields.\n\n    iex> ash_pagify = push_order(%AshPagify{order_by: [name: :asc, age: :asc]}, :species, limit_order_by: 1)\n    iex> ash_pagify.order_by\n    [species: :asc]","ref":"AshPagify.html#push_order/3-examples"},{"type":"function","title":"AshPagify.query/3","doc":"Adds clauses for full-text search, scoping, filtering and ordering to an\n`t:Ash.Query.t/0` from the given `t:AshPagify.t/0` parameter.\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#query/3"},{"type":"function","title":"Examples - AshPagify.query/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> q = Ash.Query.new(Post)\n    iex> ash_pagify = %AshPagify{filters: %{name: \"John\"}, order_by: [\"name\"]}\n    iex> query(q, ash_pagify)\n    #Ash.Query , sort: [{\"name\", :asc}]>","ref":"AshPagify.html#query/3-examples"},{"type":"function","title":"AshPagify.query_for_filters_map/3","doc":"Creates an `Ash.Query` from a filter map. Ideally, the filter map was previously\ncompiled with `AshPagify.query_to_filters_map/2`.\n\nOptionally, you can pass the `include_full_text_search?: false` option to disable\nthe full-text search term inclusion in the query.\n\nIf the full-text search term is included in the compiled filters map, it will be\nremoved from the filters map before the query is created. Further, the full-text\nsearch is validated before beeing applied to the query. If the full-text search\nis invalid and the `raise_on_invalid_search?` option is not set to `false`, the\nfunction will raise an error.","ref":"AshPagify.html#query_for_filters_map/3"},{"type":"function","title":"Examples - AshPagify.query_for_filters_map/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> filters_map = %{\"and\" => [%{\"name\" => \"foo\"}]}\n    iex> query_for_filters_map(Post, filters_map)\n    #Ash.Query >","ref":"AshPagify.html#query_for_filters_map/3-examples"},{"type":"function","title":"AshPagify.query_to_filters_map/3","doc":"Takes the AshPagify.scopes and AshPagify.form_filter and compiles them into a\nmap of filters. The filters are merged with the base filters of the AshPagify struct.\n\nAt this stage we assume that the filters, filter_form, and scopes have been validated\nand are valid.\n\n> #### Full-text search {: .info}\n> Per default we do store the full-text search term along with the user\nprovided full-text search options  in the compiled filters map. If\nyou do not need to include the full-text search setting in the compiled filters\nmap, you can set the `include_full_text_search?` option to `false`.\nThe full-text search setting is stored under the key `\"__full_text_search\"` in the\nresulting filters map. This can be handy if you want to store the current filter\nstate including the full-text search setting and retrieve it later. See\n`AshPagify.query_for_filters_map/2` for an example.\n\nPrecedence:\n- scopes (will overwrite filter_form and filters)\n- filter_form (will overwrite filters)\n- filters","ref":"AshPagify.html#query_to_filters_map/3"},{"type":"function","title":"Examples - AshPagify.query_to_filters_map/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> query_to_filters_map(Post, %AshPagify{scopes: [{:role, :admin}]})\n    %AshPagify{filters: %{\"and\" => [%{\"author\" => \"John\"}]}, scopes: [role: :admin]}\n\n    iex> query_to_filters_map(Post, %AshPagify{filters: %{name: \"foo\"}})\n    %AshPagify{filters: %{\"and\" => [%{\"name\" => \"foo\"}]}}\n\n    iex> query_to_filters_map(\n    ...>   Post,\n    ...>   %AshPagify{\n    ...>     filters: %{author: \"Author 1\"},\n    ...>     filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"},\n    ...>     scopes: [{:role, :admin}]\n    ...>   }\n    ...> )\n    %AshPagify{\n      scopes: [role: :admin],\n      filters: %{\"and\" => [%{\"author\" => \"John\"}, %{\"name\" => %{\"eq\" => \"Post 1\"}}]},\n      filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}\n    }\n\n    # Or with a full-text search term\n\n    iex> query_to_filters_map(\n    ...>   Post,\n    ...>   %AshPagify{\n    ...>     search: \"search term\",\n    ...>     filters: %{author: \"Author 1\"},\n    ...>     filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"},\n    ...>     scopes: [{:role, :admin}]\n    ...>   }\n    ...> )\n    %AshPagify{\n      scopes: [role: :admin],\n      filters: %{\n        \"and\" => [\n          %{\"author\" => \"John\"},\n          %{\"name\" => %{\"eq\" => \"Post 1\"}}\n        ],\n        \"__full_text_search\" => %{\n          \"search\" => \"search term\"\n        }\n      },\n      filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"},\n      search: \"search term\"\n    }","ref":"AshPagify.html#query_to_filters_map/3-examples"},{"type":"function","title":"AshPagify.reset_filter_form/1","doc":"Removes all filter_form from a AshPagify struct.","ref":"AshPagify.html#reset_filter_form/1"},{"type":"function","title":"Example - AshPagify.reset_filter_form/1","doc":"iex> reset_filter_form(%AshPagify{\n    ...>   filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}\n    ...> })\n\n    %AshPagify{filter_form: %{}}","ref":"AshPagify.html#reset_filter_form/1-example"},{"type":"function","title":"AshPagify.reset_filters/1","doc":"Removes all filters from a AshPagify struct.","ref":"AshPagify.html#reset_filters/1"},{"type":"function","title":"Example - AshPagify.reset_filters/1","doc":"iex> reset_filters(%AshPagify{filters: %{\n    ...>  name: \"foo\",\n    ...> }})\n    %AshPagify{filters: %{}}","ref":"AshPagify.html#reset_filters/1-example"},{"type":"function","title":"AshPagify.reset_order/1","doc":"Resets the order of a AshPagify struct.","ref":"AshPagify.html#reset_order/1"},{"type":"function","title":"Example - AshPagify.reset_order/1","doc":"iex> reset_order(%AshPagify{order_by: [name: :asc]})\n    %AshPagify{order_by: nil}","ref":"AshPagify.html#reset_order/1-example"},{"type":"function","title":"AshPagify.run/4","doc":"Applies the given `t:AshPagify.t/0` to the given `t:Ash.Query.t/0` or `t:Ash.Resource.t/0`,\nretrieves the data and the `t:AshPagify.Meta.t/0` data.\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine. Or you can use `AshPagify.validate_and_run/4` or\n`AshPagify.validate_and_run!/4` instead of this function.","ref":"AshPagify.html#run/4"},{"type":"function","title":"Examples - AshPagify.run/4","doc":"iex> alias AshPagify.Factory.Post\n    iex> opts = [page: [count: false]]\n    iex> ash_pagify = AshPagify.validate!(Post, %{filters: %{name: \"inexistent\"}}, opts)\n    iex> {data, meta} = AshPagify.run(Post, ash_pagify, opts)\n    iex> data == []\n    true\n    iex> match?(%AshPagify.Meta{}, meta)\n    true\n\nSee the documentation for `AshPagify.validate_and_run/4` for supported options.","ref":"AshPagify.html#run/4-examples"},{"type":"function","title":"AshPagify.scope/3","doc":"Applies the `scopes` parameter of a `t:AshPagify.t/0` to an `t:Ash.Query.t/0`.\n\nUsed by `AshPagify.query/2`. At this stage we assume that the scopes are already\ncompiled and validated. Further, default scopes are loaded into the AshPagify struct.\n\nFor a completed list of filter operators, see `Ash.Filter`.\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#scope/3"},{"type":"function","title":"Examples - AshPagify.scope/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> q = Ash.Query.new(Post)\n    iex> ash_pagify = %AshPagify{scopes: %{status: :active}}\n    iex> scope(q, ash_pagify)\n    #Ash.Query >","ref":"AshPagify.html#scope/3-examples"},{"type":"function","title":"AshPagify.search/3","doc":"Applies the `search` parameter of a `t:AshPagify.t/0` to an `t:Ash.Query.t/0`.\n\nUsed by `AshPagify.query/2`. AshPagify allows you to perform full-text searches on resources. It uses the\nbuilt-in [PostgreSQL full-text search functionality](https://www.postgresql.org/docs/current/textsearch.html).\n\nHave a look at the `t:AshPagify.Tsearch.tsearch_option/0` type for a list of available options.\n\nIf search is provided and there is no order_by, the query will be sorted by the rank of the search.\n\nThis function does _not_ validate or apply default parameters to the given\nAshPagify struct. Be sure to validate any user-generated parameters with\n`validate/2` or `validate!/2` before passing them to this function. Doing so\nwill automatically parse user provided input into the correct format for the\nquery engine.","ref":"AshPagify.html#search/3"},{"type":"function","title":"AshPagify.set_filter_form/3","doc":"Updates the filter form of a AshPagify.Meta struct.\n\nIf the filter already exists, it will be replaced with the new value. If the\nfilter does not exist, it will be added to the filter form map.\n\nIf the reset option is set to false, the offset will not be reset to 0.","ref":"AshPagify.html#set_filter_form/3"},{"type":"function","title":"Examples - AshPagify.set_filter_form/3","doc":"iex>  set_filter_form(%AshPagify.Meta{}, %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 2\"})\n    %AshPagify.Meta{ash_pagify: %AshPagify{filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 2\"}}}\n\n    iex> set_filter_form(%AshPagify.Meta{ash_pagify: %AshPagify{filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}}}, %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 2\"})\n    %AshPagify.Meta{ash_pagify: %AshPagify{filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 2\"}}}\n\n    iex> set_filter_form(%AshPagify.Meta{ash_pagify: %AshPagify{filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}}}, %{\"negated\" => false, \"operator\" => \"and\"})\n    %AshPagify.Meta{ash_pagify: %AshPagify{filter_form: nil}}","ref":"AshPagify.html#set_filter_form/3-examples"},{"type":"function","title":"AshPagify.set_limit/3","doc":"Sets the limit value of a `AshPagify` struct.\n\n    iex> set_limit(%AshPagify{limit: 10, offset: 10}, 20)\n    %AshPagify{limit: 20, offset: 10}\n\n    iex> set_limit(%AshPagify{limit: 10, offset: 10}, \"20\")\n    %AshPagify{limit: 20, offset: 10}\n\nThe limit will not be allowed to go below 1.\n\n    iex> set_limit(%AshPagify{}, -5)\n    %AshPagify{limit: 25}\n\nIf the limit is higher than the max_limit option, the limit will be set to the max_limit.\n\n    iex> set_limit(%AshPagify{}, 102)\n    %AshPagify{limit: 100}","ref":"AshPagify.html#set_limit/3"},{"type":"function","title":"AshPagify.set_offset/2","doc":"Sets the offset value of a `AshPagify` struct.\n\n    iex> set_offset(%AshPagify{limit: 10, offset: 10}, 20)\n    %AshPagify{offset: 20, limit: 10}\n\n    iex> set_offset(%AshPagify{limit: 10, offset: 10}, \"20\")\n    %AshPagify{offset: 20, limit: 10}\n\nThe offset will not be allowed to go below 0.\n\n    iex> set_offset(%AshPagify{}, -5)\n    %AshPagify{offset: 0}","ref":"AshPagify.html#set_offset/2"},{"type":"function","title":"AshPagify.set_scope/3","doc":"Sets the scope of a AshPagify struct.\n\nIf the scope already exists, it will be replaced with the new value. If the\nscope does not exist, it will be added to the scopes map.\n\nIf the reset option is set to false, the offset will not be reset to 0.","ref":"AshPagify.html#set_scope/3"},{"type":"function","title":"Examples - AshPagify.set_scope/3","doc":"iex> set_scope(%AshPagify{offset: 10, scopes: %{status: :active}}, %{status: :inactive})\n    %AshPagify{scopes: %{status: :inactive}}\n\n    iex> set_scope(%AshPagify{offset: 10, scopes: %{status: :active}}, %{status: :active})\n    %AshPagify{scopes: %{status: :active}}\n\nOr add a new scope:\n\n    iex> set_scope(%AshPagify{offset: 10, scopes: %{role: :admin}}, %{status: :active})\n    %AshPagify{scopes: %{status: :active, role: :admin}}\n\n    iex> set_scope(%AshPagify{}, %{role: :admin})\n    %AshPagify{scopes: %{role: :admin}}\n\nOr without reset offset:\n\n    iex> set_scope(%AshPagify{offset: 10}, %{status: :active}, reset_on_filter?: false)\n    %AshPagify{scopes: %{status: :active}, offset: 10}","ref":"AshPagify.html#set_scope/3-examples"},{"type":"function","title":"AshPagify.set_search/3","doc":"Sets the search of a AshPagify struct.\n\nIf the reset option is set to false, the offset will not be reset to 0.","ref":"AshPagify.html#set_search/3"},{"type":"function","title":"Examples - AshPagify.set_search/3","doc":"iex> set_search(%AshPagify{offset: 10}, \"term\")\n    %AshPagify{search: \"term\"}\n\n    iex> set_search(%AshPagify{offset: 10, search: \"old\"}, \"new\")\n    %AshPagify{search: \"new\"}\n\n    iex> set_search(%AshPagify{offset: 10, search: \"old\"}, nil)\n    %AshPagify{search: nil}\n\nOr without reset offset:\n\n    iex> set_search(%AshPagify{offset: 10}, \"term\", reset_on_filter?: false)\n    %AshPagify{search: \"term\", offset: 10}","ref":"AshPagify.html#set_search/3-examples"},{"type":"function","title":"AshPagify.set_tsvector/2","doc":"Sets the tsvector value in the full_text_search clause of the `Keyword.t` opts parameter.\n\nIf the full_text_search clause does not exist, it will be created. If the tsvector\nvalue already exists, it will be updated.","ref":"AshPagify.html#set_tsvector/2"},{"type":"function","title":"Examples - AshPagify.set_tsvector/2","doc":"iex> set_tsvector(\"bar\", [full_text_search: [tsvector: \"foo\"]])\n    [full_text_search: [tsvector: \"bar\"]]\n\n    iex> set_tsvector(\"bar\")\n    [full_text_search: [tsvector: \"bar\"]]\n\n    iex> set_tsvector(\"foo\", [full_text_search: [tsvector: \"foo\"]])\n    [full_text_search: [tsvector: \"foo\"]]","ref":"AshPagify.html#set_tsvector/2-examples"},{"type":"function","title":"AshPagify.to_next_offset/2","doc":"Sets the offset of a AshPagify struct to the next page depending on the limit.\n\nIf the total count is given as the second argument, the offset will not be\nincreased if the last page has already been reached. You can get the total\ncount from the `AshPagify.Meta` struct. If the AshPagify has an offset beyond the total\ncount, the offset will be set to the last page.","ref":"AshPagify.html#to_next_offset/2"},{"type":"function","title":"Examples - AshPagify.to_next_offset/2","doc":"iex> to_next_offset(%AshPagify{offset: 10, limit: 5})\n    %AshPagify{offset: 15, limit: 5}\n\n    iex> to_next_offset(%AshPagify{offset: 15, limit: 5}, 21)\n    %AshPagify{offset: 20, limit: 5}\n\n    iex> to_next_offset(%AshPagify{offset: 15, limit: 5}, 20)\n    %AshPagify{offset: 15, limit: 5}\n\n    iex> to_next_offset(%AshPagify{offset: 28, limit: 5}, 22)\n    %AshPagify{offset: 20, limit: 5}\n\n    iex> to_next_offset(%AshPagify{offset: -5, limit: 20})\n    %AshPagify{offset: 0, limit: 20}","ref":"AshPagify.html#to_next_offset/2-examples"},{"type":"function","title":"AshPagify.to_previous_offset/1","doc":"Sets the offset of a AshPagify struct to the page depending on the limit.","ref":"AshPagify.html#to_previous_offset/1"},{"type":"function","title":"Examples - AshPagify.to_previous_offset/1","doc":"iex> to_previous_offset(%AshPagify{offset: 20, limit: 10})\n    %AshPagify{offset: 10, limit: 10}\n\n    iex> to_previous_offset(%AshPagify{offset: 5, limit: 10})\n    %AshPagify{offset: 0, limit: 10}\n\n    iex> to_previous_offset(%AshPagify{offset: 0, limit: 10})\n    %AshPagify{offset: 0, limit: 10}\n\n    iex> to_previous_offset(%AshPagify{offset: -2, limit: 10})\n    %AshPagify{offset: 0, limit: 10}","ref":"AshPagify.html#to_previous_offset/1-examples"},{"type":"function","title":"AshPagify.validate/3","doc":"Validates a `t:AshPagify.t/0`.","ref":"AshPagify.html#validate/3"},{"type":"function","title":"Examples - AshPagify.validate/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> params = %{limit: 10, offset: 20, other_param: \"foo\"}\n    iex> AshPagify.validate(Post, params)\n    {:ok, %AshPagify{limit: 10, offset: 20, scopes: %{status: :all}}}\n\n    iex> ash_pagify = %AshPagify{offset: -1}\n    iex> {:error, %AshPagify.Meta{} = meta} = AshPagify.validate(Post, ash_pagify)\n    iex> AshPagify.Error.clear_stacktrace(meta.errors)\n    [\n      offset: [\n        %Ash.Error.Query.InvalidOffset{offset: -1}\n      ]\n    ]\n\nThe function is aware of the `Ash.Resource` type passed either as query or as\nresource. Thus the function is able to validate that only allowed fields are\nused for scoping, ordering and filtering. The function will also apply the\ndefault_limit and scoping if the resource provides one.","ref":"AshPagify.html#validate/3-examples"},{"type":"function","title":"AshPagify.validate!/3","doc":"Same as `AshPagify.validate/2`, but raises a `AshPagify.Error.Query.InvalidParamsError` if the\nparameters are invalid.","ref":"AshPagify.html#validate!/3"},{"type":"function","title":"AshPagify.validate_and_run/4","doc":"Validates the given ash_pagify parameters and retrieves the data and meta data on\nsuccess.","ref":"AshPagify.html#validate_and_run/4"},{"type":"function","title":"Examples - AshPagify.validate_and_run/4","doc":"iex> alias AshPagify.Factory.Post\n    iex> {:ok, {[%Post{},%Post{},%Post{}], %AshPagify.Meta{}}} =\n    ...>   AshPagify.validate_and_run(Post, %AshPagify{})\n    iex> {:error, %AshPagify.Meta{} = meta} =\n    ...>   AshPagify.validate_and_run(Post, %{limit: -1})\n    iex> AshPagify.Error.clear_stacktrace(meta.errors)\n    [\n      limit: [\n        %Ash.Error.Query.InvalidLimit{limit: -1}\n      ]\n    ]\n\nOr with a custom read action:\n\n    iex> alias AshPagify.Factory.Post\n    iex> alias AshPagify.Factory.Comment\n    iex> Comment.read!() |> Enum.count()\n    9\n    iex> ash_pagify = %AshPagify{limit: 1, filters: %{name: \"Post 1\"}}\n    iex> {:ok, {posts, _meta}} = AshPagify.validate_and_run(Post, ash_pagify)\n    iex> post = hd(posts)\n    iex> {:ok, {_comments, meta}} = AshPagify.validate_and_run(Comment, %AshPagify{}, [action: :by_post], post.id)\n    iex> meta.total_count\n    2\n\nOr with scopes:\n\n    iex> alias AshPagify.Factory.Post\n    iex> {:ok, {[%Post{}], %AshPagify.Meta{}}} = AshPagify.validate_and_run(Post, %AshPagify{scopes: %{role: :user}})","ref":"AshPagify.html#validate_and_run/4-examples"},{"type":"function","title":"Options - AshPagify.validate_and_run/4","doc":"The keyword list `opts` is used to pass additional options to the query engine.\nIt shoud conform to the list of valid options at `Ash.read/2`. Furthermore\nthe `t:AshPagify.option/0` library options are supported.","ref":"AshPagify.html#validate_and_run/4-options"},{"type":"function","title":"AshPagify.validate_and_run!/4","doc":"Same as `AshPagify.validate_and_run/4`, but raises on error.","ref":"AshPagify.html#validate_and_run!/4"},{"type":"function","title":"AshPagify.validated_query/3","doc":"Validates the given query or resource and ash_pagify parameters and returns a\nvalidated query.","ref":"AshPagify.html#validated_query/3"},{"type":"function","title":"Examples - AshPagify.validated_query/3","doc":"iex> alias AshPagify.Factory.Post\n    iex> ash_pagify = %AshPagify{limit: 10, offset: 20, order_by: [\"name\"], filters: %{name: \"foo\"}}\n    iex> validated_query(Post, ash_pagify)\n    #Ash.Query , sort: [name: :asc]>","ref":"AshPagify.html#validated_query/3-examples"},{"type":"type","title":"AshPagify.option/0","doc":"These options can be passed to most functions or configured via the\napplication environment.","ref":"AshPagify.html#t:option/0"},{"type":"type","title":"Options - AshPagify.option/0","doc":"Default ash_pagify options in addition to the ones provided by the\n`Ash.read/2` function. These options are used to configure the\npagination behavior.\n\n- `:default_limit` - The default number of records to return. Defaults to 25.\n  Can be overridden by the resource's `default_limit` function.\n- `:max_limit` - The maximum number of records that can be returned. Defaults\n  to 100.\n- `:replace_invalid_params?` - If set to `true`, invalid parameters will be\n  replaced with the default value. If set to `false`, invalid parameters\n  will result in an error. Defaults to `false`.\n- `:ash_pagify_scopes` - A map of predefined filters to apply to the query. Each map\n  entry itself is a group (list) of `t:AshPagify.scope/0` entries.\n- `:reset_on_filter?` - If set to `true`, the offset will be reset to 0 when\n  a filter is applied. Defaults to `true`.\n- `:full_text_search` - A list of options for full-text search. See\n  `t:AshPagify.Tsearch.tsearch_option/0`.","ref":"AshPagify.html#t:option/0-options"},{"type":"type","title":"Look-up order - AshPagify.option/0","doc":"Options are looked up in the following order:\n\n1. Function arguments (highest priority)\n2. Resource-level options (set in the resource module)\n3. Global options in the application environment (set in config files)\n4. Library defaults (lowest priority)","ref":"AshPagify.html#t:option/0-look-up-order"},{"type":"type","title":"AshPagify.order_by/0","doc":"Valid order_by types for the `t:AshPagify.t/0` struct.","ref":"AshPagify.html#t:order_by/0"},{"type":"type","title":"AshPagify.scope/0","doc":"A scope is a predefined filter that is merged with the user-provided filters.\n\nScope definitions live in the resource provided `ash_pagify_scopes` function or in\nthe provided `t:AshPagify.option/0`. Contrary to user-provided filters, scope filters\nare not parsed as user input and are not validated as such. However, they are\nvalidated in the `AshPagify.validate_and_run/4` context. User-provided parameters are\nused to lookup the scope filter. If the scope filter is found, it is applied to the query.\nIf the scope filter is not found, an error is raised.","ref":"AshPagify.html#t:scope/0"},{"type":"type","title":"Fields - AshPagify.scope/0","doc":"- `:name` - The name of the filter for the scope.\n- `:filter` - The filter to apply to the query.\n- `:default?` - If set to `true`, the scope is applied by default.","ref":"AshPagify.html#t:scope/0-fields"},{"type":"type","title":"AshPagify.t/0","doc":"Represents the query parameters for full-text search, scoping, filtering, ordering and pagination.","ref":"AshPagify.html#t:t/0"},{"type":"type","title":"Fields - AshPagify.t/0","doc":"- `limit`, `offset`: Used for offset-based pagination.\n- `scopes`: A map of user provided scopes to apply to the query. Scopes are internally translated to\n  predefined filters and merged into the query enginge.\n- `filter_form`: A map of filters provided by `AshPhoenix.FilterForm` module. These filters are meant\n  to be used in user interfaces.\n- `filters`: A map of manually provided filters to apply to the query. These filters must be provided in\n  the map syntax and are meant to be used in business logic context (see `Ash.Filter` for examples).\n- `order_by`: A list of fields to order by (see `Ash.Sort.parse_input/3` for all available orders).\n- `search`: A string to search for in the full-text search column.","ref":"AshPagify.html#t:t/0-fields"},{"type":"module","title":"AshPagify.Meta","doc":"Defines a struct for holding meta information of a query result.","ref":"AshPagify.Meta.html"},{"type":"function","title":"AshPagify.Meta.with_errors/3","doc":"Returns a `AshPagify.Meta` struct with the given params, errors, and opts.\n\nThis function is used internally to build error responses in case of\nvalidation errors. You can use it to add additional parameter validation.","ref":"AshPagify.Meta.html#with_errors/3"},{"type":"function","title":"Example - AshPagify.Meta.with_errors/3","doc":"In this list function, the given parameters are first validated with\n`AshPagify.validate/2`, which returns a `AshPagify` struct on success. You can then pass\nthat struct to a custom validation function, along with the original\nparameters and the opts, which both are needed to call this function.\n\n    def list_posts(%{} = params) do\n      opts = []\n\n      with {:ok, %AshPagify{} = ash_pagify} <- AshPagify.validate(Post, params, opts),\n           {:ok, %AshPagify{} = ash_pagify} <- custom_validation(ash_pagify, params, opts) do\n        AshPagify.run(Post, ash_pagify, opts)\n      end\n    end\n\nIn your custom validation function, you can retrieve and manipulate the filter\nvalues in the `AshPagify` struct.\n\n    defp custom_validation(%AshPagify{} = ash_pagify, %{} = params, opts) do\n      filters = ash_pagify.filters\n\n      if Keyword.get(filters, :name) != nil do\n        errors = [filters: [%Ash.Error.Query.InvalidFilterReference{field: :name}]]\n        {:error, AshPagify.Meta.with_errors(params, errors, opts)}\n      else\n        {:ok, ash_pagify}\n      end\n    end","ref":"AshPagify.Meta.html#with_errors/3-example"},{"type":"type","title":"AshPagify.Meta.t/0","doc":"Meta information for a query result.\n\n- `:current_limit` - The `:limit` value used in the query\n- `:current_offset` - The `:offset` value used in the query\n- `:current_page` - A derived value when using offset-based pagination. Note that\n  the value will be rounded if the offset lies between pages.\n- `:current_search` - The current full-text search term.\n- `:default_scopes` - Default scopes loaded for this resource and query.\n- `:errors` - Any validation errors that occurred.\n- `:has_previous_page?`, `:has_next_page?` - Whether there are previous or next\n  pages based on the current page and total pages.\n- `:previous_offset`, `:next_offset` - Values based on `:current_page`\n  and `:current_offset`/`current_limit`.\n- `:opts` - The options passed to the `AshPagify` struct.\n- `:ash_pagify` - The `AshPagify` struct used in the query.\n- `:params` - The original, unvalidated params that were passed. Only set\n  if validation errors occurred.\n- `:resource` - The `Ash.Resource` that was queried.\n- `:total_count` - The total count of records for the given query.\n- `:total_pages` - The total page count based on the total record count and the limit.","ref":"AshPagify.Meta.html#t:t/0"},{"type":"module","title":"AshPagify.Misc","doc":"Miscellaneous functions for AshPagify.","ref":"AshPagify.Misc.html"},{"type":"function","title":"AshPagify.Misc.atomize_keys/2","doc":"Convert map string keys to :atom keys. This is useful when\nyou have a map that was created from JSON or other external\nsource and you want to convert the keys to atoms.\n\nYou can specify a list of keys to convert or a depth to which\nto convert keys. If you specify a depth of 1, only the top\nlevel keys will be converted. If you specify a depth of 2, the\ntop level keys and the keys of any maps in the top level will\nbe converted. And so on.\n\nIf you set the existing? option to true, the function will use\nthe `String.to_existing_atom/1` function to convert the keys.\n\nList of options:\n\n- `keys`: A list of keys to convert. If a key is not in the list,\n  it will not be converted. Default is an empty list and all keys\n  will be converted.\n- `depth`: The depth to which to convert keys. Default is nil and\n  all keys will be converted.\n- `existing?`: If true, the function will use `String.to_existing_atom/1`\n  to convert the keys. Default is false.","ref":"AshPagify.Misc.html#atomize_keys/2"},{"type":"function","title":"Example - AshPagify.Misc.atomize_keys/2","doc":"iex> AshPagify.Misc.atomize_keys(%{\"a\" => 1, \"b\" => 2})\n    %{a: 1, b: 2}\n\n    iex> AshPagify.Misc.atomize_keys(%{\"a\" => 1, \"b\" => %{\"c\" => 3}})\n    %{a: 1, b: %{c: 3}}\n\n    iex> AshPagify.Misc.atomize_keys(%{\"a\" => 1, \"b\" => %{\"c\" => 3}}, keys: [\"b\"])\n    %{\"a\" => 1, b: %{\"c\" => 3}}\n\n    iex> AshPagify.Misc.atomize_keys(%{\"a\" => 1, \"b\" => %{\"c\" => 3}}, keys: [\"b\", \"c\"])\n    %{\"a\" => 1, b: %{c: 3}}\n\n    iex> AshPagify.Misc.atomize_keys(%{\"a\" => 1, \"b\" => %{\"c\" => 3}}, keys: [\"b\", \"d\"], depth: 1)\n    %{\"a\" => 1, b: %{\"c\" => 3}}\n\n    iex> AshPagify.Misc.atomize_keys(%{\"a\" => 1, \"b\" => %{\"c\" => 3}}, keys: [\"b\", \"c\"], depth: 2)\n    %{\"a\" => 1, b: %{c: 3}}","ref":"AshPagify.Misc.html#atomize_keys/2-example"},{"type":"function","title":"AshPagify.Misc.coerce_maybe_empty_map/1","doc":"Coerce a maybe empty map to nil if it is empty.","ref":"AshPagify.Misc.html#coerce_maybe_empty_map/1"},{"type":"function","title":"Example - AshPagify.Misc.coerce_maybe_empty_map/1","doc":"iex> AshPagify.Misc.coerce_maybe_empty_map(%{})\n    nil\n\n    iex> AshPagify.Misc.coerce_maybe_empty_map(%{a: 1})\n    %{a: 1}\n\n    iex> AshPagify.Misc.coerce_maybe_empty_map(nil)\n    nil","ref":"AshPagify.Misc.html#coerce_maybe_empty_map/1-example"},{"type":"function","title":"AshPagify.Misc.deep_merge/2","doc":"Deeply merges two maps or lists, preferring values from the right map or list.\n\nIf a key exists in both maps or lists, and both values are maps or lists as well,\nthese can be merged recursively. If a key exists in both maps or lists,\nbut at least one of the values is NOT a map or list, we fall back to\nstandard merge behavior, preferring the value on the right.\n\nExample:\n\n    iex> AshPagify.Misc.deep_merge(%{a: 1, b: %{c: 2}}, %{b: %{d: 3}})\n    %{a: 1, b: %{c: 2, d: 3}}\n\none level of maps without conflict\n\n    iex> AshPagify.Misc.deep_merge(%{a: 1}, %{b: 2})\n    %{a: 1, b: 2}\n\ntwo levels of maps without conflict\n\n    iex> AshPagify.Misc.deep_merge(%{a: [%{b: 1}]}, %{a: [%{c: 3}]})\n    %{a: [%{b: 1}, %{c: 3}]}\n\nthree levels of maps without conflict\n\n    iex> AshPagify.Misc.deep_merge(%{a: %{b: %{c: 1}}}, %{a: %{b: %{d: 2}}})\n    %{a: %{b: %{c: 1, d: 2}}}\n\nnon-map value in left\n\n    iex> AshPagify.Misc.deep_merge(%{a: 1}, %{a: %{b: 2}})\n    %{a: %{b:  2}}\n\nnon-map value in right\n\n    iex> AshPagify.Misc.deep_merge(%{a: %{b: 1}}, %{a: 2})\n    %{a: 2}\n\nnon-map value in both\n\n    iex> AshPagify.Misc.deep_merge(%{a: 1}, %{a: 2})\n    %{a: 2}\n\nmap of list\n\n    iex> AshPagify.Misc.deep_merge(%{a: [1, 2]}, %{a: [2, 3]})\n    %{a: [1, 2, 3]}\n\nmap of list of map\n\n    iex> AshPagify.Misc.deep_merge(%{a: [%{b: 1}, %{c: 2}]}, %{a: [%{c: 3}, %{d: 4}]})\n    %{a: [%{b: 1}, %{c: 3}, %{d: 4}]}\n\nmap of different types\n\n    iex> AshPagify.Misc.deep_merge(%{a: [1, 2]}, %{a: %{b: 2}})\n    %{a: %{b: 2}}\n\nmap of list of different types\n\n    iex> AshPagify.Misc.deep_merge(%{a: [1, 2]}, %{a: [%{b: 2}]})\n    %{a: [1, 2, %{b: 2}]}","ref":"AshPagify.Misc.html#deep_merge/2"},{"type":"function","title":"AshPagify.Misc.get_global_opts/1","doc":"Returns the global opts derived from a function referenced in the application\nenvironment.","ref":"AshPagify.Misc.html#get_global_opts/1"},{"type":"function","title":"AshPagify.Misc.list_merge/2","doc":"Deep merges two lists, preferring values from the right list.\n\nIf a key exists in both lists, and both values are lists as well,\nthese can be merged recursively. If a key exists in both lists,\nbut at least one of the values is NOT a list, we fall back to\nstandard merge behavior, preferring the value on the right.\n\nExample:\n\n    iex> list_merge(\n    ...>   [aria: [role: \"navigation\"]],\n    ...>   [aria: [label: \"pagination\"]]\n    ...> )\n    [aria: [role: \"navigation\", label: \"pagination\"]]\n\n    iex> list_merge(\n    ...>   [class: \"a\"],\n    ...>   [class: \"b\"]\n    ...> )\n    [class: \"b\"]","ref":"AshPagify.Misc.html#list_merge/2"},{"type":"function","title":"AshPagify.Misc.map_merge/2","doc":"Deeply merges two maps, preferring values from the right map.\n\nIf a key exists in both maps, and both values are maps as well,\nthese can be merged recursively. If a key exists in both maps,\nbut at least one of the values is NOT a map, we fall back to\nstandard merge behavior, preferring the value on the right.\n\nExample:\n\n    iex> AshPagify.Misc.map_merge(%{a: 1, b: %{c: 2}}, %{b: %{d: 3}})\n    %{a: 1, b: %{c: 2, d: 3}}\n\none level of maps without conflict\n    iex> AshPagify.Misc.map_merge(%{a: 1}, %{b: 2})\n    %{a: 1, b: 2}\n\ntwo levels of maps without conflict\n    iex> AshPagify.Misc.map_merge(%{a: %{b: 1}}, %{a: %{c: 3}})\n    %{a: %{b: 1, c: 3}}\n\nthree levels of maps without conflict\n    iex> AshPagify.Misc.map_merge(%{a: %{b: %{c: 1}}}, %{a: %{b: %{d: 2}}})\n    %{a: %{b: %{c: 1, d: 2}}}\n\nnon-map value in left\n    iex> AshPagify.Misc.map_merge(%{a: 1}, %{a: %{b: 2}})\n    %{a: %{b:  2}}\n\nnon-map value in right\n    iex> AshPagify.Misc.map_merge(%{a: %{b: 1}}, %{a: 2})\n    %{a: 2}\n\nnon-map value in both\n    iex> AshPagify.Misc.map_merge(%{a: 1}, %{a: 2})\n    %{a: 2}","ref":"AshPagify.Misc.html#map_merge/2"},{"type":"function","title":"AshPagify.Misc.maybe_put/4","doc":"Puts a `value` under `key` only if the value is not `nil`, `[]`, `\"\"`, or `%{}`.\n\nIf a `:default` value is passed, it only puts the value into the list if the\nvalue does not match the default value.\n\n    iex> maybe_put([], :a, \"b\")\n    [a: \"b\"]\n\n    iex> maybe_put([], :a, nil)\n    []\n\n    iex> maybe_put([], :a, [])\n    []\n\n    iex> maybe_put([], :a, %{})\n    []\n\n    iex> maybe_put([], :a, \"\")\n    []\n\n    iex> maybe_put([], :a, \"a\", \"a\")\n    []\n\n    iex> maybe_put([], :a, \"a\", \"b\")\n    [a: \"a\"]","ref":"AshPagify.Misc.html#maybe_put/4"},{"type":"function","title":"AshPagify.Misc.maybe_put_compiled_ash_pagify_scopes/2","doc":"Put compiled ash_pagify scopes into the options if they are not already there.","ref":"AshPagify.Misc.html#maybe_put_compiled_ash_pagify_scopes/2"},{"type":"function","title":"Example - AshPagify.Misc.maybe_put_compiled_ash_pagify_scopes/2","doc":"iex> alias AshPagify.Factory.Post\n    iex> AshPagify.Misc.maybe_put_compiled_ash_pagify_scopes(Post)\n    [\n      __compiled_ash_pagify_default_scopes: %{status: :all},\n      __compiled_ash_pagify_scopes: %{\n        role: [\n          %{name: :admin, filter: %{author: \"John\"}},\n          %{name: :user, filter: %{author: \"Doe\"}}\n        ],\n        status: [\n          %{name: :all, filter: nil, default?: true},\n          %{name: :active, filter: %{age: %{lt: 10}}},\n          %{name: :inactive, filter: %{age: %{gte: 10}}}\n        ]\n      }\n    ]\n\nOr with default scopes passed as opts\n\n    iex> alias AshPagify.Factory.Post\n    iex> ash_pagify_scopes = %{role: [%{name: :user, filter: %{author: \"Doe\"}, default?: true}]}\n    iex> AshPagify.Misc.maybe_put_compiled_ash_pagify_scopes(Post, [ash_pagify_scopes: ash_pagify_scopes])\n    [\n      __compiled_ash_pagify_default_scopes: %{role: :user, status: :all},\n      __compiled_ash_pagify_scopes: %{\n        role: [\n          %{name: :admin, filter: %{author: \"John\"}},\n          %{name: :user, filter: %{author: \"Doe\"}, default?: true}\n        ],\n        status: [\n          %{name: :all, filter: nil, default?: true},\n          %{name: :active, filter: %{age: %{lt: 10}}},\n          %{name: :inactive, filter: %{age: %{gte: 10}}}\n        ]\n      },\n      ash_pagify_scopes: ash_pagify_scopes\n    ]","ref":"AshPagify.Misc.html#maybe_put_compiled_ash_pagify_scopes/2-example"},{"type":"function","title":"AshPagify.Misc.maybe_put_scopes/3","doc":"Puts the scopes params of a AshPagify struct into a keyword list only if they don't\nmatch the defaults either passed as last argument or loaded on the fly.\n\nExample:\n\n    iex> maybe_put_scopes([], %AshPagify{scopes: %{status: :inactive}}, default_scopes: %{status: :active})\n    [scopes: %{status: :inactive}]\n\n    iex> maybe_put_scopes([], %AshPagify{scopes: %{status: :active}}, default_scopes: %{status: :active})\n    []\n\n    iex> alias AshPagify.Factory.Post\n    iex> maybe_put_scopes([], %AshPagify{scopes: %{status: :active}}, for: Post)\n    [scopes: %{status: :active}]","ref":"AshPagify.Misc.html#maybe_put_scopes/3"},{"type":"function","title":"AshPagify.Misc.remove_nil_values/1","doc":"Remove nil values from a map or struct. Does not work with nested maps.","ref":"AshPagify.Misc.html#remove_nil_values/1"},{"type":"function","title":"Example - AshPagify.Misc.remove_nil_values/1","doc":"iex> AshPagify.Misc.remove_nil_values(%{a: 1, b: nil, c: 3})\n    %{a: 1, c: 3}\n\n    iex> AshPagify.Misc.remove_nil_values(%{a: 1, b: %{c: nil, d: 4}})\n    %{a: 1, b: %{c: nil, d: 4}}","ref":"AshPagify.Misc.html#remove_nil_values/1-example"},{"type":"function","title":"AshPagify.Misc.stringify_keys/2","doc":"Convert map :atom keys to string keys.\n\nYou can specify a list of keys to convert or a depth to which\nto convert keys. If you specify a depth of 1, only the top\nlevel keys will be converted. If you specify a depth of 2, the\ntop level keys and the keys of any maps in the top level will\nbe converted. And so on.\n\nList of options:\n\n- `keys`: A list of keys to convert. If a key is not in the list,\n  it will not be converted. Default is an empty list and all keys\n  will be converted.\n- `depth`: The depth to which to convert keys. Default is nil and\n  all keys will be converted.","ref":"AshPagify.Misc.html#stringify_keys/2"},{"type":"function","title":"Example - AshPagify.Misc.stringify_keys/2","doc":"iex> AshPagify.Misc.stringify_keys(%{a: 1, b: 2})\n    %{\"a\" => 1, \"b\" => 2}\n\n    iex> AshPagify.Misc.stringify_keys(%{a: 1, b: %{c: 3}})\n    %{\"a\" => 1, \"b\" => %{\"c\" => 3}}\n\n    iex> AshPagify.Misc.stringify_keys(%{a: 1, b: %{c: 3}}, keys: [:b])\n    %{:a => 1, \"b\" => %{c: 3}}\n\n    iex> AshPagify.Misc.stringify_keys(%{a: 1, b: %{c: 3}}, keys: [:b, :c])\n    %{:a => 1, \"b\" => %{\"c\" => 3}}\n\n    iex> AshPagify.Misc.stringify_keys(%{a: 1, b: %{c: 3}}, keys: [:b, :d], depth: 1)\n    %{:a => 1, \"b\" => %{c: 3}}\n\n    iex> AshPagify.Misc.stringify_keys(%{a: 1, b: %{c: 3}}, keys: [:b, :c], depth: 2)\n    %{:a => 1, \"b\" => %{\"c\" => 3}}","ref":"AshPagify.Misc.html#stringify_keys/2-example"},{"type":"function","title":"AshPagify.Misc.unique_keywords/1","doc":"Returns a list of unique keywords from a list of keywords while\npreserving the order of the first occurrence of each keyword.","ref":"AshPagify.Misc.html#unique_keywords/1"},{"type":"function","title":"Example - AshPagify.Misc.unique_keywords/1","doc":"iex> AshPagify.Misc.unique_keywords([:a, :b, :a, :c, :b])\n    [:a, :b, :c]\n\n    iex> AshPagify.Misc.unique_keywords([a: 1, b: 2, a: 3, c: 4, b: 5])\n    [a: 1, b: 2, c: 4]","ref":"AshPagify.Misc.html#unique_keywords/1-example"},{"type":"function","title":"AshPagify.Misc.walk/4","doc":"Walks a map or list and applies a serializer to the keys.\n\nThe serializer function receives the key and the opts. The serializer function\nshould return the new key.\n\nThe walk function will walk the map or list and apply the serializer to the\nkeys. If the depth is specified and it is reached, the serializer will not\nbe applied to the keys at that depth.\n\nThe serializer function can be used to convert the keys to atoms, strings, or\nany other format.","ref":"AshPagify.Misc.html#walk/4"},{"type":"function","title":"Example - AshPagify.Misc.walk/4","doc":"iex> walk(%{\"a\" => 1, \"b\" => %{\"c\" => 3}}, fn key, _opts -> String.to_atom(key) end)\n    %{a: 1, b: %{c: 3}}\n\n    iex> walk(%{\"a\" => 1, \"b\" => %{\"c\" => 3}}, fn key, _opts -> String.to_atom(key) end, depth: 1)\n    %{b: %{\"c\" => 3}, a: 1}","ref":"AshPagify.Misc.html#walk/4-example"},{"type":"module","title":"AshPagify.Tsearch","doc":"AshPagify full-text search utilities.\n\nThis module provides utilities for full-text search in AshPagify. For a basic usage\nyou can `use AshPagify.Tsearch` and implement the `tsvector` calculation in your\nresource.\n\n```elixir\ndefmodule MyApp.Resource do\n  use AshPagify.Tsearch\n  require Ash.Expr\n\n  calculations do\n    calculate :tsvector,\n              AshPostgres.Tsvector,\n              expr(\n                fragment(\n                  \"to_tsvector('simple', coalesce(?, '')) || to_tsvector('simple', coalesce(?, ''))\",\n                  name,\n                  title\n                )\n              ),\n              public?: true\n    end\n  end\nend\n```\n\nAshPagify.Tsearch provides the following calculations which are used by `AshPagify.search` for full-text search:\n\n- `:tsquery` - The tsquery to search for.\n- `:full_text_search` - A boolean indicating whether the tsvector matches the tsquery.\n- `:full_text_search_rank` - The rank of the tsvector against the tsquery.\n\nIf you need to provide a custom implementation for one of these calculations, you can do so by\n1. not require the calculation in your resource\n2. implementing the calculation in your resource\n\n```elixir\ndefmodule MyApp.Resource do\n  use AshPagify.Tsearch, only: [:full_text_search, :full_text_search_rank]\n  require Ash.Expr\n\n  calculations do\n    calculate :tsquery,\n              AshPostgres.Tsquery,\n              # use english dictionary unaccent PostgreSQL extension\n              expr(fragment(\"to_tsquery('english', unaccent(?))\", ^arg(:search))) do\n      public? true\n      argument :search, :string, allow_expr?: true, allow_nil?: false\n    end\n\n    ...\n  end\nend\n```","ref":"AshPagify.Tsearch.html"},{"type":"module","title":"Installation - AshPagify.Tsearch","doc":"If you do not use any PostgreSQL specific full-text search extensions, you can skip this step.\n\nOtherwise, you need to add the required extensions to your Repo.installed_extensions list.\n\n```elixir\ndefmodule MyApp.Repo do\n  use AshPostgres.Repo, otp_app: :my_app\n\n  def installed_extensions do\n    [\"ash-functions\", \"uuid-ossp\", \"citext\", \"unaccent\", AshUUID.PostgresExtension]\n  end\nend\n```","ref":"AshPagify.Tsearch.html#module-installation"},{"type":"module","title":"Configuration - AshPagify.Tsearch","doc":"You can configure the full-text search options globally, per resource, or locally.\nThe options are merged in the following order:\n\n1. Function arguments (highest priority)\n2. Resource-level options (set in the resource module)\n3. Global options in the application environment (set in config files)\n4. Library defaults (lowest priority)\n\nHave a look at `t:tsearch_option/0` for a list of available options.","ref":"AshPagify.Tsearch.html#module-configuration"},{"type":"module","title":"Features - AshPagify.Tsearch","doc":"### :prefix (PostgreSQL 8.4 and newer only)\n\nPostgreSQL's full text search matches on whole words by default. If you want to search for partial words,\nhowever, you can set :prefix to true in one of the configuration options described above.\n\nDefault: `true`\n\n### :negation\n\nPostgreSQL's full text search matches all search terms by default. If you want to exclude certain words,\nyou can set :negation to true. Then any term that begins with an exclamation point `!` will be excluded\nfrom the results.\n\nDefault: `true`\n\n### :any_word\n\nSetting this attribute to true will perform a search which will return all models containing any word\nin the search terms. If set to false, the search will return all models containing all words in the\nsearch terms.\n\nDefault: `false`\n\n### :tsvector_column\n\nThis option allows you to specify a custom tsvector column expression for dynamic tsvector column lookup.\nHave a look at the `Enhanced search` section for more information.\n\nDefault: `nil`\n\n### :dictionary\n\nWe do not provide a mechanisme to set the dictionary in the configuration options. You can set the dictionary\nin a custom `tsquery` calculation implementation in your resource.\n\n### :weighting\n\nWe do not provide a mechanisme to set the weighting in the configuration options. You can set the weighting\nin your `tsvector` calculation implementation in your resource (or in the tsvector column in your database).","ref":"AshPagify.Tsearch.html#module-features"},{"type":"module","title":"Enhanced search - AshPagify.Tsearch","doc":"If you need to be able to change the `tsvector` column dynamically (e.g. based on some user input), you can\nuse the `:tsvector_column` option. This option should be specified in your resource module. Then you need\nto pass the targeted tsvector calculation as `full_text_search: [tsvector: :custom_tsvector]` option to your\n`AshPagify.validate_and_run/4` call (or other functions provided by AshPagify). This approach is mandatory so we\ncan serialize the custom tsvector in `AshPagify.query_to_filters_map` and restore it in `AshPagify.query_for_filters_map`\naccordingly.\n\n```elixir\ndefmodule MyApp.Resource do\n  use AshPagify.Tsearch\n  require Ash.Expr\n\n  def full_text_search do\n    [\n      tsvector_column: [\n        custom_tsvector: Ash.Expr.expr(custom_tsvector),\n        another_custom_tsvector: Ash.Expr.expr(another_custom_tsvector),\n      ]\n    ]\n  end\n\n  calculations do\n    # default tsvector calculation\n    calculate :tsvector,\n              AshPostgres.Tsvector,\n              expr(\n                fragment(\n                  \"to_tsvector('simple', coalesce(?, '')) || to_tsvector('simple', coalesce(?, ''))\",\n                  name,\n                  title\n                )\n              ),\n              public?: true\n    end\n\n    # custom tsvector calculation\n    calculate :custom_tsvector,\n              AshPostgres.Tsvector,\n              expr(\n                fragment(\n                  \"to_tsvector('simple', coalesce(?, ''))\",\n                  name\n                )\n              ),\n              public?: true\n    end\n\n    # another custom tsvector calculation\n    calculate :another_custom_tsvector,\n              AshPostgres.Tsvector,\n              expr(\n                fragment(\n                  \"to_tsvector('simple', coalesce(?, ''))\",\n                  title\n                )\n              ),\n              public?: true\n    end\n  end\nend\n```\n\nThe in your business logic:\n\n```elixir\ndef search(query, opts \\\\ []) do\n  opts = AshPagify.set_tsvector(:custom_tsvector, opts)\n  query\n  |> AshPagify.validate_and_run(MyApp.Resource, opts)\nend\n```","ref":"AshPagify.Tsearch.html#module-enhanced-search"},{"type":"function","title":"AshPagify.Tsearch.default_opts/0","doc":"Returns the default full text search options.\n\nThe default options are:\n- `:negation` - `true`\n- `:prefix` - `true`\n- `:any_word` - `false`\n- `:tsvector_column` - `nil`","ref":"AshPagify.Tsearch.html#default_opts/0"},{"type":"function","title":"AshPagify.Tsearch.merge_opts/1","doc":"Merges the given options with the default options.\n\nThe options are merged in the following order:\n\n1. Function arguments (highest priority)\n2. Resource-level options (set in the resource module)\n3. Global options in the application environment (set in config files)\n4. Library defaults (lowest priority)","ref":"AshPagify.Tsearch.html#merge_opts/1"},{"type":"function","title":"AshPagify.Tsearch.normalize/1","doc":"Replaces disallowed characters in the term with spaces.","ref":"AshPagify.Tsearch.html#normalize/1"},{"type":"function","title":"AshPagify.Tsearch.option_keys/0","doc":"Returns the keys for the full text search options.","ref":"AshPagify.Tsearch.html#option_keys/0"},{"type":"function","title":"AshPagify.Tsearch.query_terms/1","doc":"Splits the search term into terms and returns a list of trimmed terms.","ref":"AshPagify.Tsearch.html#query_terms/1"},{"type":"function","title":"AshPagify.Tsearch.sanitize_term/2","doc":"Handles the negation of the term.","ref":"AshPagify.Tsearch.html#sanitize_term/2"},{"type":"function","title":"AshPagify.Tsearch.tsquery/2","doc":"Returns the tsquery expression for the given search term and options.\n\nThe search term is split into terms and each term is sanitized and normalized.\nThe terms are then combined into a tsquery expression.","ref":"AshPagify.Tsearch.html#tsquery/2"},{"type":"function","title":"AshPagify.Tsearch.tsquery_expression/2","doc":"After this, the SQL expression evaluates to a string containing the term surrounded by single-quotes.\n\nIf :prefix is true, then the term will have :* appended to the end.\nIf :negated is true, then the term will have ! prepended to the front and be surrounded by brackets.","ref":"AshPagify.Tsearch.html#tsquery_expression/2"},{"type":"function","title":"AshPagify.Tsearch.tsquery_for_term/2","doc":"Returns the tsquery expression for the given term and options.","ref":"AshPagify.Tsearch.html#tsquery_for_term/2"},{"type":"function","title":"AshPagify.Tsearch.tsvector/1","doc":"Returns the tsvector expression for the given options.\n\nRespects the `:tsvector_column` option together with the `:tsvector` option.\nIf both are set, the `:tsvector` option is used to lookup the tsvector column\nin the `:tsvector_column` option. If the custom tsvector column is not found,\nthe default tsvector column is used.","ref":"AshPagify.Tsearch.html#tsvector/1"},{"type":"type","title":"AshPagify.Tsearch.tsearch_option/0","doc":"A list of options for full text search.\n\n- `:negation` - Whether to negate the search. Defaults to `true`.\n- `:prefix` - Whether to prefix the search. Defaults to `true`.\n- `:any_word` - Whether to combine multiple words with || or &&. Defaults to `false` (&&).\n- `:tsvector_column` - Custom tsvector column expressions for dynamic tsvector\n  column lookup. Defaults to `nil`.","ref":"AshPagify.Tsearch.html#t:tsearch_option/0"},{"type":"module","title":"AshPagify.Validation","doc":"Utilities for validating and transforming full-text search, scoping,\nfiltering, ordering, and pagination parameters.","ref":"AshPagify.Validation.html"},{"type":"function","title":"AshPagify.Validation.validate_filter_form/2","doc":"Validates the form filter in the given parameters.\n\nUses `AshPagify.FormFilter.validate/3` to parse the form filter.\n\nIf `replace_invalid_params?` is `true`, invalid\nfilter_form parameters are removed and an error is added to the `:errors` key\nin the returned map. If `replace_invalid_params?` is `false`, invalid\nfilter_form parameters are not removed and an error is added to the `:errors`\nkey in the returned map.\n\nIf the `:filter_form` key is `nil`, it is returned as is.","ref":"AshPagify.Validation.html#validate_filter_form/2"},{"type":"function","title":"Examples - AshPagify.Validation.validate_filter_form/2","doc":"iex> AshPagify.Validation.validate_filter_form(%{}, for: Post)\n    %{}\n\n    iex> AshPagify.Validation.validate_filter_form(%{filter_form: nil}, for: Post)\n    %{filter_form: nil}\n\n    iex> %{filter_form: filter_form} = AshPagify.Validation.validate_filter_form(%{filter_form: %{}}, for: Post)\n    iex> filter_form\n    %{}\n\n    iex> %{filter_form: filter_form} = AshPagify.Validation.validate_filter_form(%{filter_form: %{}}, for: Post, replace_invalid_params?: true)\n    iex> filter_form\n    %{}\n\n    iex> %{filter_form: filter_form, errors: errors} = AshPagify.Validation.validate_filter_form(%{filter_form:  %{\"field\" => \"non_existent\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}}, for: Post)\n    iex> filter_form\n    %{\"field\" => \"non_existent\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}\n    iex> errors\n    [filter_form: [{:field, {\"No such field non_existent\", []}}]]\n\n    iex> %{filter_form: filter_form, errors: errors} = AshPagify.Validation.validate_filter_form(%{filter_form:  %{\"field\" => \"non_existent\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}}, for: Post, replace_invalid_params?: true)\n    iex> filter_form\n    %{}\n    iex> errors\n    [filter_form: [{:field, {\"No such field non_existent\", []}}]]","ref":"AshPagify.Validation.html#validate_filter_form/2-examples"},{"type":"function","title":"AshPagify.Validation.validate_filters/2","doc":"Validates the filters in the given parameters.\n\nIf `replace_invalid_params?` is `true`, invalid\nfilters are removed and an error is added to the `:errors` key in the returned map. If\n`replace_invalid_params?` is `false`, invalid filters are not removed and an error is added to\nthe `:errors` key in the returned map. Only the first error is added to the `:errors` key.\n\nIf the `:filters` key is `nil`, it is returned as is.","ref":"AshPagify.Validation.html#validate_filters/2"},{"type":"function","title":"Examples - AshPagify.Validation.validate_filters/2","doc":"iex> AshPagify.Validation.validate_filters(%{}, for: Post)\n    %{}\n\n    iex> AshPagify.Validation.validate_filters(%{filters: nil}, for: Post)\n    %{filters: nil}\n\n    iex> %{filters: filters} = AshPagify.Validation.validate_filters(%{filters: [%{name: \"Post 1\"}]}, for: Post)\n    iex> filters\n    #Ash.Filter \n\n    iex> %{filters: filters, errors: errors} = AshPagify.Validation.validate_filters(%{filters: 1}, for: Post, replace_invalid_params?: true)\n    iex> filters\n    nil\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      filters: [\n        %Ash.Error.Query.InvalidFilterValue{value: 1}\n      ]\n    ]\n\n    iex> %{filters: filters, errors: errors} = AshPagify.Validation.validate_filters(%{filters: 1}, for: Post)\n    iex> filters\n    1\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      filters: [\n        %Ash.Error.Query.InvalidFilterValue{value: 1}\n      ]\n    ]","ref":"AshPagify.Validation.html#validate_filters/2-examples"},{"type":"function","title":"AshPagify.Validation.validate_order_by/2","doc":"Validates the order by in the given parameters.\n\nIf `replace_invalid_params?` is `true`, invalid\norder by values are removed and an error is added to the `:errors` key in the returned map. If\n`replace_invalid_params?` is `false`, invalid order by values are not removed and an error is added\nto the `:errors` key in the returned map. Only the first error is added to the `:errors` key.\n\nIf the `:order_by` key is `nil`, it is returned as is.","ref":"AshPagify.Validation.html#validate_order_by/2"},{"type":"function","title":"Examples - AshPagify.Validation.validate_order_by/2","doc":"iex> AshPagify.Validation.validate_order_by(%{}, for: Post)\n    %{}\n\n    iex> AshPagify.Validation.validate_order_by(%{order_by: nil}, for: Post)\n    %{order_by: nil}\n\n    iex> %{order_by: order_by} = AshPagify.Validation.validate_order_by(%{order_by: [\"name\"]}, for: Post)\n    iex> order_by\n    [name: :asc]\n\n    iex> %{order_by: order_by} = AshPagify.Validation.validate_order_by(%{order_by: \"++name\"}, for: Post)\n    iex> order_by\n    [name: :asc_nils_first]\n\n    iex> %{order_by: order_by} = AshPagify.Validation.validate_order_by(%{order_by: \"name,--comments_count\"}, for: Post)\n    iex> order_by\n    [name: :asc, comments_count: :desc_nils_last]\n\n    iex> %{order_by: order_by, errors: errors} = AshPagify.Validation.validate_order_by(%{order_by: \"--name,non_existent\"}, for: Post, replace_invalid_params?: true)\n    iex> order_by\n    [name: :desc_nils_last]\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      order_by: [\n        %Ash.Error.Query.NoSuchField{field: \"non_existent\", resource: Post}\n      ]\n    ]","ref":"AshPagify.Validation.html#validate_order_by/2-examples"},{"type":"function","title":"AshPagify.Validation.validate_pagination/2","doc":"Validates the pagination parameters in the given parameters.\n\nIf `replace_invalid_params?` is `true`,\ninvalid pagination parameters are removed / replaced and an error is added to the `:errors` key in\nthe returned map. If `replace_invalid_params?` is `false`, invalid pagination parameters are not\nremoved and an error is added to the `:errors` key in the returned map.\n\nIf the `:limit` key is `nil`, the default_limit value is applied.\n\nIf the `:offset` key is `nil`, it is returned as is.","ref":"AshPagify.Validation.html#validate_pagination/2"},{"type":"function","title":"Examples - AshPagify.Validation.validate_pagination/2","doc":"iex> AshPagify.Validation.validate_pagination(%{}, for: Post)\n    %{limit: 15, offset: 0}\n\n    iex> AshPagify.Validation.validate_pagination(%{limit: nil}, for: Post)\n    %{limit: 15, offset: 0}\n\n    iex> %{limit: limit} = AshPagify.Validation.validate_pagination(%{limit: 10}, for: Post)\n    iex> limit\n    10\n\n    iex> %{limit: limit, errors: errors} = AshPagify.Validation.validate_pagination(%{limit: 0}, for: Post, replace_invalid_params?: true)\n    iex> limit\n    15\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      limit: [\n        %Ash.Error.Query.InvalidLimit{limit: 0}\n      ]\n    ]\n\n    iex> %{limit: limit} = AshPagify.Validation.validate_pagination(%{limit: 100}, for: Post)\n    iex> limit\n    100\n\n    iex> %{limit: limit, errors: errors} = AshPagify.Validation.validate_pagination(%{limit: -1}, for: Post, replace_invalid_params?: true)\n    iex> limit\n    15\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      limit: [\n        %Ash.Error.Query.InvalidLimit{limit: -1}\n      ]\n    ]\n\n    iex> %{offset: offset} = AshPagify.Validation.validate_pagination(%{offset: 10}, for: Post)\n    iex> offset\n    10\n\n    iex> %{offset: offset, errors: errors} = AshPagify.Validation.validate_pagination(%{offset: -1}, for: Post, replace_invalid_params?: true)\n    iex> offset\n    0\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      offset: [\n        %Ash.Error.Query.InvalidOffset{offset: -1}\n      ]\n    ]\n\n    iex> %{offset: offset, errors: errors} = AshPagify.Validation.validate_pagination(%{offset: -1}, for: Post)\n    iex> offset\n    -1\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      offset: [\n        %Ash.Error.Query.InvalidOffset{offset: -1}\n      ]\n    ]","ref":"AshPagify.Validation.html#validate_pagination/2-examples"},{"type":"function","title":"AshPagify.Validation.validate_params/3","doc":"","ref":"AshPagify.Validation.html#validate_params/3"},{"type":"function","title":"AshPagify.Validation.validate_scopes/4","doc":"Validates the scopes in the given parameters.\n\nIf `replace_invalid_params?` is `true`, invalid\nscopes are removed and an error is added to the `:errors` key in the returned map. If\n`replace_invalid_params?` is `false`, invalid scopes are not removed and an error is added to\nthe `:errors` key in the returned map. Only the first error is added to the `:errors` key.\n\nIf the `:scopes` key is `nil`, it is returned as is.","ref":"AshPagify.Validation.html#validate_scopes/4"},{"type":"function","title":"Examples - AshPagify.Validation.validate_scopes/4","doc":"iex> ash_pagify_scopes = %{}\n    iex> AshPagify.Validation.validate_scopes(%{}, ash_pagify_scopes)\n    %{}\n\n    iex> ash_pagify_scopes = %{}\n    iex> AshPagify.Validation.validate_scopes(%{scopes: nil}, ash_pagify_scopes)\n    %{scopes: nil}\n\n    iex> ash_pagify_scopes = %{}\n    iex> %{scopes: scopes} = AshPagify.Validation.validate_scopes(%{scopes: %{role: :admin}}, ash_pagify_scopes)\n    iex> scopes\n    %{role: :admin}\n\n    iex> ash_pagify_scopes = %{}\n    iex> %{scopes: scopes, errors: errors} = AshPagify.Validation.validate_scopes(%{scopes: %{role: :non_existent}}, ash_pagify_scopes)\n    iex> scopes\n    %{role: :non_existent}\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      scopes: [\n        %AshPagify.Error.Query.NoSuchScope{group: :role, name: :non_existent}\n      ]\n    ]\n\n    iex> ash_pagify_scopes = %{}\n    iex> %{scopes: scopes, errors: errors} = AshPagify.Validation.validate_scopes(%{scopes: %{role: :non_existent}}, ash_pagify_scopes, nil, replace_invalid_params?: true)\n    iex> scopes\n    nil\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      scopes: [\n        %AshPagify.Error.Query.NoSuchScope{group: :role, name: :non_existent}\n      ]\n    ]\n\n    iex> ash_pagify_scopes = %{}\n    iex> %{scopes: scopes, errors: errors} = AshPagify.Validation.validate_scopes(%{scopes: %{non_existent: :admin}}, ash_pagify_scopes)\n    iex> scopes\n    %{non_existent: :admin}\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      scopes: [\n        %AshPagify.Error.Query.NoSuchScope{group: :non_existent, name: :admin}\n      ]\n    ]\n\n    iex> ash_pagify_scopes = %{}\n    iex> %{scopes: scopes, errors: errors} = AshPagify.Validation.validate_scopes(%{scopes: %{non_existent: :admin}}, ash_pagify_scopes, nil, replace_invalid_params?: true)\n    iex> scopes\n    nil\n    iex> AshPagify.Error.clear_stacktrace(errors)\n    [\n      scopes: [\n        %AshPagify.Error.Query.NoSuchScope{group: :non_existent, name: :admin}\n      ]\n    ]","ref":"AshPagify.Validation.html#validate_scopes/4-examples"},{"type":"function","title":"AshPagify.Validation.validate_search/2","doc":"Validates the search attribute in the given parameters.\n\nIn case full_text_search is configured, we validate if the given search\nattribute is a valid full text search attribute.\n\nIf `replace_invalid_params?` is `true`, invalid\nsearch parameters are removed and an error is added to the `:errors` key in the returned map. If\n`replace_invalid_params?` is `false`, invalid search parameters are not removed and an error is added to\nthe `:errors` key in the returned map. Only the first error is added to the `:errors` key.\n\nIf the `:search` key is `nil` or an empty string, it is returned as is.","ref":"AshPagify.Validation.html#validate_search/2"},{"type":"module","title":"AshPagify.Components","doc":"Phoenix headless components for pagination and sortable tables with `AshPagify`.","ref":"AshPagify.Components.html"},{"type":"module","title":"Introduction - AshPagify.Components","doc":"Please refere to the _Usage_ section in `AshPagify` for more information.\n\nThis module provides two components: `AshPagify.Components.Pagination` and\n`AshPagify.Components.Table`. The components are designed to work with\n`AshPagify` and `Ash.Resource` structs. They are by default unstyled components\nwhich add basic classes and attributes to the elements they render. However,\nyou can customize the components by passing options.\n\nFurther, `AshPagify.Components` provides helper functions to build paths for\npagination and sorting links. The paths are built based on the current query\nparameters and the new parameters that are passed to the function.","ref":"AshPagify.Components.html#module-introduction"},{"type":"module","title":"Customization - AshPagify.Components","doc":"The default classes, attributes, texts and symbols can be overridden by\npassing the `opts` assign. Since you probably will use the same `opts` in all\nyour templates, you can globally configure an `opts` provider function for\neach component.\n\nThe functions have to return the options as a keyword list. The overrides\nare deep-merged into the default options.\n\n    defmodule MyAppWeb.CoreComponents do\n      use Phoenix.Component\n\n      def pagination_opts do\n         [\n          ellipsis_attrs: [class: \"ellipsis\"],\n          ellipsis_content: \"\",\n          next_link_attrs: [class: \"next\"],\n          next_link_content: next_icon(),\n          page_links: {:ellipsis, 7},\n          pagination_link_aria_label: &\"#{&1}\",\n          previous_link_attrs: [class: \"prev\"],\n          previous_link_content: previous_icon()\n        ]\n      end\n\n      defp next_icon do\n        assigns = %{}\n\n        ~H\"\"\"\n         \n        \"\"\"\n      end\n\n      defp previous_icon do\n        assigns = %{}\n\n        ~H\"\"\"\n         \n        \"\"\"\n      end\n\n      def table_opts do\n        [\n          container: true,\n          container_attrs: [class: \"table-container\"],\n          no_results_content: no_results_content(),\n          table_attrs: [class: \"table\"]\n        ]\n      end\n\n      defp no_results_content do\n        assigns = %{}\n\n        ~H\"\"\"\n         Nothing found. \n        \"\"\"\n      end\n    end\n\nRefer to `t:pagination_option/0` and `t:table_option/0` for a list of\navailable options and defaults.\n\nOnce you have defined these functions, you can reference them with a\nmodule/function tuple in `config/config.exs`.\n\n```elixir\nconfig :ash_pagify,\n  pagination: [opts: {MyAppWeb.CoreComponents, :pagination_opts}],\n  table: [opts: {MyAppWeb.CoreComponents, :table_opts}]\n```","ref":"AshPagify.Components.html#module-customization"},{"type":"module","title":"Hiding default parameters - AshPagify.Components","doc":"Default values for scoping, pagination and ordering are omitted from the query\nparameters. AshPagify.Components function will pick up the default values\nfrom the `Ash.Resource` specifications.","ref":"AshPagify.Components.html#module-hiding-default-parameters"},{"type":"module","title":"Links - AshPagify.Components","doc":"Links are generated with `Phoenix.Component.link/1`. This will\nlead to ` ` tags with `data-phx-link` and `data-phx-link-state` attributes,\nwhich will be ignored outside of LiveViews and LiveComponents.\n\nWhen used within a LiveView or LiveComponent, you will need to handle the new\nparams in the `c:Phoenix.LiveView.handle_params/3` callback of your LiveView\nmodule.","ref":"AshPagify.Components.html#module-links"},{"type":"module","title":"Using JS commands - AshPagify.Components","doc":"You can pass a `Phoenix.LiveView.JS` command as `on_paginate` and `on_sort`\nattributes.\n\nIf used with the `path` attribute, the URL will be patched _and_ the given\nJS command will be executed.\n\nIf used without the `path` attribute, you will need to include a `push`\ncommand to trigger an event when a pagination or sort link is clicked.\n\nYou can set a different target by assigning a `:target`. The value\nwill be used as the `phx-target` attribute.\n\n     \n\n     \n\nYou will need to handle the event in the `c:Phoenix.LiveView.handle_event/3`\nor `c:Phoenix.LiveComponent.handle_event/3` callback of your\nLiveView or LiveComponent module. The event name will be the one you set with\nthe `:event` option.\n\n    @impl true\n    def handle_event(\"paginate-posts\", %{\"offset\" => offset}, socket) do\n      ash_pagify = AshPagify.set_offset(socket.assigns.meta.ash_pagify, offset)\n\n      with {:ok, {posts, meta}} <- Post.list_posts(ash_pagify) do\n        {:noreply, assign(socket, posts: posts, meta: meta)}\n      end\n    end\n\n    @impl true\n    def handle_event(\"sort-posts\", %{\"order\" => order}, socket) do\n      ash_pagify = AshPagify.push_order(socket.assigns.meta.ash_pagify, order)\n\n      with {:ok, {posts, meta}} <- Post.list_posts(ash_pagify) do\n        {:noreply, assign(socket, posts: posts, meta: meta)}\n      end\n    end","ref":"AshPagify.Components.html#module-using-js-commands"},{"type":"function","title":"AshPagify.Components.build_path/3","doc":"Builds a path that includes query parameters for the given `AshPagify` struct\nusing the referenced Components path helper function.\n\nThe first argument can be either one of:\n\n- an MFA tuple (module, function name as atom, arguments)\n- a 2-tuple (function, arguments)\n- a URL string, usually produced with a verified route (e.g. `~p\"/some/path\"`)\n- a function that takes the AshPagify parameters as a keyword list as an argument\n\nDefault values for `scopes`, `limit` and `order_by` are omitted from the query parameters.\nTo pick up the default parameters from an `Ash.Resource`, you need to pass the\n`:for` option. If you pass a `AshPagify.Meta` struct as the second argument,\nthese options are retrieved from the struct automatically.","ref":"AshPagify.Components.html#build_path/3"},{"type":"function","title":"Examples - AshPagify.Components.build_path/3","doc":"","ref":"AshPagify.Components.html#build_path/3-examples"},{"type":"function","title":"With a verified route - AshPagify.Components.build_path/3","doc":"The examples below use plain URL strings without the p-sigil, so that the\ndoc tests work, but in your application, you can use verified routes or\nanything else that produces a URL.\n\n    iex> ash_pagify = %AshPagify{offset: 20, limit: 10}\n    iex> path = build_path(\"/posts\", ash_pagify)\n    iex> %URI{path: parsed_path, query: parsed_query} = URI.parse(path)\n    iex> {parsed_path, URI.decode_query(parsed_query)}\n    {\"/posts\", %{\"offset\" => \"20\", \"limit\" => \"10\"}}\n\nThe AshPagify query parameters will be merged into existing query parameters.\n\n    iex> ash_pagify = %AshPagify{offset: 20, limit: 10}\n    iex> path = build_path(\"/posts?category=A\", ash_pagify)\n    iex> %URI{path: parsed_path, query: parsed_query} = URI.parse(path)\n    iex> {parsed_path, URI.decode_query(parsed_query)}\n    {\"/posts\", %{\"offset\" => \"20\", \"limit\" => \"10\", \"category\" => \"A\"}}","ref":"AshPagify.Components.html#build_path/3-with-a-verified-route"},{"type":"function","title":"With an MFA tuple - AshPagify.Components.build_path/3","doc":"iex> ash_pagify = %AshPagify{offset: 20, limit: 10}\n    iex> build_path(\n    ...>   {AshPagify.ComponentsTest, :route_helper, [%Plug.Conn{}, :posts]},\n    ...>   ash_pagify\n    ...> )\n    \"/posts?limit=10&offset=20\"","ref":"AshPagify.Components.html#build_path/3-with-an-mfa-tuple"},{"type":"function","title":"With a function/arguments tuple - AshPagify.Components.build_path/3","doc":"iex> post_path = fn _conn, :index, query ->\n    ...>   \"/posts?\" <> Plug.Conn.Query.encode(query)\n    ...> end\n    iex> ash_pagify = %AshPagify{offset: 20, limit: 10}\n    iex> build_path({post_path, [%Plug.Conn{}, :index]}, ash_pagify)\n    \"/posts?limit=10&offset=20\"\n\nWe're defining fake path helpers for the scope of the doctests. In a real\nPhoenix application, you would pass something like\n`{Routes, :post_path, args}` or `{&Routes.post_path/3, args}` as the\nfirst argument.","ref":"AshPagify.Components.html#build_path/3-with-a-function-arguments-tuple"},{"type":"function","title":"Passing a `AshPagify.Meta` struct or a keyword list - AshPagify.Components.build_path/3","doc":"You can also pass a `AshPagify.Meta` struct or a keyword list as the third\nargument.\n\n    iex> post_path = fn _conn, :index, query ->\n    ...>   \"/posts?\" <> Plug.Conn.Query.encode(query)\n    ...> end\n    iex> ash_pagify = %AshPagify{offset: 20, limit: 10}\n    iex> meta = %AshPagify.Meta{ash_pagify: ash_pagify, resource: AshPagify.Factory.Post}\n    iex> build_path({post_path, [%Plug.Conn{}, :index]}, meta)\n    \"/posts?limit=10&offset=20\"\n    iex> query_params = to_query(ash_pagify)\n    iex> build_path({post_path, [%Plug.Conn{}, :index]}, query_params)\n    \"/posts?limit=10&offset=20\"","ref":"AshPagify.Components.html#build_path/3-passing-a-ashpagify-meta-struct-or-a-keyword-list"},{"type":"function","title":"Additional path parameters - AshPagify.Components.build_path/3","doc":"If the path helper takes additional path parameters, just add them to the\nsecond argument.\n\n    iex> user_post_path = fn _conn, :index, id, query ->\n    ...>   \"/users/#{id}/posts?\" <> Plug.Conn.Query.encode(query)\n    ...> end\n    iex> ash_pagify = %AshPagify{offset: 20, limit: 10}\n    iex> build_path({user_post_path, [%Plug.Conn{}, :index, 123]}, ash_pagify)\n    \"/users/123/posts?limit=10&offset=20\"","ref":"AshPagify.Components.html#build_path/3-additional-path-parameters"},{"type":"function","title":"Additional query parameters - AshPagify.Components.build_path/3","doc":"If the last path helper argument is a query parameter list, the AshPagify\nparameters are merged into it.\n\n    iex> post_url = fn _conn, :index, query ->\n    ...>   \"https://posts.ash_pagify/posts?\" <> Plug.Conn.Query.encode(query)\n    ...> end\n    iex> ash_pagify = %AshPagify{order_by: [name: :desc]}\n    iex> build_path({post_url, [%Plug.Conn{}, :index, [user_id: 123]]}, ash_pagify)\n    \"https://posts.ash_pagify/posts?user_id=123&order_by[]=-name\"\n    iex> build_path(\n    ...>   {post_url,\n    ...>    [%Plug.Conn{}, :index, [category: \"small\", user_id: 123]]},\n    ...>   ash_pagify\n    ...> )\n    \"https://posts.ash_pagify/posts?category=small&user_id=123&order_by[]=-name\"","ref":"AshPagify.Components.html#build_path/3-additional-query-parameters"},{"type":"function","title":"Set page as path parameter - AshPagify.Components.build_path/3","doc":"Finally, you can also pass a function that takes the AshPagify parameters as\na keyword list as an argument. Default values will not be included in the\nparameters passed to the function. You can use this if you need to set some\nof the parameters as path parameters instead of query parameters.\n\n    iex> ash_pagify = %AshPagify{offset: 20, limit: 10}\n    iex> build_path(\n    ...>   fn params ->\n    ...>     {offset, params} = Keyword.pop(params, :offset)\n    ...>     query = Plug.Conn.Query.encode(params)\n    ...>     if offset, do: \"/posts/page/#{offset}?#{query}\", else: \"/posts?#{query}\"\n    ...>   end,\n    ...>   ash_pagify\n    ...> )\n    \"/posts/page/20?limit=10\"\n\nNote that in this example, the anonymous function just returns a string. With\nPhoenix 1.7, you will be able to use verified routes.\n\n    build_path(\n      fn params ->\n        {offset, query} = Keyword.pop(params, :offset)\n        if offset, do: ~p\"/posts/page/#{offset}?#{query}\", else: ~p\"/posts?#{query}\"\n      end,\n      ash_pagify\n    )\n\nNote that the keyword list passed to the path builder function is built using\n`Plug.Conn.Query.encode/2`, which means filter_forms are formatted as maps.","ref":"AshPagify.Components.html#build_path/3-set-page-as-path-parameter"},{"type":"function","title":"Set filter_form value as path parameter - AshPagify.Components.build_path/3","doc":"iex> ash_pagify = %AshPagify{\n    ...>   offset: 20,\n    ...>   order_by: [:updated_at],\n    ...>   filter_form: %{\n    ...>     \"field\" => \"author\",\n    ...>     \"operator\" => \"eq\",\n    ...>     \"value\" => \"John\"\n    ...>   }\n    ...> }\n    iex> build_path(\n    ...>   fn params ->\n    ...>     {offset, params} = Keyword.pop(params, :offset)\n    ...>     filter_form = Keyword.get(params, :filter_form, %{})\n    ...>     author = Map.get(filter_form, \"value\", nil)\n    ...>     params = Keyword.put(params, :filter_form, %{})\n    ...>     query = Plug.Conn.Query.encode(params)\n    ...>\n    ...>     case {offset, author} do\n    ...>       {nil, nil} -> \"/posts?#{query}\"\n    ...>       {offset, nil} -> \"/posts/page/#{offset}?#{query}\"\n    ...>       {nil, author} -> \"/posts/author/#{author}?#{query}\"\n    ...>       {offset, author} -> \"/posts/author/#{author}/page/#{offset}?#{query}\"\n    ...>     end\n    ...>   end,\n    ...>   ash_pagify\n    ...> )\n    \"/posts/author/John/page/20?order_by[]=updated_at\"","ref":"AshPagify.Components.html#build_path/3-set-filter_form-value-as-path-parameter"},{"type":"function","title":"If only path is set - AshPagify.Components.build_path/3","doc":"If only the path is set, it is returned as is.\n\n    iex> build_path(\"/posts\", nil)\n    \"/posts\"","ref":"AshPagify.Components.html#build_path/3-if-only-path-is-set"},{"type":"function","title":"AshPagify.Components.build_scope_path/4","doc":"Wrapper around `build_path/3` that builds a path with the updated scope.\n\nExamples\n\n    iex> ash_pagify = %AshPagify{offset: 20, limit: 10}\n    iex> meta = %AshPagify.Meta{ash_pagify: ash_pagify, resource: AshPagify.Factory.Post}\n    iex> build_scope_path(\"/posts\", meta, %{status: :active})\n    \"/posts?limit=10&scopes[status]=active\"","ref":"AshPagify.Components.html#build_scope_path/4"},{"type":"function","title":"AshPagify.Components.pagination/1","doc":"Generates a pagination element.","ref":"AshPagify.Components.html#pagination/1"},{"type":"function","title":"Examples - AshPagify.Components.pagination/1","doc":"","ref":"AshPagify.Components.html#pagination/1-examples"},{"type":"function","title":"Page link options - AshPagify.Components.pagination/1","doc":"By default, page links for all pages are shown. You can limit the number of\npage links or disable them altogether by passing the `:page_links` option.\n\n- `:all`: Show all page links.\n- `:hide`: Don't show any page links. Only the previous/next links will be\n  shown.\n- `{:ellipsis, x}`: Limits the number of page links. The first and last page\n  are always displayed. The `x` refers to the number of additional page links\n  to show (default n=4).","ref":"AshPagify.Components.html#pagination/1-page-link-options"},{"type":"function","title":"Attributes - AshPagify.Components.pagination/1","doc":"* `meta` (`AshPagify.Meta`) (required) - The meta information of the query as returned by the `AshPagify` query functions.\n* `path` (`:any`) - If set, the current view is patched with updated query parameters when a\n  pagination link is clicked. In case the `on_paginate` attribute is set as\n  well, the URL is patched _and_ the given command is executed.\n\n  The value must be either a URI string (Phoenix verified route), an MFA or FA\n  tuple (Phoenix route helper), or a 1-ary path builder function. See\n  `AshPagify.Components.build_path/3` for details.\n\n  Defaults to `nil`.\n* `on_paginate` (`Phoenix.LiveView.JS`) - A `Phoenix.LiveView.JS` command that is triggered when a pagination link is\n  clicked.\n\n  If used without the `path` attribute, you should include a `push` operation\n  to handle the event with the `handle_event` callback.\n\n      <.pagination\n        meta={@meta}\n        on_paginate={\n          JS.dispatch(\"my_app:scroll_to\", to: \"#post-table\") |> JS.push(\"paginate\")\n        }\n      />\n\n  If used with the `path` attribute, the URL is patched _and_ the given\n  JS command is executed.\n\n      <.pagination\n        meta={@meta}\n        path={~\"/posts\"}\n        on_paginate={JS.dispatch(\"my_app:scroll_to\", to: \"#post-table\")}\n      />\n\n  With the above attributes in place, you can add the following JavaScript to\n  your application to scroll to the top of your table whenever a pagination\n  link is clicked:\n\n  ```js\n  window.addEventListener(\"my_app:scroll_to\", (e) => {\n    e.target.scrollIntoView();\n  });\n  ```\n\n  You can use CSS to scroll to the new position smoothly.\n\n  ```css\n  html {\n    scroll-behavior: smooth;\n  }\n  ```\n\n  Defaults to `nil`.\n* `target` (`:string`) - Sets the `phx-target` attribute for the pagination links. Defaults to `nil`.\n* `opts` (`:list`) - Options to customize the pagination. See\n  `t:AshPagify.Components.pagination_option/0`. Note that the options passed to the\n  function are deep merged into the default options. Since these options will\n  likely be the same for all the tables in a project, it is recommended to\n  define them once in a function or set them in a wrapper function as\n  described in the `Customization` section of the module documentation.\n\n  Defaults to `[]`.","ref":"AshPagify.Components.html#pagination/1-attributes"},{"type":"function","title":"AshPagify.Components.table/1","doc":"Generates a table with sortable columns.","ref":"AshPagify.Components.html#table/1"},{"type":"function","title":"Example - AshPagify.Components.table/1","doc":"```elixir\n \n  <:col :let={post} label=\"Name\" field={:name}><%= post.name %></:col>\n  <:col :let={post} label=\"Author\" field={:author}><%= post.author %></:col>\n \n```","ref":"AshPagify.Components.html#table/1-example"},{"type":"function","title":"Attributes - AshPagify.Components.table/1","doc":"* `id` (`:string`) - ID used on the table. If not set, an ID is chosen based on the resource\n  module derived from the `AshPagify.Meta` struct.\n\n  The ID is necessary in case the table is fed with a LiveView stream.\n\n* `items` (`:list`) (required) - The list of items to be displayed in rows. This is the result list returned\n  by the query.\n\n* `meta` (`AshPagify.Meta`) - The `AshPagify.Meta` struct returned by the query function. If omitted\n      the table will be rendered without order_by links.\n\n  Defaults to `nil`.\n* `path` (`:any`) - If set, the current view is patched with updated query parameters when a\n  header link for sorting is clicked. In case the `on_sort` attribute is\n  set as well, the URL is patched _and_ the given JS command is executed.\n\n  The value must be either a URI string (Phoenix verified route), an MFA or FA\n  tuple (Phoenix route helper), or a 1-ary path builder function. See\n  `AshPagify.Components.build_path/3` for details.\n\n  Defaults to `nil`.\n* `on_sort` (`Phoenix.LiveView.JS`) - A `Phoenix.LiveView.JS` command that is triggered when a header link for\n  sorting is clicked.\n\n  If used without the `path` attribute, you should include a `push` operation\n  to handle the event with the `handle_event` callback.\n\n      <.table\n        items={@items}\n        meta={@meta}\n        on_sort={\n          JS.dispatch(\"my_app:scroll_to\", to: \"#post-table\") |> JS.push(\"sort\")\n        }\n      />\n\n  If used with the `path` attribute, the URL is patched _and_ the given\n  JS command is executed.\n\n      <.table\n        meta={@meta}\n        path={~\"/posts\"}\n        on_sort={JS.dispatch(\"my_app:scroll_to\", to: \"#post-table\")}\n      />\n\n  Defaults to `nil`.\n* `target` (`:string`) - Sets the `phx-target` attribute for the header links. Defaults to `nil`.\n* `caption_text` (`:string`) - Content for the ` ` element. Defaults to `nil`.\n* `opts` (`:list`) - Keyword list with additional options (see `t:AshPagify.Components.table_option/0`).\n  Note that the options passed to the function are deep merged into the\n  default options. Since these options will likely be the same for all\n  the tables in a project, it is recommended to define them once in a\n  function or set them in a wrapper function as described in the `Customization`\n  section of the module documentation.\n\n  Defaults to `[]`.\n* `row_id` (`:any`) - Overrides the default function that retrieves the row ID from a stream item. Defaults to `nil`.\n* `row_click` (`Phoenix.LiveView.JS`) - Sets the `phx-click` function attribute for each row `td`. Expects to be a\n  function that receives a row item as an argument. This does not add the\n  `phx-click` attribute to the `action` slot.\n\n  Example:\n\n  ```elixir\n  row_click={&JS.navigate(~p\"/users/#{&1}\")}\n  ```\n\n  Defaults to `nil`.\n* `row_item` (`:any`) - This function is called on the row item before it is passed to the :col\n  and :action slots.\n\n  Defaults to `&Function.identity/1`.","ref":"AshPagify.Components.html#table/1-attributes"},{"type":"function","title":"Slots - AshPagify.Components.table/1","doc":"* `caption` - The slot for the table caption. If set, the content of the slot is rendered\n  as the content of the ` ` element.\n\n  ```elixir\n  <:caption>\n     Posts \n  </:caption>\n  ```\n\n* `col` (required) - For each column to render, add one `<:col>` element.\n\n  ```elixir\n  <:col :let={post} label=\"Name\" field={:name} col_style=\"width: 20%;\">\n    <%= post.name %>\n  </:col>\n  ```\n\n  Any additional assigns will be added as attributes to the ` ` elements.\n\n  Accepts attributes:\n\n  * `label` (`:any`) - The content for the header column.\n  * `field` (`:atom`) - The field name for sorting. If set and the field is configured as sortable\n    in the resource, the column header will be clickable, allowing the user to\n    sort by that column. If the field is not marked as sortable or if the\n    `field` attribute is omitted or set to `nil` or `false`, the column header\n    will not be clickable.\n\n  * `directions` (`:any`) - An optional 2-element tuple used for custom ascending and descending sort\n    behavior for the column, i.e. `{:asc_nils_last, :desc_nils_first}`\n\n  * `col_style` (`:string`) - If set, a ` ` element is rendered and the value of the\n    `col_style` assign is set as `style` attribute for the ` ` element of\n    the respective column. You can set the `width`, `background`, `border`,\n    and `visibility` of a column this way.\n\n  * `col_class` (`:string`) - If set, a ` ` element is rendered and the value of the\n    `col_class` assign is set as `class` attribute for the ` ` element of\n    the respective column. You can set the `width`, `background`, `border`,\n    and `visibility` of a column this way.\n\n  * `class` (`:string`) - Additional classes to add to the ` ` and ` ` element. Will be merged with the\n    `thead_attr_attrs` and `tbody_td_attrs` attributes.\n\n  * `thead_th_attrs` (`:list`) - Additional attributes to pass to the ` ` element as a static keyword\n    list. Note that these attributes will override any conflicting\n    `thead_th_attrs` that are set at the table level.\n\n  * `th_wrapper_attrs` (`:list`) - Additional attributes for the ` ` element that wraps the\n    header link and the order direction symbol. Note that these attributes\n    will override any conflicting `th_wrapper_attrs` that are set at the table\n    level.\n\n  * `tbody_td_attrs` (`:any`) - Additional attributes to pass to the ` ` element. May be provided as a\n    static keyword list, or as a 1-arity function to dynamically generate the\n    list using row data. Note that these attributes will override any\n    conflicting `tbody_td_attrs` that are set at the table level.\n\n* `action` - The slot for showing user actions in the last table column. These columns\n  do not receive the `row_click` attribute.\n\n\n  ```elixir\n  <:action :let={user}>\n    <.link navigate={~p\"/users/#{user}\"}>Show</.link>\n  </:action>\n  ```\n\n  Accepts attributes:\n\n  * `label` (`:string`) - The content for the header column.\n  * `show` (`:boolean`) - Boolean value to conditionally show the column. Defaults to `true`.\n  * `hide` (`:boolean`) - Boolean value to conditionally hide the column. Defaults to `false`.\n  * `col_style` (`:string`) - If set, a ` ` element is rendered and the value of the\n    `col_style` assign is set as `style` attribute for the ` ` element of\n    the respective column. You can set the `width`, `background`, `border`,\n    and `visibility` of a column this way.\n\n  * `col_class` (`:string`) - If set, a ` ` element is rendered and the value of the\n    `col_class` assign is set as `class` attribute for the ` ` element of\n    the respective column. You can set the `width`, `background`, `border`,\n    and `visibility` of a column this way.\n\n  * `class` (`:string`) - Additional classes to add to the ` ` and ` ` element. Will be merged with the\n    `thead_attr_attrs` and `tbody_td_attrs` attributes.\n\n  * `thead_th_attrs` (`:list`) - Any additional attributes to pass to the ` ` as a keyword list.\n  * `tbody_td_attrs` (`:any`) - Any additional attributes to pass to the ` `. Can be a keyword list or\n    a function that takes the current row item as an argument and returns a\n    keyword list.\n\n* `foot` - You can optionally add a `foot`. The inner block will be rendered inside\n  a `tfoot` element.\n\n       \n        <:foot>\n            Total:  <%= @total %>   \n        </:foot>","ref":"AshPagify.Components.html#table/1-slots"},{"type":"function","title":"AshPagify.Components.to_query/2","doc":"Converts a AshPagify struct into a keyword list that can be used as a query with\nPhoenix verified routes or route helper functions.","ref":"AshPagify.Components.html#to_query/2"},{"type":"function","title":"Encoded parameters - AshPagify.Components.to_query/2","doc":"The following parameters are encoded as strings:\n\n- `:search`\n- `:scopes`\n- `:filter_form`\n- `:order_by`\n- `:limit`\n- `:offset`","ref":"AshPagify.Components.html#to_query/2-encoded-parameters"},{"type":"function","title":"Default parameters - AshPagify.Components.to_query/2","doc":"Default parameters for the limit, scopes, filter_form and order parameters\nare omitted. The defaults are determined by calling `AshPagify.get_option/3`.\n\n- Pass the `:for` option to pick up the default values from an `Ash.Resource`.\n- If the `Ash.Resource` has no default options set, the function will fall\n  back to the application environment.","ref":"AshPagify.Components.html#to_query/2-default-parameters"},{"type":"function","title":"Encoding queries - AshPagify.Components.to_query/2","doc":"To encode the returned query as a string, you will need to use\n`Plug.Conn.Query.encode/1`. `URI.encode_query/1` does not support bracket\nnotation for arrays and maps.","ref":"AshPagify.Components.html#to_query/2-encoding-queries"},{"type":"function","title":"Examples - AshPagify.Components.to_query/2","doc":"iex> to_query(%AshPagify{})\n    []\n\n    iex> f = %AshPagify{offset: 40, limit: 20}\n    iex> to_query(f)\n    [limit: 20, offset: 40]\n\n    iex> f = %AshPagify{offset: 40, limit: 20}\n    iex> to_query(f, default_limit: 20)\n    [offset: 40]\n\n    iex> f = %AshPagify{order_by: [name: :asc]}\n    iex> to_query(f, for: AshPagify.Factory.Post)\n    []\n\n    iex> f = %AshPagify{scopes: %{status: :active}}\n    iex> to_query(f, for: AshPagify.Factory.Post)\n    [scopes: %{status: :active}]\n\n    iex> f = %AshPagify{search: \"foo\"}\n    iex> to_query(f, for: AshPagify.Factory.Post)\n    [search: \"foo\"]\n\nEncoding the query as a string:\n\n    iex> f = %AshPagify{order_by: [name: :desc, age: :asc]}\n    iex> to_query(f)\n    [order_by: [\"-name\", \"age\"]]\n    iex> f |> to_query |> Plug.Conn.Query.encode()\n    \"order_by[]=-name&order_by[]=age\"\n\n    iex> f = %AshPagify{filter_form: %{\"field\" => \"comments_count\", \"operator\" => \"gt\", \"value\" => 2}}\n    iex> to_query(f)\n    [filter_form: %{\"field\" => \"comments_count\", \"operator\" => \"gt\", \"value\" => 2}]\n    iex> f |> to_query |> Plug.Conn.Query.encode()\n    \"filter_form[field]=comments_count&filter_form[operator]=gt&filter_form[value]=2\"\n\n    iex> f = %AshPagify{scopes: %{status: :active}}\n    iex> to_query(f)\n    [scopes: %{status: :active}]\n    iex> f |> to_query |> Plug.Conn.Query.encode()\n    \"scopes[status]=active\"\n\n    iex> f = %AshPagify{search: \"foo\"}\n    iex> to_query(f)\n    [search: \"foo\"]\n    iex> f |> to_query |> Plug.Conn.Query.encode()\n    \"search=foo\"","ref":"AshPagify.Components.html#to_query/2-examples"},{"type":"type","title":"AshPagify.Components.pagination_option/0","doc":"Defines the available options for `AshPagify.Components.pagination/1`.\n\n- `:current_link_attrs` - The attributes for the link to the current page.\n  Default: `[class: \"pagination-link is-current\", aria: [current: \"page\"]]`.\n- `:disabled_class` - The class which is added to disabled links. Default:\n  `\"disabled\"`.\n- `:ellipsis_attrs` - The attributes for the ` ` that wraps the\n  ellipsis.\n  Default: `[class: \"pagination-ellipsis\"]`.\n- `:ellipsis_content` - The content for the ellipsis element.\n  Default: `{:safe, \"&hellip;\"}`.\n- `:next_link_attrs` - The attributes for the link to the next page.\n  Default: `[aria: [label: \"Go to next page\"], class: \"pagination-next\"]`.\n- `:next_link_content` - The content for the link to the next page.\n  Default: `\"Next\"`.\n- `:page_links` - Specifies how many page links should be rendered.\n  Default: `:all`.\n  - `:all` - Renders all page links.\n  - `{:ellipsis, n}` - Renders `n` page links. Renders ellipsis elements if\n    there are more pages than displayed.\n  - `:hide` - Does not render any page links.\n- `:pagination_link_aria_label` - 1-arity function that takes a page number\n  and returns an aria label for the corresponding page link.\n  Default: `&\"Go to page #{&1}\"`.\n- `:pagination_link_attrs` - The attributes for the pagination links.\n  Default: `[class: \"pagination-link\"]`.\n- `:previous_link_attrs` - The attributes for the link to the previous page.\n  Default: `[aria: [label: \"Go to previous page\"], class: \"pagination-previous\"]`.\n- `:previous_link_content` - The content for the link to the previous page.\n  Default: `\"Previous\"`.\n- `:wrapper_attrs` - The attributes for the ` ` element that wraps the\n  pagination links.\n  Default: `[class: \"pagination\", role: \"navigation\", aria: [label: \"pagination\"]]`.","ref":"AshPagify.Components.html#t:pagination_option/0"},{"type":"type","title":"AshPagify.Components.pagination_path/0","doc":"Defines the available types for the `path` attribute of `AshPagify.Components.pagination/1`.","ref":"AshPagify.Components.html#t:pagination_path/0"},{"type":"type","title":"AshPagify.Components.table_option/0","doc":"Defines the available options for `AshPagify.Components.table/1`.\n\n- `:container` - Wraps the table in a ` ` if `true`.\n  Default: `false`.\n- `:container_attrs` - The attributes for the table container.\n  Default: `[class: \"table-container\"]`.\n- `:no_results_content` - Any content that should be rendered if there are no\n  results. Default: ` No results. `.\n- `:table_attrs` - The attributes for the ` ` element.\n  Default: `[]`.\n- `:th_wrapper_attrs` - The attributes for the ` ` element that wraps the\n  header link and the order direction symbol.\n  Default: `[]`.\n- `:symbol_asc` - The symbol that is used to indicate that the column is\n  sorted in ascending order.\n  Default: `\"\"`.\n- `:symbol_attrs` - The attributes for the ` ` element that wraps the\n  order direction indicator in the header columns.\n  Default: `[class: \"order-direction\"]`.\n- `:symbol_desc` - The symbol that is used to indicate that the column is\n  sorted in ascending order.\n  Default: `\"\"`.\n- `:symbol_unsorted` - The symbol that is used to indicate that the column is\n  not sorted. Default: `nil`.\n- `:tbody_attrs`: Attributes to be added to the ` ` tag within the\n  ` `. Default: `[]`.\n- `:tbody_td_attrs`: Attributes to be added to each ` ` tag within the\n  ` `. Default: `[]`.\n- `:thead_attrs`: Attributes to be added to the ` ` tag within the\n  ` `. Default: `[]`.\n- `:tbody_tr_attrs`: Attributes to be added to each ` ` tag within the\n  ` `. A function with arity of 1 may be passed to dynamically generate\n  the attrs based on row data.\n  Default: `[]`.\n- `:thead_th_attrs`: Attributes to be added to each ` ` tag within the\n  ` `. Default: `[]`.\n- `:thead_tr_attrs`: Attributes to be added to each ` ` tag within the\n  ` `. Default: `[]`.\n- `:limit_order_by` - Limit the number of applied order_by fields.\n  Default: `nil`.","ref":"AshPagify.Components.html#t:table_option/0"},{"type":"module","title":"AshPagify.Components.Pagination","doc":"Pagination component for AshPagify.","ref":"AshPagify.Components.Pagination.html"},{"type":"function","title":"AshPagify.Components.Pagination.attrs_for_page_link/3","doc":"","ref":"AshPagify.Components.Pagination.html#attrs_for_page_link/3"},{"type":"function","title":"AshPagify.Components.Pagination.build_page_link_helper/2","doc":"","ref":"AshPagify.Components.Pagination.html#build_page_link_helper/2"},{"type":"function","title":"AshPagify.Components.Pagination.default_opts/0","doc":"","ref":"AshPagify.Components.Pagination.html#default_opts/0"},{"type":"function","title":"AshPagify.Components.Pagination.get_page_link_range/3","doc":"","ref":"AshPagify.Components.Pagination.html#get_page_link_range/3"},{"type":"function","title":"AshPagify.Components.Pagination.max_pages/2","doc":"","ref":"AshPagify.Components.Pagination.html#max_pages/2"},{"type":"function","title":"AshPagify.Components.Pagination.merge_opts/1","doc":"","ref":"AshPagify.Components.Pagination.html#merge_opts/1"},{"type":"function","title":"AshPagify.Components.Pagination.show_pagination?/1","doc":"","ref":"AshPagify.Components.Pagination.html#show_pagination?/1"},{"type":"module","title":"AshPagify.Components.Table","doc":"Table component for AshPagify.","ref":"AshPagify.Components.Table.html"},{"type":"function","title":"AshPagify.Components.Table.default_opts/0","doc":"","ref":"AshPagify.Components.Table.html#default_opts/0"},{"type":"function","title":"AshPagify.Components.Table.merge_opts/1","doc":"","ref":"AshPagify.Components.Table.html#merge_opts/1"},{"type":"function","title":"AshPagify.Components.Table.render/1","doc":"","ref":"AshPagify.Components.Table.html#render/1"},{"type":"function","title":"Attributes - AshPagify.Components.Table.render/1","doc":"* `id` (`:string`) (required)\n* `meta` (`AshPagify.Meta`) (required)\n* `path` (`:any`) (required)\n* `on_sort` (`Phoenix.LiveView.JS`)\n* `target` (`:string`) (required)\n* `caption_text` (`:string`) (required)\n* `caption` (`:any`)\n* `opts` (`:any`) (required)\n* `col` (`:any`)\n* `items` (`:list`) (required)\n* `foot` (`:any`) (required)\n* `row_id` (`:any`) - Defaults to `nil`.\n* `row_click` (`Phoenix.LiveView.JS`) - Defaults to `nil`.\n* `row_item` (`:any`) (required)\n* `action` (`:any`) (required)","ref":"AshPagify.Components.Table.html#render/1-attributes"},{"type":"module","title":"AshPagify.FilterForm","doc":"A module to help you create complex forms that generate Ash filters.\n\n> #### Disclaimer {: .info}\n>\n> This is a copy of the `AshPhoenix.FilterForm` module from the `ash_phoenix` package.\n> We made some changes such as `nillify_blanks?` option in `params_for_query/2` function.\n> Further we fixed the issue with the duplicated [components][index] suffix in case\n> you restore the form from the params. Additonal you can now provide an `initial_form`\n> to `AshPagify.FilterForm.new/2` to enforce a specific structure for the form and then merge\n> in the params.\n\n```elixir\n# Create a FilterForm\nfilter_form = AshPagify.FilterForm.new(MyApp.Payroll.Employee)\n```\n\nFilterForm's comprise two concepts, predicates and groups. Predicates are the simple boolean\nexpressions you can use to build a query (`name == \"Joe\"`), and groups can be used to group\npredicates and more groups together. Groups can apply `and` or `or` operators to its nested\ncomponents.\n\n```elixir\n# Add a predicate to the root of the form (which is itself a group)\nfilter_form = AshPagify.FilterForm.add_predicate(filter_form, :some_field, :eq, \"Some Value\")\n\n# Add a group and another predicate to that group\n{filter_form, group_id} = AshPagify.FilterForm.add_group(filter_form, operator: :or, return_id?: true)\nfilter_form = AshPagify.FilterForm.add_predicate(filter_form, :another, :eq, \"Other\", to: group_id)\n```\n\n`validate/1` is used to merge the submitted form params into the filter form, and one of the\nprovided filter functions to apply the filter as a query, or generate an expression map,\ndepending on your requirements:\n\n```elixir\nfilter_form = AshPagify.FilterForm.validate(socket.assigns.filter_form, params)\n\n# Generate a query and pass it to the Domain\nquery = AshPagify.FilterForm.filter!(MyApp.Payroll.Employee, filter_form)\nfiltered_employees = MyApp.Payroll.read!(query)\n\n# Or use one of the other filter functions\nAshPagify.FilterForm.to_filter_expression(filter_form)\nAshPagify.FilterForm.to_filter_map(filter_form)\n```","ref":"AshPagify.FilterForm.html"},{"type":"module","title":"LiveView Example - AshPagify.FilterForm","doc":"You can build a form and handle adding and removing nested groups and predicates with the following:\n\n```elixir\nalias MyApp.Payroll.Employee\n\n@impl true\ndef render(assigns) do\n  ~H\"\"\"\n  <.simple_form\n    :let={filter_form}\n    for={@filter_form}\n    phx-change=\"filter_validate\"\n    phx-submit=\"filter_submit\"\n  >\n    <.filter_form_component component={filter_form} />\n    <:actions>\n      <.button>Submit</.button>\n    </:actions>\n  </.simple_form>\n  <.table id=\"employees\" rows={@employees}>\n    <:col :let={employee} label=\"Payroll ID\"><%= employee.employee_id %></:col>\n    <:col :let={employee} label=\"Name\"><%= employee.name %></:col>\n    <:col :let={employee} label=\"Position\"><%= employee.position %></:col>\n  </.table>\n  \"\"\"\nend\n\nattr :component, :map, required: true, doc: \"Could be a FilterForm (group) or a Predicate\"\n\ndefp filter_form_component(%{component: %{source: %AshPagify.FilterForm{}}} = assigns) do\n  ~H\"\"\"\n   \n     \n       Filter \n       \n        <.input type=\"select\" field={@component[:operator]} options={[\"and\", \"or\"]} />\n        <.button phx-click=\"add_filter_group\" phx-value-component-id={@component.source.id} type=\"button\">\n          Add Group\n        </.button>\n        <.button\n          phx-click=\"add_filter_predicate\"\n          phx-value-component-id={@component.source.id}\n          type=\"button\"\n        >\n          Add Predicate\n        </.button>\n        <.button\n          phx-click=\"remove_filter_component\"\n          phx-value-component-id={@component.source.id}\n          type=\"button\"\n        >\n          Remove Group\n        </.button>\n       \n     \n    <.inputs_for :let={component} field={@component[:components]}>\n      <.filter_form_component component={component} />\n    </.inputs_for>\n   \n  \"\"\"\nend\n\ndefp filter_form_component(\n       %{component: %{source: %AshPhoenix.FilterForm.Predicate{}}} = assigns\n     ) do\n  ~H\"\"\"\n   \n    <.input\n      type=\"select\"\n      options={AshPagify.FilterForm.fields(Employee)}\n      field={@component[:field]}\n    />\n    <.input\n      type=\"select\"\n      options={AshPagify.FilterForm.predicates(Employee)}\n      field={@component[:operator]}\n    />\n    <.input field={@component[:value]} />\n    <.button\n      phx-click=\"remove_filter_component\"\n      phx-value-component-id={@component.source.id}\n      type=\"button\"\n    >\n      Remove\n    </.button>\n   \n  \"\"\"\nend\n\n@impl true\ndef mount(_params, _session, socket) do\n  socket =\n    socket\n    |> assign(:filter_form, AshPagify.FilterForm.new(Employee))\n    |> assign(:employees, Employee.read_all!())\n\n  {:ok, socket}\nend\n\n@impl true\ndef handle_event(\"filter_validate\", %{\"filter\" => params}, socket) do\n  {:noreply,\n   assign(socket,\n     filter_form: AshPagify.FilterForm.validate(socket.assigns.filter_form, params)\n   )}\nend\n\n@impl true\ndef handle_event(\"filter_submit\", %{\"filter\" => params}, socket) do\n  filter_form = AshPagify.FilterForm.validate(socket.assigns.filter_form, params)\n\n  case AshPagify.FilterForm.filter(Employee, filter_form) do\n    {:ok, query} ->\n      {:noreply,\n       socket\n       |> assign(:employees, Employee.read_all!(query: query))\n       |> assign(:filter_form, filter_form)}\n\n    {:error, filter_form} ->\n      {:noreply, assign(socket, filter_form: filter_form)}\n  end\nend\n\n@impl true\ndef handle_event(\"remove_filter_component\", %{\"component-id\" => component_id}, socket) do\n  {:noreply,\n   assign(socket,\n     filter_form:\n       AshPagify.FilterForm.remove_component(socket.assigns.filter_form, component_id)\n   )}\nend\n\n@impl true\ndef handle_event(\"add_filter_group\", %{\"component-id\" => component_id}, socket) do\n  {:noreply,\n   assign(socket,\n     filter_form: AshPagify.FilterForm.add_group(socket.assigns.filter_form, to: component_id)\n   )}\nend\n\n@impl true\ndef handle_event(\"add_filter_predicate\", %{\"component-id\" => component_id}, socket) do\n  {:noreply,\n   assign(socket,\n     filter_form:\n       AshPagify.FilterForm.add_predicate(socket.assigns.filter_form, :name, :contains, nil,\n         to: component_id\n       )\n   )}\nend\n```","ref":"AshPagify.FilterForm.html#module-liveview-example"},{"type":"function","title":"AshPagify.FilterForm.active_filter_form_fields/1","doc":"Helper function to extract all active filter form fields from a AshPagify.Meta struct.","ref":"AshPagify.FilterForm.html#active_filter_form_fields/1"},{"type":"function","title":"AshPagify.FilterForm.add_group/2","doc":"Add a group to the filter. A group can contain predicates and other groups,\nallowing you to build quite complex nested filters.\n\nOptions:\n\n* `:to` (`t:String.t/0`) - The nested group id to add the group to.\n\n* `:operator` - The operator that the group should have internally. Valid values are :and, :or The default value is `:and`.\n\n* `:key` (`t:term/0`) - The key to use for the group. The default value is `nil`.\n\n* `:return_id?` (`t:boolean/0`) - If set to `true`, the function returns `{form, predicate_id}` The default value is `false`.","ref":"AshPagify.FilterForm.html#add_group/2"},{"type":"function","title":"AshPagify.FilterForm.add_predicate/5","doc":"Add a predicate to the filter.\n\nOptions:\n\n* `:to` (`t:String.t/0`) - The group id to add the predicate to. If not set, will be added to the top level group.\n\n* `:return_id?` (`t:boolean/0`) - If set to `true`, the function returns `{form, predicate_id}` The default value is `false`.\n\n* `:path` - The relationship path to apply the predicate to","ref":"AshPagify.FilterForm.html#add_predicate/5"},{"type":"function","title":"AshPagify.FilterForm.count/4","doc":"Count the number of records that match the filter form parameters.\n\nIf you pass a query, it will be used to count the records. Otherwise, the resource\nfrom the meta struct will be used.\n\nIf you pass `reset: true`, the filter form will be reset to an empty map.","ref":"AshPagify.FilterForm.html#count/4"},{"type":"function","title":"AshPagify.FilterForm.errors/2","doc":"Returns a flat list of all errors on all predicates in the filter.","ref":"AshPagify.FilterForm.html#errors/2"},{"type":"function","title":"AshPagify.FilterForm.extract_filter_form_fields/1","doc":"Helper function to extract all filter form fields from a AshPhoenix.FilterForm parameter.","ref":"AshPagify.FilterForm.html#extract_filter_form_fields/1"},{"type":"function","title":"AshPagify.FilterForm.fields/1","doc":"Returns the list of available fields, which may be attributes, calculations, or aggregates.","ref":"AshPagify.FilterForm.html#fields/1"},{"type":"function","title":"AshPagify.FilterForm.filter/2","doc":"Converts the form into a filter, and filters the provided query or resource with that filter.","ref":"AshPagify.FilterForm.html#filter/2"},{"type":"function","title":"AshPagify.FilterForm.filter!/2","doc":"Same as `filter/2` but raises on errors.","ref":"AshPagify.FilterForm.html#filter!/2"},{"type":"function","title":"AshPagify.FilterForm.new/2","doc":"Create a new filter form.\n\nOptions:\n* `:params` (`t:term/0`) - Initial parameters to create the form with The default value is `%{}`.\n\n* `:as` (`t:String.t/0`) - Set the parameter name for the form. The default value is `\"filter\"`.\n\n* `:key` (`t:term/0`) - Set the parameter key for the form. The default value is `nil`.\n\n* `:transform_errors` (`t:term/0`) - Allows for manual manipulation and transformation of errors.  \n  If possible, try to implement `AshPhoenix.FormData.Error` for the error (if it as a custom one, for example).\n  If that isn't possible, you can provide this function which will get the predicate and the error, and should\n  return a list of ash phoenix formatted errors, e.g `[{field :: atom, message :: String.t(), substituations :: Keyword.t()}]`\n\n* `:remove_empty_groups?` (`t:boolean/0`) - If true (the default), then any time a group would be made empty by removing a group or predicate, it is removed instead.  \n  An empty form can still be added, this only affects a group if its last component is removed. The default value is `false`.\n\n* `:root?` (`t:boolean/0`) - If true (the default), the form's name will not be suffixed with [components][index] when adding / validating components.  \n  This flag is used internally and should not be set manually. The default value is `true`.\n\n* `:initial_form` (`t:term/0`) - The initial form to use when creating a new form.  \n  This is usefully if you want to enforce a specific structure for the form and then merge in the params.\n\n* `:serializer` (`t:term/0`) - A function that will be called on the predicate param during new predicate initialization.  \n  This is useful for custom serialization of the form input values. The default value is `nil`.","ref":"AshPagify.FilterForm.html#new/2"},{"type":"function","title":"AshPagify.FilterForm.params_for_query/2","doc":"Returns the minimal set of params (at the moment just strips ids) for use in a query string.\n\nIf nillify_blanks? is true (default to true), then any blank values will be set to nil and\nnot included in the params. Furthermore, if a nested group results to an empty group (after\nnillification of it's components), it will be removed as well.","ref":"AshPagify.FilterForm.html#params_for_query/2"},{"type":"function","title":"AshPagify.FilterForm.predicates/1","doc":"Returns the list of available predicates for the given resource, which may be functions or operators.","ref":"AshPagify.FilterForm.html#predicates/1"},{"type":"function","title":"AshPagify.FilterForm.remove_component/2","doc":"Removes the group *or* predicate with the given id","ref":"AshPagify.FilterForm.html#remove_component/2"},{"type":"function","title":"AshPagify.FilterForm.remove_group/2","doc":"Remove the group with the given id","ref":"AshPagify.FilterForm.html#remove_group/2"},{"type":"function","title":"AshPagify.FilterForm.remove_predicate/2","doc":"Remove the predicate with the given id","ref":"AshPagify.FilterForm.html#remove_predicate/2"},{"type":"function","title":"AshPagify.FilterForm.to_filter!/1","doc":"","ref":"AshPagify.FilterForm.html#to_filter!/1"},{"type":"function","title":"AshPagify.FilterForm.to_filter_expression/1","doc":"Returns a filter expression that can be provided to Ash.Query.filter/2\n\nTo add this to a query, remember to use `^`, for example:\n```elixir\nfilter = AshPagify.FilterForm.to_filter_expression(form)\n\nAsh.Query.filter(MyApp.Post, ^filter)\n```\n\nAlternatively, you can use the shorthand: `filter/2` to apply the expression directly to a query.","ref":"AshPagify.FilterForm.html#to_filter_expression/1"},{"type":"function","title":"AshPagify.FilterForm.to_filter_expression!/1","doc":"Same as `to_filter_expression/1` but raises on errors.","ref":"AshPagify.FilterForm.html#to_filter_expression!/1"},{"type":"function","title":"AshPagify.FilterForm.to_filter_map/1","doc":"Returns a filter map that can be provided to `Ash.Filter.parse`\n\nThis allows for things like saving a stored filter. Does not currently support parameterizing calculations or functions.","ref":"AshPagify.FilterForm.html#to_filter_map/1"},{"type":"function","title":"AshPagify.FilterForm.update_group/4","doc":"Update the predicates of the nested_form with the given key.\n\nWorks also for predicates in nested forms inside the nested form.","ref":"AshPagify.FilterForm.html#update_group/4"},{"type":"function","title":"AshPagify.FilterForm.update_predicate/3","doc":"Update the predicate with the given id","ref":"AshPagify.FilterForm.html#update_predicate/3"},{"type":"function","title":"AshPagify.FilterForm.validate/3","doc":"Updates the filter with the provided input and validates it.\n\nAt present, no validation actually occurs, but this will eventually be added.\n\nPassing `reset_on_change?: false` into `opts` will prevent predicates to reset\nthe `value` and `operator` fields to `nil` if the predicate `field` changes.","ref":"AshPagify.FilterForm.html#validate/3"},{"type":"type","title":"AshPagify.FilterForm.t/0","doc":"","ref":"AshPagify.FilterForm.html#t:t/0"},{"type":"exception","title":"AshPagify.Error.Components.PathOrJSError","doc":"Raised when a neither the `path` nor the `on_*` attribute is set for a\npagination or table component.","ref":"AshPagify.Error.Components.PathOrJSError.html"},{"type":"function","title":"AshPagify.Error.Components.PathOrJSError.exception/0","doc":"","ref":"AshPagify.Error.Components.PathOrJSError.html#exception/0"},{"type":"exception","title":"AshPagify.Error.Query.InvalidDirectionsError","doc":"An error that is raised when invalid directions are passed.","ref":"AshPagify.Error.Query.InvalidDirectionsError.html"},{"type":"function","title":"AshPagify.Error.Query.InvalidDirectionsError.exception/0","doc":"","ref":"AshPagify.Error.Query.InvalidDirectionsError.html#exception/0"},{"type":"exception","title":"AshPagify.Error.Query.InvalidFilterFormParameter","doc":"Used when an invalid filter_form is provided","ref":"AshPagify.Error.Query.InvalidFilterFormParameter.html"},{"type":"function","title":"AshPagify.Error.Query.InvalidFilterFormParameter.exception/0","doc":"","ref":"AshPagify.Error.Query.InvalidFilterFormParameter.html#exception/0"},{"type":"exception","title":"AshPagify.Error.Query.InvalidOrderByParameter","doc":"Used when an invalid order_by is provided","ref":"AshPagify.Error.Query.InvalidOrderByParameter.html"},{"type":"function","title":"AshPagify.Error.Query.InvalidOrderByParameter.exception/0","doc":"","ref":"AshPagify.Error.Query.InvalidOrderByParameter.html#exception/0"},{"type":"exception","title":"AshPagify.Error.Query.InvalidParamsError","doc":"Raised when parameter validation fails.\n\nThis can occur under a number of circumstances, such as:\n\n- Pagination parameters are improperly formatted or invalid.\n- Filter values are incompatible with the respective field's type or specified\n  operator.\n- Ordering parameters are not provided in the correct format.","ref":"AshPagify.Error.Query.InvalidParamsError.html"},{"type":"function","title":"AshPagify.Error.Query.InvalidParamsError.exception/0","doc":"","ref":"AshPagify.Error.Query.InvalidParamsError.html#exception/0"},{"type":"type","title":"AshPagify.Error.Query.InvalidParamsError.t/0","doc":"","ref":"AshPagify.Error.Query.InvalidParamsError.html#t:t/0"},{"type":"exception","title":"AshPagify.Error.Query.InvalidScopesParameter","doc":"Used when an invalid scopes is provided","ref":"AshPagify.Error.Query.InvalidScopesParameter.html"},{"type":"function","title":"AshPagify.Error.Query.InvalidScopesParameter.exception/0","doc":"","ref":"AshPagify.Error.Query.InvalidScopesParameter.html#exception/0"},{"type":"exception","title":"AshPagify.Error.Query.InvalidSearchParameter","doc":"Used when an invalid search is provided","ref":"AshPagify.Error.Query.InvalidSearchParameter.html"},{"type":"function","title":"AshPagify.Error.Query.InvalidSearchParameter.exception/0","doc":"","ref":"AshPagify.Error.Query.InvalidSearchParameter.html#exception/0"},{"type":"exception","title":"AshPagify.Error.Query.NoSuchScope","doc":"Used when an invalid scopes is provided","ref":"AshPagify.Error.Query.NoSuchScope.html"},{"type":"function","title":"AshPagify.Error.Query.NoSuchScope.exception/0","doc":"","ref":"AshPagify.Error.Query.NoSuchScope.html#exception/0"},{"type":"exception","title":"AshPagify.Error.Query.SearchNotImplemented","doc":"Used when a search is requested but not implemented","ref":"AshPagify.Error.Query.SearchNotImplemented.html"},{"type":"function","title":"AshPagify.Error.Query.SearchNotImplemented.exception/0","doc":"","ref":"AshPagify.Error.Query.SearchNotImplemented.html#exception/0"},{"type":"extras","title":"Home","doc":"![Elixir CI](https://github.com/zebbra/ash_pagify/workflows/AshPagify%20CI/badge.svg)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Hex version badge](https://img.shields.io/hexpm/v/ash_pagify.svg)](https://hex.pm/packages/ash_pagify)\n[![Hexdocs badge](https://img.shields.io/badge/docs-hexdocs-purple)](https://hexdocs.pm/ash_pagify)\n\n# AshPagify\n\n<!-- MDOC -->\n\nAshPagify is an Elixir library designed to easily add full-text search, scoping, filtering,\nordering, and pagination APIs for the [Ash Framework](https://hexdocs.pm/ash).\n\nIt takes concepts from `Flop`, `Flop.Phoenix`, `Ash` and `AshPhoenix.FilterForm` and\ncombines them into a single library.\n\nIt's main purpose is to provide functions to convert user input for full-text search, scoping,\nfiltering, ordering, and pagination into the following data structures:\n\n1. `AshPagify.Meta` a struct holding information of a db query result.\n2. query parameters for url building and to restore the query parameters from the url.\n3. a basic map syntax which for example can be stored in a session or database (and restore\n  the information from it).\n\nFurther, it provides headless components to build sortable tables and pagination links in your\nPhoenix LiveView with the `AshPagify.Components` module. Finally, it provides a simple way to build\nfilter forms for your LiveView with the `AshPagify.FilterForm` struct.","ref":"readme.html"},{"type":"extras","title":"Examples - Home","doc":"```elixir\nash_pagify = %AshPagify{\n  search: \"Post 1\",\n  scopes: %{role: :admin},\n  filters: %{\"comments_count\" => %{\"gt\" => 2}},\n  filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"},\n  order_by: :name,\n  limit: 10,\n  offset: 0\n}\nopts = [full_text_search: [tsvector: :custom_tsvector]]\n\nAshPagify.query_to_filters_map(Post, ash_pagify, opts).filters\n%{\n  \"__full_text_search\" => %{\n    \"search\" => \"Post 1\",\n    \"tsvector\" => \"custom_tsvector\"\n  },\n  \"and\" => [\n    %{\"comments_count\" => %{\"gt\" => 2}},\n    %{\"name\" => %{\"eq\" => \"Post 1\"}},\n    %{\"author\" => \"John\"}\n  ]\n}\n\nAshPagify.Components.build_path(\"/posts\", ash_pagify, opts)\n\"/posts?search=Post+1&limit=10&scopes[role]=admin&filter_form[field]=name&filter_form[operator]=eq&filter_form[value]=Post+1&order_by[]=name\"\n```","ref":"readme.html#examples"},{"type":"extras","title":"Features - Home","doc":"- **Full-text search**: AshPagify supports full-text search using the `tsvector` column in PostgreSQL.\n- **Offset-based pagination**: AshPagify uses `OFFSET` and `LIMIT` to paginate your queries.\n- **Scoping**: Apply predefined filters to your queries using a simple map syntax.\n- **Filtering**: Apply user-input filters to your queries using a simple map syntax. Allows complex data filtering using multiple conditions, operators, and fields. Also incooperates with `AshPhoenix.FilterForm` to provide a simple way to build complex filter user interfaces.\n- **Sorting**: Sort your queries by multiple fields and any directions.\n- **UI helpers and URL builders**: AshPagify provides a `AshPagify.Meta` struct with information about the current page, total pages, and more. This information can be used to build pagination links in your UI. Further, `AshPagify` provides the `AshPagify.Components` module with headless table and pagination components to easily build sortable tables and pagination links in your Phoenix LiveView. The `AshPagify.FilterForm` module provides a simple way to build filter forms for your LiveView.","ref":"readme.html#features"},{"type":"extras","title":"Overview - Home","doc":"- [Examples](#examples)\n- [Features](#features)\n- [Installation](#installation)\n- [Global configuration](#global-configuration)\n- [Resource configuration](#resource-configuration)\n- [LiveView configuration](#liveview-configuration)\n  - [LiveView streams](#liveview-streams)\n  - [Replace invalid params](#replace-invalid-params)\n  - [Custom read action](#custom-read-action)\n- [Full-text search](#full-text-search)\n- [Sortable tables and pagination](#sortable-tables-and-pagination)\n- [Parameter format](#parameter-format)\n  - [Search query](#search-query)\n  - [Pagination](#pagination)\n  - [Scoping](#scoping)\n  - [Filter forms](#filter-forms)\n  - [Ordering](#ordering)\n  - [Internal parameters](#internal-parameters)\n- [Release Management](#release-management)","ref":"readme.html#overview"},{"type":"extras","title":"Installation - Home","doc":"AshPagify requires the following dependencies to be installed:\n\n- `Ash` - The main library for building queries.\n- `ash_phoenix` - The Phoenix integration for Ash.\n- `AshPostgres` - The PostgreSQL integration for Ash.\n- `AshUUID` - The UUID integration for Ash.\n- `Phoenix` - The Phoenix web framework.\n\nThen simply add `ash_pagify` to your list of dependencies in `mix.exs` and run\n`mix deps.get`:\n\n```elixir\ndef deps do\n  [\n    {:ash_pagify, \"~> 1.0.2\"}\n  ]\nend\n```","ref":"readme.html#installation"},{"type":"extras","title":"Global configuration - Home","doc":"You can set some global options like the default_limit via the application\nenvironment. All global options can be overridden by passing them directly to\nthe functions.\n\n```elixir\nconfig :ash_pagify,\n  default_limit: 50,\n  max_limit: 1000,\n  replace_invalid_params?: true,\n  ash_pagify_scopes: %{\n    role: [\n      %{name: :all, filter: nil},\n      %{name: :admin, filter: %{role: \"admin\"}},\n      %{name: :user, filter: %{role: \"user\"}}\n    ]\n  },\n  reset_on_filter?: true,\n  full_text_search: [\n    negation: true,\n    prefix: true,\n    any_word: false\n  ]\n```\n\nSee `t:AshPagify.option/0` for a description of all available options.","ref":"readme.html#global-configuration"},{"type":"extras","title":"Resource configuration - Home","doc":"You need to add the `pagination macro` call to the action of the resource that you\nwant to be paginated. The macro call is used to set the default limit, offset and\nother options for the pagination.\n\nFurthermore, you can define scopes in the resource module. Scopes are predefined\nfilters that can be applied to the query.\n\nWe allow full-text search using the `tsvector` column in PostgreSQL. To enable full-text search,\nyou need to either `use AshPagify.Tsearch` in your module or implement the `full_text_search`,\n`full_text_search_rank`, `tsquery`, and `tsvector` calculations as described in `AshPagify.Tsearch`\n(tsvector calculation  is always mandatory).\n\n```elixir\ndefmodule YourApp.Resource.Post\n  # only required if you want to implement full-text search\n  use AshPagify.Tsearch\n  require Ash.Expr\n\n  @default_limit 15\n  def default_limit, do: @default_limit\n\n  @ash_pagify_scopes %{\n    role: [\n      %{name: :all, filter: nil},\n      %{name: :admin, filter: %{author: \"John\"}},\n      %{name: :user, filter: %{author: \"Doe\"}}\n    ]\n  }\n  def ash_pagify_scopes, do: @ash_pagify_scopes\n\n  actions do\n    read :read do\n      #...\n      pagination offset?: true,\n                default_limit: @default_limit,\n                countable: true,\n                required?: false\n    end\n  end\n\n  calculations do\n    # provide your default `tsvector` calculation for full-text search\n    calculate :tsvector,\n              AshPostgres.Tsvector,\n              expr(\n                fragment(\n                  \"to_tsvector('simple', coalesce(?, '')) || to_tsvector('simple', coalesce(?, ''))\",\n                  name,\n                  title\n                )\n              ),\n              public?: true\n  end\n  #...\nend\n```","ref":"readme.html#resource-configuration"},{"type":"extras","title":"LiveView configuration - Home","doc":"In your LiveView, fetch the data and assign it alongside the meta data to the socket.\n\n```elixir\ndefmodule YourAppWeb.PostLive.IndexLive do\n  use YourAppWeb, :live_view\n\n  alias YourApp.Resource.Post\n\n  @impl true\n  def handle_params(params, _, socket) do\n    case Post.list_posts(params) do\n      {:ok, {posts, meta}} ->\n        {:noreply, assign(socket, %{posts: posts, meta: meta})}\n      {:error, _meta} ->\n        # This will reset invalid parameters. Alternatively, you can assign\n        # only the meta and render the errors, or assign the validated params,\n        # or you can ignore the error case entirely.\n        {:noreply, push_navigate(socket, to: ~p\"/posts\")}\n    end\n  end\n\n  defp list_posts(params, opts \\\\ []) do\n    AshPagify.validate_and_run(Post, params, opts)\n  end\nend\n```","ref":"readme.html#liveview-configuration"},{"type":"extras","title":"LiveView streams - Home","doc":"To use LiveView streams, you can change your `handle_params/3` function as follows:\n\n```elixir\ndef handle_params(params, _, socket) do\n  case Post.list_posts(params) do\n    {:noreply,\n        socket\n        |> assign(:meta, meta)\n        |> stream(:posts, posts, reset: true)}\n  # ...\n  end\nend\n```","ref":"readme.html#liveview-streams"},{"type":"extras","title":"Replace invalid params - Home","doc":"To replace invalid ash_pagify parameters with their default values, you can use the `replace_invalid_params?` option. You can change your `handle_params/3` function as follows:\n\n```elixir\ndef handle_params(params, _, socket) do\n  case Post.list_posts(params, replace_invalid_params?: true) do\n      {:ok, {posts, meta}} ->\n        {:noreply, assign(socket, %{posts: posts, meta: meta})}\n      {:error, meta} ->\n        valid_path = AshPagify.Components.build_path(~p\"/posts\", meta.params)\n        {:noreply, push_navigate(socket, to: valid_path)}\n  # ...\n  end\nend\n```","ref":"readme.html#replace-invalid-params"},{"type":"extras","title":"Custom read action - Home","doc":"If the `:action` option is set (to perform a custom read action), the fourth argument\n`args` will be passed to the action as arguments.\n\n```elixir\n%Ash.Page.Offset{count: count} = AshPagify.all(Comment, %AshPagify{}, [action: :by_post], post.id)\n```","ref":"readme.html#custom-read-action"},{"type":"extras","title":"Full-text search - Home","doc":"We allow full-text search using the `tsvector` column in PostgreSQL. To enable full-text search,\nyou need to either `use AshPagify.Tsearch` in your module or implement the `full_text_search`,\n`full_text_search_rank`, `tsquery`, and `tsvector` calculations as described in `AshPagify.Tsearch`\n(tsvector calculation  is always mandatory).\n\n```elixir\n# provide the default tsvector calculation for full-text search\ncalculate :tsvector,\n          AshPostgres.Tsvector,\n          expr(\n            fragment(\n              \"to_tsvector('simple', coalesce(?, '')) || to_tsvector('simple', coalesce(?, ''))\",\n              name,\n              title\n            )\n          ),\n          public?: true\n```\n\nOr if you want to use a generated tsvector column, you can replace the fields\npart with the name of your generated tsvector column:\n\n```elixir\n# use a tsvector column from the database\ncalculate :tsvector, AshPostgres.Tsvector, expr(tsv), public?: true\n```\n\nYou can also configure `dynamic` tsvectors based on user input. Have a look at the\n`AshPagify.Tsearch` module for more information.\n\nOnce configured, you can use the `search` parameter to apply full-text search.","ref":"readme.html#full-text-search"},{"type":"extras","title":"Sortable tables and pagination - Home","doc":"To add a sortable table and pagination links, you can add the following to your template:\n\n```elixir\n Posts \n\n \n  <:col :let={post} label=\"Name\" field={:name}><%= post.name %></:col>\n  <:col :let={post} label=\"Author\" field={:author}><%= post.author %></:col>\n \n\n \n```\n\nIn this context, path points to the current route, and AshPagify Components appends\nfull-text search, pagination, scoping, filtering, and sorting parameters to it.\nYou can use verified routes, route helpers, or custom path builder functions.\nYou'll find explanations for the different formats in the documentation for\n`AshPagify.Components.build_path/3`.\n\nNote that the field attribute in the `:col` slot is optional. If set and the\ncorresponding field in the resource is defined as sortable, the table header for\nthat column will be interactive, allowing users to sort by that column. However,\nif the field isn't defined as sortable, or if the field attribute is omitted, or\nset to `nil` or `false`, the table header will not be clickable.\n\nYou also have the option to pass a `Phoenix.LiveView.JS` command instead of or\nin addition to a path. For more details, please refer to the component\ndocumentation.","ref":"readme.html#sortable-tables-and-pagination"},{"type":"extras","title":"Parameter format - Home","doc":"The AshPagify library requires parameters to be provided in a specific format as a map.\nThis map can be translated into a URL query parameter string, typically for use in a\nweb framework like Phoenix.\n\nThe following parameters are encoded as strings and handled by the library:\n\n- `search` - A string to search for in the full-text search column or in the searchable fields.\n- `limit` - The number of records to return.\n- `offset` - The number of records to skip.\n- `scopes` - A map of predefined filters to apply to the query.\n- `filter_form` - A map of filters provided by the `AshPagify.FilterForm` module.\n- `order_by` - A list of fields to order by.","ref":"readme.html#parameter-format"},{"type":"extras","title":"Search query - Home","doc":"You can search for a string in a full-text search column.\n\n```elixir\n%{search: \"John\"}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?search=John\n```\n\nYou can use the `AshPagify.set_search/3` function to set the search query in the\n`AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.set_search(%AshPagify{}, \"John\")\n```","ref":"readme.html#search-query"},{"type":"extras","title":"Pagination - Home","doc":"You can specify an offset to start from and a limit to the number of results.\n\n```elixir\n%{offset: 100, limit: 20}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?offset=100&limit=20\n```\n\nYou can use the `AshPagify.set_offset/2` and `AshPagify.set_limit/3` functions to set\nthe offset and limit in the `AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.set_offset(%AshPagify{}, 100)\nash_pagify = AshPagify.set_limit(ash_pagify, 20)\n```","ref":"readme.html#pagination"},{"type":"extras","title":"Scoping - Home","doc":"To apply predefined filters to a query, you can set the `:scopes` parameter. `:scopes`\nshould be a map of predefined filters (maps) available in your resource. The filter name\nis used to look up the predefined filter. If the filter is found, it is applied to\nthe query. If the filter is not found, an error is raised.\n\n```elixir\n%{scopes: %{role: :admin}}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?scopes[role]=admin\n```\n\nYou can use the `AshPagify.set_scope/3` function to set the scopes in the `AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.set_scope(%AshPagify{}, %{role: :admin})\n```","ref":"readme.html#scoping"},{"type":"extras","title":"Filter forms - Home","doc":"Filter forms can be passed as a map of filter conditions. Usually, this map is generated\nby a filter form component using the `AshPagify.FilterForm` module. `AshPagify.FilterForm.params_for_query/2`\ncan be used to convert the form filter map into a query map.\n\n```elixir\n%{filter_form: %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"}}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?filter_form[name][eq]=Post%201\n```\n\nYou can use the `AshPagify.set_filter_form/3` function to set the filter form in the `AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.set_filter_form(%AshPagify{}, %{\"field\" => \"name\", \"operator\" => \"eq\", \"value\" => \"Post 1\"})\n```\n\nCheck the `AshPhoenix.FilterForm` documentation for more information.\nSee `Ash.Query.filter/2` for a list of all available filter operators.","ref":"readme.html#filter-forms"},{"type":"extras","title":"Ordering - Home","doc":"To add an ordering clause to a query, you need to set the `:order_by`\nparameter. `:order_by` should be a list of fields, aggregates, or calculations\navailable in your resource. The order direction can be set by adding\none of the following prefixes to the field name:\n\n- `\"\"` or `+` for ascending order\n- `-` for descending order\n- `++` for ascending order with nulls first\n- `--` for descending order with nulls last\n\nIf no order directions are given, `:asc` is used as default.\n\n```elixir\n%{order_by: [\"name\", \"--author\"]}\n```\n\nThis translates to the following query parameter string:\n\n```URL\n?order_by=[]name&oder_by[]=--author\n```\n\nYou can use the `AshPagify.push_order/3` function to set the order by clause in the `AshPagify` struct.\n\n```elixir\nash_pagify = AshPagify.push_order(%AshPagify{}, \"name\")\n```","ref":"readme.html#ordering"},{"type":"extras","title":"Internal parameters - Home","doc":"AshPagify is designed to manage parameters that come from the user side. While it is\npossible to alter those parameters and append extra filters upon receiving them,\nit is advisable to clearly differentiate parameters coming from outside and the\nparameters that your application adds internally.\n\nConsider the scenario where you need to scope a query based on the current user.\nIn this case, it is better to create a separate function that introduces the\nnecessary filter clauses:\n\n```elixir\ndef list_posts(%{} = params, %User{} = current_user) do\n  Post\n  |> scope(current_user)\n  |> AshPagify.validate_and_run(params)\nend\n\ndefp scope(query, %User{role: :admin}), do: query\ndefp scope(query, %User{id: user_id}), do: Ash.Query.filter_input(query, %{user_id: ^user_id})\n```\n\nIf you need to add extra filters that are only used internally and aren't exposed to the user,\nyou can pass them as a separate argument. This same argument can be used to override certain\noptions depending on the context in which the function is called.\n\n```elixir\ndef list_posts(%{} = params, opts \\\\\\\\ [], %User{} = current_user) do\n  ash_pagify_opts =\n    opts\n    |> Keyword.put(:max_limit, 10)\n    |> Keyword.put(:default_limit, 10)\n    |> Keyword.put(:replace_invalid_params?, true)\n\n  Post\n  |> scope(current_user)\n  |> apply_filters(opts)\n  |> AshPagify.validate_and_run(params, ash_pagify_opts)\nend\n\ndefp scope(query, %User{role: :admin}), do: query\ndefp scope(query, %User{id: user_id}), do: Ash.Query.filter_input(query, %{user_id: ^user_id})\n\ndefp apply_filters(query, opts) do\n  Enum.reduce(opts, query, fn\n    {:updated_at, dt}, query -> Ash.Query.filter_input(query, %{updated_at: dt})\n    _, query -> query\n  end)\nend\n```\n\nWith this approach, you maintain a clean separation between user-driven parameters and\nsystem-driven parameters, leading to more maintainable and less error-prone code. Please be\naware that in most cases it is better to use `Ash.Policy` to manage access control. This\nexample is just to illustrate the concept.\n\nUnder the hood, the `AshPagify.validate_and_run/4` or `AshPagify.validate_and_run!/4` functions\njust call `AshPagify.validate/2` and `AshPagify.run/4`, which in turn calls `AshPagify.all/4` and\n`AshPagify.meta/3`.\n\nSee `AshPagify.Meta` for descriptions of the meta fields.\n\nAlternatively, you may separate parameter validation and data fetching into different\nsteps using the `AshPagify.validate/2`, `AshPagify.validate!/2`, and `AshPagify.run/4` functions.\nThis allows you to manipulate the validated parameters, to modify the query depending on\nthe parameters, or to move the parameter validation to a different layer of your application.\n\n```elixir\nwith {:ok, ash_pagify} <- AshPagify.validate(Post, params) do\n  {:ok, {results, meta}} = AshPagify.run(Post, ash_pagify)\nend\n```\n\nThe aforementioned functions internally call the lower-level functions `AshPagify.all/4` and\n`AshPagify.meta/3`. If you have advanced requirements, you might prefer to use these functions\ndirectly. However, it's important to note that these lower-level functions do not validate\nthe parameters. If parameters are generated based on user input, they should always be\nvalidated first using `AshPagify.validate/2` or `AshPagify.validate!/2` to ensure safe execution.","ref":"readme.html#internal-parameters"},{"type":"extras","title":"Release Management - Home","doc":"We use [git_opts](https://hexdocs.pm/git_ops/readme.html) to manage our releases. To create a new release, run:\n\n```bash\nmix git_ops.release\n```\n\nThis will bump the version, create a new tag, and push the changes to the repository. The GitHub action will then build and publish the new version to Hex.","ref":"readme.html#release-management"},{"type":"extras","title":"Change Log","doc":"# Change Log\n\nAll notable changes to this project will be documented in this file.\nSee [Conventional Commits](Https://conventionalcommits.org) for commit guidelines.\n\n<!-- changelog -->\n\n## [v1.0.2](https://github.com/zebbra/ash_pagify/compare/v1.0.1...v1.0.2) (2024-08-07)","ref":"changelog.html"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* deps: remove ash_uuid\n\n## [v1.0.1](https://github.com/zebbra/ash_pagify/compare/v1.0.0...v1.0.1) (2024-08-07)","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* undo unstaged changes\n\n## [v1.0.0](https://github.com/zebbra/ash_pagify/compare/v0.1.2...v1.0.0) (2024-08-07)","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Breaking Changes: - Change Log","doc":"* Ash v3: follow ash v3 upgrade guide\n\n\n\n## [v0.1.2](https://github.com/zebbra/ash_pagify/compare/v0.1.1...v0.1.2) (2024-08-05)\n\n\n\n\n## [v0.1.1](https://github.com/zebbra/ash_pagify/compare/v0.1.0...v0.1.1) (2024-07-26)","ref":"changelog.html#breaking-changes"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* cicd: exclude dialyzer from mix check\n\n* tests: add tests/reports directory\n\n* workflows: use ubuntu-latest as runner for now\n\n## [v0.1.0](https://github.com/zebbra/ash_pagify/compare/v0.1.0...v0.1.0) (2024-07-26)","ref":"changelog.html#bug-fixes"}],"content_type":"text/markdown","producer":{"name":"ex_doc","version":[48,46,51,52,46,50]}}