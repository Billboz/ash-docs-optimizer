<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.34.2">
    <meta name="project" content="ash v3.4.8">


    <title>Update Actions — ash v3.4.8</title>
    <link rel="stylesheet" href="dist/html-elixir-F2VRIOKR.css" />


    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-K7URE6B4.js"></script>
    <script src="dist/sidebar_items-370365CE.js"></script>
    <script src="docs_config.js"></script>
    <script async src="dist/html-YIPIRHGU.js"></script>
<style>
  .livebook-badge-container + pre {
    display: none;
  }
</style>
<script>
  if (location.hostname === "hexdocs.pm") {
    var script = document.createElement("script");
    script.src = "https://plausible.io/js/script.js";
    script.setAttribute("defer", "defer")
    script.setAttribute("data-domain", "ashhexdocs")
    document.head.appendChild(script);
  }
</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad: true})</script>

  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

        <a href="https://github.com/ash-project/ash" class="sidebar-projectImage">
          <img src="assets/logo.png" alt="ash" />
        </a>

      <div>
        <a href="https://github.com/ash-project/ash" class="sidebar-projectName" translate="no">
ash
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v3.4.8
        </div>
      </div>
    </div>
    <ul id="sidebar-listNav" class="sidebar-listNav" role="tablist">
      <li>
        <button id="extras-list-tab-button" role="tab" data-type="extras" aria-controls="extras-tab-panel" aria-selected="true" tabindex="0">
GUIDES
        </button>
      </li>

        <li>
          <button id="modules-list-tab-button" role="tab" data-type="modules" aria-controls="modules-tab-panel" aria-selected="false" tabindex="-1">
            Modules
          </button>
        </li>


        <li>
          <button id="tasks-list-tab-button" role="tab" data-type="tasks" aria-controls="tasks-tab-panel" aria-selected="false" tabindex="-1">
            <span translate="no">Mix</span> Tasks
          </button>
        </li>

    </ul>
  </div>

  <div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button">
    <ul id="extras-full-list" class="full-list"></ul>
  </div>

    <div id="modules-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="modules-list-tab-button" hidden>
      <ul id="modules-full-list" class="full-list"></ul>
    </div>


    <div id="tasks-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="tasks-list-tab-button" hidden>
      <ul id="tasks-full-list" class="full-list"></ul>
    </div>

</nav>

<main class="content">
  <output role="status" id="toast"></output>

  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of ash</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search">
            <i class="ri-search-2-line ri-lg" aria-hidden="true" title="Submit search"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <h1>

      <a href="https://github.com/ash-project/ash/blob/v3.4.8/documentation/topics/actions/update-actions.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>


    <span>Update Actions</span>
  </h1>

<p>Update actions are used to update records in the data layer. For example:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># on a ticket resource</span><span class="w">
</span><span class="n">update</span><span class="w"> </span><span class="ss">:close</span><span class="w"> </span><span class="k" data-group-id="1716288895-1">do</span><span class="w">
  </span><span class="n">accept</span><span class="w"> </span><span class="p" data-group-id="1716288895-2">[</span><span class="ss">:close_reason</span><span class="p" data-group-id="1716288895-2">]</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">set_attribute</span><span class="p" data-group-id="1716288895-3">(</span><span class="ss">:status</span><span class="p">,</span><span class="w"> </span><span class="ss">:closed</span><span class="p" data-group-id="1716288895-3">)</span><span class="w">
</span><span class="k" data-group-id="1716288895-1">end</span></code></pre><p>Here we have an update action called <code class="inline">:close</code> that allows setting the <code class="inline">close_reason</code>, and sets the <code class="inline">status</code> to <code class="inline">:closed</code>. It could be called like so:</p><pre><code class="makeup elixir" translate="no"><span class="n">ticket</span><span class="w"> </span><span class="c1"># providing an initial ticket to close</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Changeset</span><span class="o">.</span><span class="n">for_update</span><span class="p" data-group-id="0377828801-1">(</span><span class="ss">:close</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0377828801-2">%{</span><span class="ss">close_reason</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;I figured it out.&quot;</span><span class="p" data-group-id="0377828801-2">}</span><span class="p" data-group-id="0377828801-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">update!</span><span class="p" data-group-id="0377828801-3">(</span><span class="p" data-group-id="0377828801-3">)</span></code></pre><p>See the <a href="code-interfaces.html">Code Interface guide</a> for creating an interface to call the action more elegantly, like so:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Support</span><span class="o">.</span><span class="n">close_ticket!</span><span class="p" data-group-id="2560247509-1">(</span><span class="n">ticket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;I figured it out.&quot;</span><span class="p" data-group-id="2560247509-1">)</span><span class="w">
</span><span class="c1"># You can also provide an id</span><span class="w">
</span><span class="nc">Support</span><span class="o">.</span><span class="n">close_ticket!</span><span class="p" data-group-id="2560247509-2">(</span><span class="n">ticket</span><span class="o">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;I figured it out.&quot;</span><span class="p" data-group-id="2560247509-2">)</span></code></pre><h2 id="atomics" class="section-heading">
  <a href="#atomics" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Atomics</span>
</h2>
<p>Atomic updates can be added to a changeset, which will update the value of an attribute given by an expression. Atomics can be a very powerful way to model updating data in a simple way. An action does not have to be <a href="#fully-atomic-updates">fully atomic</a> in order to leverage atomic updates. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">update</span><span class="w"> </span><span class="ss">:add_to_name</span><span class="w"> </span><span class="k" data-group-id="3682006628-1">do</span><span class="w">
  </span><span class="n">argument</span><span class="w"> </span><span class="ss">:to_add</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="n">allow_nil?</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">atomic_update</span><span class="p" data-group-id="3682006628-2">(</span><span class="ss">:name</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="3682006628-3">(</span><span class="s">&quot;</span><span class="si" data-group-id="3682006628-4">#{</span><span class="n">name</span><span class="si" data-group-id="3682006628-4">}</span><span class="s">_</span><span class="si" data-group-id="3682006628-5">#{</span><span class="n">to_add</span><span class="si" data-group-id="3682006628-5">}</span><span class="s">&quot;</span><span class="p" data-group-id="3682006628-3">)</span><span class="p" data-group-id="3682006628-2">)</span><span class="w">
</span><span class="k" data-group-id="3682006628-1">end</span></code></pre><p>Changing attributes in this way makes them safer to use in concurrent environments, and is typically more performant than doing it manually in memory.</p><blockquote><h3 id="atomics-are-not-stored-with-other-changes" class="warning section-heading">
  <a href="#atomics-are-not-stored-with-other-changes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Atomics are not stored with other changes</span>
</h3>
<p>While we recommend using atomics wherever possible, it is important to note that they are stored in their own map in the changeset,
i.e <code class="inline">changeset.atomics</code>, meaning if you need to do something later in the action with the new value for an attribute, you won't be
able to access the new value. This is because atomics are evaluated in the data layer. You can, however, access &quot;the old or new value&quot;
in a similar way to <code class="inline">Ash.Changeset.get_attribute</code>, using the template expression, <code class="inline">atomic_ref(:name)</code>. See the section below for more.</p></blockquote><h3 id="atomic_ref-1" class="section-heading">
  <a href="#atomic_ref-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text"><code class="inline">atomic_ref/1</code></span>
</h3>
<p>Lets say that you have an action that may perform multiple atomic update on a single column, or for some other reason needs to refer to the new value.
The only way to access that new value is <em>also</em> in an atomic update, change, or validation, using <code class="inline">atomic_ref/1</code>. There is no way to access the new value
prior to the action being run with something like <a href="Ash.Changeset.html#get_attribute/2"><code class="inline">Ash.Changeset.get_attribute/2</code></a>.</p><p>For example, lets say you have a postgres function that will slugify a string, and you want to make sure to always set it to the slugified version of <code class="inline">name</code>,
whenever <code class="inline">name</code> is changing.</p><pre><code class="makeup elixir" translate="no"><span class="n">changes</span><span class="w"> </span><span class="k" data-group-id="3718254779-1">do</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">atomic_update</span><span class="p" data-group-id="3718254779-2">(</span><span class="ss">:slug</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="3718254779-3">(</span><span class="n">fragment</span><span class="p" data-group-id="3718254779-4">(</span><span class="s">&quot;slugify(?)&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">^</span><span class="n">atomic_ref</span><span class="p" data-group-id="3718254779-5">(</span><span class="ss">:name</span><span class="p" data-group-id="3718254779-5">)</span><span class="p" data-group-id="3718254779-4">)</span><span class="p" data-group-id="3718254779-3">)</span><span class="p" data-group-id="3718254779-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">where</span><span class="p">:</span><span class="w"> </span><span class="n">changing</span><span class="p" data-group-id="3718254779-6">(</span><span class="ss">:name</span><span class="p" data-group-id="3718254779-6">)</span><span class="p">,</span><span class="w"> </span><span class="ss">on</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3718254779-7">[</span><span class="ss">:update</span><span class="p" data-group-id="3718254779-7">]</span><span class="w">
</span><span class="k" data-group-id="3718254779-1">end</span></code></pre><p>By using <code class="inline">atomic_ref/1</code> here, you are always referring to the new value of <code class="inline">name</code>, even if another atomic update has been made that modifies <code class="inline">name</code>.</p><p>Because the validation <code class="inline">changing/1</code> can be done atomically, and the change <code class="inline">atomic_update/2</code> (naturally) can be done atomically, this is a fully atomic update.
Lets say that you paired this with an action like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">update</span><span class="w"> </span><span class="ss">:add_to_name</span><span class="w"> </span><span class="k" data-group-id="7102717093-1">do</span><span class="w">
  </span><span class="n">argument</span><span class="w"> </span><span class="ss">:to_add</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="n">allow_nil?</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">atomic_update</span><span class="p" data-group-id="7102717093-2">(</span><span class="ss">:name</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="7102717093-3">(</span><span class="s">&quot;</span><span class="si" data-group-id="7102717093-4">#{</span><span class="n">name</span><span class="si" data-group-id="7102717093-4">}</span><span class="s">_</span><span class="si" data-group-id="7102717093-5">#{</span><span class="n">to_add</span><span class="si" data-group-id="7102717093-5">}</span><span class="s">&quot;</span><span class="p" data-group-id="7102717093-3">)</span><span class="p" data-group-id="7102717093-2">)</span><span class="w">
</span><span class="k" data-group-id="7102717093-1">end</span></code></pre><p>and would produce a SQL update along the lines of:</p><pre><code class="sql">UPDATE table
  SET name = name || $1,
  slug = CASE
    WHEN name = name || $1 THEN
      slug
    ELSE
      slugify(name || $1)
  END
WHERE id = $2</code></pre><p>This is a <em>fully atomic update</em>, because all changes are done atomically in the data layer. We now have the benefits of composable building blocks <em>and</em>
atomic updates.</p><h2 id="fully-atomic-updates" class="section-heading">
  <a href="#fully-atomic-updates" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Fully Atomic updates</span>
</h2>
<p>Atomic updates are a special case of update actions that can be done completely atomically. If your update action can't be done atomically, you will get an error unless you have set <code class="inline">require_atomic? false</code>. This is to encourage you to opt for atomic updates whereever reasonable. Not all actions can reasonably be made atomic, and not all non-atomic actions are problematic for concurrency. The goal is only to make sure that you are aware and have considered the implications.</p><blockquote><h3 id="what-does-atomic-mean" class="info section-heading">
  <a href="#what-does-atomic-mean" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">What does atomic mean?</span>
</h3>
<p>An atomic update is one that can be done in a single operation in the data layer. This ensures that there are no issues with concurrent access to the record being updated, and that it is as performant as possible.
For example, the following action cannot be done atomically, because it has
an anonymous function change on it.</p><pre><code class="makeup elixir" translate="no"><span class="n">update</span><span class="w"> </span><span class="ss">:increment_score</span><span class="w"> </span><span class="k" data-group-id="6127503115-1">do</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="k" data-group-id="6127503115-2">fn</span><span class="w"> </span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nc">Ash.Changeset</span><span class="o">.</span><span class="n">set_attribute</span><span class="p" data-group-id="6127503115-3">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="ss">:score</span><span class="p">,</span><span class="w"> </span><span class="n">changeset</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">score</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="6127503115-3">)</span><span class="w">
  </span><span class="k" data-group-id="6127503115-2">end</span><span class="w">
</span><span class="k" data-group-id="6127503115-1">end</span></code></pre><p>The action shown above is not safe to run concurrently. If two separate processes fetch the record with score <code class="inline">1</code>, and then call <code class="inline">increment_score</code>, they will both set the score to <code class="inline">2</code>, when what you almost certainly intended to do was end up with a score of <code class="inline">3</code></p><p>By contrast, the following action <em>can</em> be done atomically</p><pre><code class="makeup elixir" translate="no"><span class="n">update</span><span class="w"> </span><span class="ss">:increment_score</span><span class="w"> </span><span class="k" data-group-id="9919704180-1">do</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">atomic_update</span><span class="p" data-group-id="9919704180-2">(</span><span class="ss">:score</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="9919704180-3">(</span><span class="n">score</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="9919704180-3">)</span><span class="p" data-group-id="9919704180-2">)</span><span class="w">
</span><span class="k" data-group-id="9919704180-1">end</span></code></pre><p>In a SQL data layer, this would produce SQL along the lines of</p><pre><code class="makeup elixir" translate="no"><span class="s">&quot;UPDATE table SET score = score + 1 WHERE id = post_id&quot;</span></code></pre></blockquote><h2 id="what-makes-an-action-not-atomic" class="section-heading">
  <a href="#what-makes-an-action-not-atomic" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">What makes an action not atomic?</span>
</h2>
<h3 id="types-that-can-t-be-atomically-casted" class="section-heading">
  <a href="#types-that-can-t-be-atomically-casted" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Types that can't be atomically casted</span>
</h3>
<p>Not all types support being casted atomically. For instance, <code class="inline">:union</code> types, and embedded resources that have primary keys(and therefore may need to use an update action) cannot currently be casted atomically.</p><h3 id="changes-without-an-atomic-callback" class="section-heading">
  <a href="#changes-without-an-atomic-callback" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Changes without an <code class="inline">atomic</code> callback</span>
</h3>
<p>Changes can be enhanced to support atomics by defining <a href="Ash.Resource.Change.html#c:atomic/3"><code class="inline">Ash.Resource.Change.atomic/3</code></a>. This callback can return a map of atomic updates to be made to attributes. Here is a simplified example from the built in <a href="Ash.Resource.Change.Builtins.html#increment/2"><code class="inline">Ash.Resource.Change.Builtins.increment/2</code></a> change:</p><pre><code class="makeup elixir" translate="no"><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">atomic</span><span class="p" data-group-id="8140625241-1">(</span><span class="c">_changeset</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="c">_context</span><span class="p" data-group-id="8140625241-1">)</span><span class="w"> </span><span class="k" data-group-id="8140625241-2">do</span><span class="w">
  </span><span class="c1"># Set the requested attribute to its current value (atomic_ref) + the amount</span><span class="w">
  </span><span class="p" data-group-id="8140625241-3">{</span><span class="ss">:atomic</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8140625241-4">%{</span><span class="n">opts</span><span class="p" data-group-id="8140625241-5">[</span><span class="ss">:attribute</span><span class="p" data-group-id="8140625241-5">]</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="8140625241-6">(</span><span class="o">^</span><span class="n">atomic_ref</span><span class="p" data-group-id="8140625241-7">(</span><span class="n">opts</span><span class="p" data-group-id="8140625241-8">[</span><span class="ss">:attribute</span><span class="p" data-group-id="8140625241-8">]</span><span class="p" data-group-id="8140625241-7">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">^</span><span class="n">opts</span><span class="p" data-group-id="8140625241-9">[</span><span class="ss">:amount</span><span class="p" data-group-id="8140625241-9">]</span><span class="p" data-group-id="8140625241-6">)</span><span class="p" data-group-id="8140625241-4">}</span><span class="p" data-group-id="8140625241-3">}</span><span class="w">
</span><span class="k" data-group-id="8140625241-2">end</span></code></pre><h3 id="validations-without-an-atomic-callback" class="section-heading">
  <a href="#validations-without-an-atomic-callback" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Validations without an <code class="inline">atomic</code> callback</span>
</h3>
<p>Validations can be enhanced to support atomics by defining <a href="Ash.Resource.Validation.html#c:atomic/3"><code class="inline">Ash.Resource.Validation.atomic/3</code></a>. This callback can return an atomic validation (or a list of atomic validations), which is represented by a list of affected attributes (not currently used), an expression that should trigger an error, and the expression producing the error. Here is an example from the built in <code class="inline">Ash.Resource.Validations.Builtins.attribute_equals/2</code> validation:</p><pre><code class="makeup elixir" translate="no"><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">atomic</span><span class="p" data-group-id="7627130606-1">(</span><span class="c">_changeset</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p" data-group-id="7627130606-1">)</span><span class="w"> </span><span class="k" data-group-id="7627130606-2">do</span><span class="w">
  </span><span class="p" data-group-id="7627130606-3">{</span><span class="ss">:atomic</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7627130606-4">[</span><span class="n">opts</span><span class="p" data-group-id="7627130606-5">[</span><span class="ss">:attribute</span><span class="p" data-group-id="7627130606-5">]</span><span class="p" data-group-id="7627130606-4">]</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="7627130606-6">(</span><span class="o">^</span><span class="n">atomic_ref</span><span class="p" data-group-id="7627130606-7">(</span><span class="n">opts</span><span class="p" data-group-id="7627130606-8">[</span><span class="ss">:attribute</span><span class="p" data-group-id="7627130606-8">]</span><span class="p" data-group-id="7627130606-7">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">^</span><span class="n">opts</span><span class="p" data-group-id="7627130606-9">[</span><span class="ss">:value</span><span class="p" data-group-id="7627130606-9">]</span><span class="p" data-group-id="7627130606-6">)</span><span class="p">,</span><span class="w">
   </span><span class="n">expr</span><span class="p" data-group-id="7627130606-10">(</span><span class="w">
     </span><span class="n">error</span><span class="p" data-group-id="7627130606-11">(</span><span class="o">^</span><span class="nc">InvalidAttribute</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7627130606-12">%{</span><span class="w">
       </span><span class="ss">field</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="n">opts</span><span class="p" data-group-id="7627130606-13">[</span><span class="ss">:attribute</span><span class="p" data-group-id="7627130606-13">]</span><span class="p">,</span><span class="w">
       </span><span class="ss">value</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="n">atomic_ref</span><span class="p" data-group-id="7627130606-14">(</span><span class="n">opts</span><span class="p" data-group-id="7627130606-15">[</span><span class="ss">:attribute</span><span class="p" data-group-id="7627130606-15">]</span><span class="p" data-group-id="7627130606-14">)</span><span class="p">,</span><span class="w">
       </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="p" data-group-id="7627130606-16">(</span><span class="n">context</span><span class="o">.</span><span class="n">message</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s">&quot;must equal %{value}&quot;</span><span class="p" data-group-id="7627130606-16">)</span><span class="p">,</span><span class="w">
       </span><span class="ss">vars</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7627130606-17">%{</span><span class="ss">field</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="n">opts</span><span class="p" data-group-id="7627130606-18">[</span><span class="ss">:attribute</span><span class="p" data-group-id="7627130606-18">]</span><span class="p">,</span><span class="w"> </span><span class="ss">value</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="n">opts</span><span class="p" data-group-id="7627130606-19">[</span><span class="ss">:value</span><span class="p" data-group-id="7627130606-19">]</span><span class="p" data-group-id="7627130606-17">}</span><span class="w">
     </span><span class="p" data-group-id="7627130606-12">}</span><span class="p" data-group-id="7627130606-11">)</span><span class="w">
   </span><span class="p" data-group-id="7627130606-10">)</span><span class="p" data-group-id="7627130606-3">}</span><span class="w">
</span><span class="k" data-group-id="7627130606-2">end</span></code></pre><h2 id="bulk-updates" class="section-heading">
  <a href="#bulk-updates" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Bulk updates</span>
</h2>
<p>There are three strategies for bulk updating data. They are, in order of preference: <code class="inline">:atomic</code>, <code class="inline">:atomic_batches</code>, and <code class="inline">:stream</code>. When calling <a href="Ash.html#bulk_update/4"><code class="inline">Ash.bulk_update/4</code></a>, you can provide a strategy or strategies that can be used, and Ash will choose the best one available. The implementation of the update action and the capabilities of the data layer determine what strategies can be used.</p><h2 id="atomic" class="section-heading">
  <a href="#atomic" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Atomic</span>
</h2>
<p>Atomic bulk updates are used when the subject of the bulk update is a query, and the update action <a href="#fully-atomic-updates">can be done atomically</a> and the data layer supports updating a query. They map to a single statement to the data layer to update all matching records. The data layer must support updating a query.</p><h3 id="example" class="section-heading">
  <a href="#example" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Example</span>
</h3>
<pre><code class="makeup elixir" translate="no"><span class="nc">Ticket</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="4943822307-1">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:open</span><span class="p" data-group-id="4943822307-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">bulk_update!</span><span class="p" data-group-id="4943822307-2">(</span><span class="ss">:close</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4943822307-3">%{</span><span class="ss">reason</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Closing all open tickets.&quot;</span><span class="p" data-group-id="4943822307-3">}</span><span class="p" data-group-id="4943822307-2">)</span></code></pre><p>If using a SQL data layer, this would produce a query along the lines of</p><pre><code class="sql">UPDATE tickets
SET status = 'closed',
    reason = 'Closing all open tickets.'
WHERE status = 'open';</code></pre><h2 id="atomic-batches" class="section-heading">
  <a href="#atomic-batches" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Atomic Batches</span>
</h2>
<p>Atomic batches is used when the subject of the bulk update is an enumerable (i.e list or stream) of records and the update action <a href="#fully-atomic-updates">can be done atomically</a> and the data layer supports updating a query. The records are pulled out in batches, and then each batch follows the logic described <a href="#atomic">above</a>. The batch size is controllable by the <code class="inline">batch_size</code> option.</p><h3 id="example-1" class="section-heading">
  <a href="#example-1" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Example</span>
</h3>
<pre><code class="makeup elixir" translate="no"><span class="w">
</span><span class="nc">Ash</span><span class="o">.</span><span class="n">bulk_update!</span><span class="p" data-group-id="5345032612-1">(</span><span class="n">one_hundred_tickets</span><span class="p">,</span><span class="w"> </span><span class="ss">:close</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5345032612-2">%{</span><span class="ss">reason</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Closing all open tickets.&quot;</span><span class="p" data-group-id="5345032612-2">}</span><span class="p">,</span><span class="w"> </span><span class="ss">batch_size</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p" data-group-id="5345032612-1">)</span></code></pre><p>If using a SQL data layer, this would produce ten queries along the lines of</p><pre><code class="sql">UPDATE tickets
SET status = 'closed',
    reason = 'Closing all open tickets.'
WHERE id IN (...ids)</code></pre><h2 id="stream" class="section-heading">
  <a href="#stream" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Stream</span>
</h2>
<p>Stream is used when the update action <a href="#fully-atomic-updates">cannot be done atomically</a> or if the data layer does not support updating a query. If a query is given, it is run and the records are used as an enumerable of inputs. If an enumerable of inputs is given, each one is updated individually. There is nothing inherently wrong with doing this kind of update, but it will naturally be slower than the other two strategies.
The benefit of having a single interface (<a href="Ash.html#bulk_update/4"><code class="inline">Ash.bulk_update/4</code></a>) is that the caller doesn't need to change based on the performance implications of the action.</p><h2 id="running-a-standard-update-action" class="section-heading">
  <a href="#running-a-standard-update-action" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Running a standard update action</span>
</h2>
<p>All actions are run in a transaction if the data layer supports it. You can opt out of this behavior by supplying <code class="inline">transaction?: false</code> when creating the action. When an action is being run in a transaction, all steps inside of it are serialized because transactions cannot be split across processes.</p><ul><li>Authorization is performed on the changes</li><li>A before action hook is added to set up belongs_to relationships that are managed. This means potentially creating/modifying the destination of the relationship, and then changing the <code class="inline">destination_attribute</code> of the relationship.</li><li><code class="inline">before_transaction</code> and <code class="inline">around_transaction</code> hooks are called (<a href="Ash.Changeset.html#before_transaction/2"><code class="inline">Ash.Changeset.before_transaction/2</code></a>). Keep in mind, any validations that are marked as <code class="inline">before_action? true</code> (or all global validations if your action has <code class="inline">delay_global_validations? true</code>) will not have happened at this point.</li><li>A transaction is opened if the action is configured for it (by default they are) and the data layer supports transactions</li><li><code class="inline">before_action</code> hooks are performed in order</li><li>The main action is sent to the data layer</li><li><code class="inline">after_action</code> hooks are performed in order</li><li>Non-belongs-to relationships are managed, creating/updating/destroying related records.</li><li>The transaction is closed, if one was opened</li><li><code class="inline">after_transaction</code> hooks are invoked with the result of the transaction (even if it was an error)</li></ul><h2 id="atomic-upgrade" class="section-heading">
  <a href="#atomic-upgrade" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Atomic Upgrade</span>
</h2>
<p>Update actions that are run as &quot;normal&quot; update actions will, at the time of execution, be &quot;upgraded&quot; to an atomic action if possible. This means taking the original inputs and building a corresponding atomic action. This behavior is primarily useful for using things like <code class="inline">AshPhoenix.Form</code>, where you want to validate and see the effects of an action before running it, but want the ultimate invocation to be atomic (i.e concurrency safe).</p><p>You can disable this by adding <code class="inline">atomic_upgrade? false</code> to the action configuration. Additionally, you may want to configure the read action used for atomic upgrades (defaults to the primary read), with <code class="inline">atomic_upgrade_with</code> option, i.e <code class="inline">atomic_upgrade_with :list_all</code></p>
</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="create-actions.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Create Actions
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="destroy-actions.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Destroy Actions
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

          <span class="line">
            <a href="https://hex.pm/packages/ash/3.4.8" class="footer-hex-package">Hex Package</a>

            <a href="https://preview.hex.pm/preview/ash/3.4.8">Hex Preview</a>

              (<a href="https://preview.hex.pm/preview/ash/3.4.8/show/documentation/topics/actions/update-actions.md">current file</a>)

          </span>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="ash.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.34.2) for the

          <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

      </p>

    </footer>
  </div>
</main>
</div>

  </body>
</html>
