searchData={"items":[{"type":"module","title":"AshPhoenix.LiveView","doc":"Utilities for keeping Ash query results up to date in a LiveView.","ref":"AshPhoenix.LiveView.html"},{"type":"function","title":"AshPhoenix.LiveView.can_link_to_page?/2","doc":"","ref":"AshPhoenix.LiveView.html#can_link_to_page?/2"},{"type":"function","title":"AshPhoenix.LiveView.change_page/3","doc":"","ref":"AshPhoenix.LiveView.html#change_page/3"},{"type":"function","title":"AshPhoenix.LiveView.handle_live/4","doc":"Incorporates an `Ash.Notifier.Notification` into the query results, based on the liveness configuration.\n\nYou will want to match on receiving a notification from Ash, and the easiest way to do that is to match\non the payload like so:\n\n```\n  @impl true\ndef handle_info(%{topic: topic, payload: %Ash.Notifier.Notification{}}, socket) do\n  {:noreply, handle_live(socket, topic, [:query1, :query2, :query3])}\nend\n```\n\nFeel free to intercept notifications and do your own logic to respond to events. Ultimately, all\nthat matters is that you also call `handle_live/3` if you want it to update your query results.\n\nThe assign or list of assigns passed as the third argument must be the same names passed into\n`keep_live`. If you only want some queries to update based on some events, you can define multiple\nmatches on events, and only call `handle_live/3` with the assigns that should be updated for that\nnotification.","ref":"AshPhoenix.LiveView.html#handle_live/4"},{"type":"function","title":"AshPhoenix.LiveView.keep_live/4","doc":"Runs the callback, and stores the information required to keep it live in the socket assigns.\n\nThe data will be assigned to the provided key, e.g `keep_live(socket, :me, ...)` would assign the results\nto `:me` (accessed as `@me` in the template).\n\nAdditionally, you'll need to define a `handle_info/2` callback for your liveview to receive any\nnotifications, and pass that notification into `handle_live/3`. See `handle_live/3` for more.","ref":"AshPhoenix.LiveView.html#keep_live/4"},{"type":"function","title":"Important - AshPhoenix.LiveView.keep_live/4","doc":"The logic for handling events to keep data live is currently very limited. It will simply rerun the query\nevery time. To this end, you should feel free to intercept individual events and handle them yourself for\nmore optimized liveness.","ref":"AshPhoenix.LiveView.html#keep_live/4-important"},{"type":"function","title":"Pagination - AshPhoenix.LiveView.keep_live/4","doc":"To make paginated views convenient, as well as making it possible to keep those views live, Ash does not\nsimply rerun the query when it gets an update, as that could involve shuffling the records around on the\npage. Eventually this will be configurable, but for now, Ash simply adjusts the query to only include the\nrecords that are on the page. If a record would be removed from a page due to a data change, it will simply\nbe left there. For the best performance, use `keyset` pagination. If you *need* the ability to jump to a\npage by number, you'll want to use `offset` pagination, but keep in mind that it performs worse on large\ntables.\n\nTo support this, accept a second parameter to your callback function, which will be the options to use in `page_opts`","ref":"AshPhoenix.LiveView.html#keep_live/4-pagination"},{"type":"function","title":"Options: - AshPhoenix.LiveView.keep_live/4","doc":"* `:subscribe` - A topic or list of topics that should cause this data to update.\n\n* `:refetch?` (`t:boolean/0`) - A boolean flag indicating whether a refetch is allowed to happen. Defaults to `true`\n\n* `:after_fetch` (`t:term/0`) - A two argument function that takes the results, and the socket, and returns the new socket. Can be used to set assigns based on the result of the query.\n\n* `:results` - For list and page queries, by default the records shown are never changed (unless the page changes) Valid values are :keep, :lose The default value is `:keep`.\n\n* `:load_until_connected?` (`t:boolean/0`) - If the socket is not connected, then the value of the provided assign is set to `:loading`. Has no effect if `initial` is provided.\n\n* `:initial` (`t:term/0`) - Results to use instead of running the query immediately.\n\n* `:refetch_interval` (`t:non_neg_integer/0`) - An interval (in ms) to periodically refetch the query\n\n* `:refetch_window` (`t:non_neg_integer/0`) - The minimum time (in ms) between refetches, including refetches caused by notifications.\n\n\n\nA great way to get readable millisecond values is to use the functions in erlang's `:timer` module,\nlike `:timer.hours/1`, `:timer.minutes/1`, and `:timer.seconds/1`\n\n#### refetch_interval\n\nIf this option is set, a message is sent as `{:refetch, assign_name, opts}` on that interval.\nYou can then match on that event, like so:\n\n```\ndef handle_info({:refetch, assign, opts}, socket) do\n  {:noreply, handle_live(socket, :refetch, assign, opts)}\nend\n```\n\nThis is the equivalent of `:timer.send_interval(interval, {:refetch, assign, opts})`, so feel free to\nroll your own solution if you have complex refetching requirements.\n\n#### refetch_window\n\nNormally, when a pubsub message is received the query is rerun. This option will cause the query to wait at least\nthis amount of time before doing a refetch. This is accomplished with `Process.send_after/4`, and recording the\nlast time each query was refetched. For example if a refetch happens at time `0`, and the `refetch_window` is\n10,000 ms, we would refetch, and record the time. Then if another refetch should happen 5,000 ms later, we would\nlook and see that we need to wait another 5,000ms. So we use `Process.send_after/4` to send a\n`{:refetch, assign, opts}` message in 5,000ms. The time that a refetch was requested is tracked, so if the\ndata has since been refetched, it won't be refetched again.\n\n#### Future Plans\n\nOne interesting thing here is that, given that we know the scope of data that a resource cares about,\nwe should be able to make optimizations to this code, to support partial refetches, or even just updating\nthe data directly. However, this will need to be carefully considered, as the risks involve showing users\ndata they could be unauthorized to see, or having state in the socket that is inconsistent.","ref":"AshPhoenix.LiveView.html#keep_live/4-options"},{"type":"function","title":"AshPhoenix.LiveView.last_page/1","doc":"","ref":"AshPhoenix.LiveView.html#last_page/1"},{"type":"function","title":"AshPhoenix.LiveView.next_page?/1","doc":"","ref":"AshPhoenix.LiveView.html#next_page?/1"},{"type":"function","title":"AshPhoenix.LiveView.on_page?/2","doc":"","ref":"AshPhoenix.LiveView.html#on_page?/2"},{"type":"function","title":"AshPhoenix.LiveView.page_from_params/3","doc":"","ref":"AshPhoenix.LiveView.html#page_from_params/3"},{"type":"function","title":"AshPhoenix.LiveView.page_link_params/2","doc":"","ref":"AshPhoenix.LiveView.html#page_link_params/2"},{"type":"function","title":"AshPhoenix.LiveView.page_number/1","doc":"","ref":"AshPhoenix.LiveView.html#page_number/1"},{"type":"function","title":"AshPhoenix.LiveView.page_params/1","doc":"","ref":"AshPhoenix.LiveView.html#page_params/1"},{"type":"function","title":"AshPhoenix.LiveView.prev_page?/1","doc":"","ref":"AshPhoenix.LiveView.html#prev_page?/1"},{"type":"type","title":"AshPhoenix.LiveView.assign/0","doc":"","ref":"AshPhoenix.LiveView.html#t:assign/0"},{"type":"type","title":"AshPhoenix.LiveView.assigns/0","doc":"","ref":"AshPhoenix.LiveView.html#t:assigns/0"},{"type":"type","title":"AshPhoenix.LiveView.callback/0","doc":"","ref":"AshPhoenix.LiveView.html#t:callback/0"},{"type":"type","title":"AshPhoenix.LiveView.callback_result/0","doc":"","ref":"AshPhoenix.LiveView.html#t:callback_result/0"},{"type":"type","title":"AshPhoenix.LiveView.liveness_options/0","doc":"","ref":"AshPhoenix.LiveView.html#t:liveness_options/0"},{"type":"type","title":"AshPhoenix.LiveView.socket/0","doc":"","ref":"AshPhoenix.LiveView.html#t:socket/0"},{"type":"type","title":"AshPhoenix.LiveView.topic/0","doc":"","ref":"AshPhoenix.LiveView.html#t:topic/0"},{"type":"module","title":"AshPhoenix.SubdomainPlug","doc":"This is a basic plug that loads the current tenant assign from a given\nvalue set on subdomain.\n\nThis was copied from `Triplex.SubdomainPlug`, here:\n  https://github.com/ateliware/triplex/blob/master/lib/triplex/plugs/subdomain_plug.ex\n\nOptions:\n\n* `:endpoint` (`t:atom/0`) - Required. The endpoint that the plug is in, used for deterining the host\n\n* `:assign` (`t:atom/0`) - The key to use when assigning the current tenant The default value is `:current_tenant`.\n\n* `:handle_subdomain` - An mfa to call with the conn and a subdomain value. Can be used to do something like fetch the current user given the tenant. Must return the new conn.\n\n\n\nTo plug it on your router, you can use:\n    plug AshPhoenix.SubdomainPlug,\n      endpoint: MyApp.Endpoint\n\nAn additional helper here can be used for determining the host in your liveview, and/or using\nthe host that was already assigned to the conn.\n\nFor example:\n\n    def handle_params(params, uri, socket) do\n      socket =\n        assign_new(socket, :current_tenant, fn ->\n          AshPhoenix.SubdomainPlug.live_tenant(socket, uri)\n        end)\n\n      socket =\n        assign_new(socket, :current_organization, fn ->\n          if socket.assigns[:current_tenant] do\n            MyApp.Accounts.Ash.get!(MyApp.Accounts.Organization,\n              subdomain: socket.assigns[:current_tenant]\n            )\n          end\n        end)\n\n      {:noreply, socket}\n    end","ref":"AshPhoenix.SubdomainPlug.html"},{"type":"function","title":"AshPhoenix.SubdomainPlug.live_tenant/2","doc":"","ref":"AshPhoenix.SubdomainPlug.html#live_tenant/2"},{"type":"task","title":"mix ash_phoenix.gen.html","doc":"This task renders .ex and .heex templates and copies them to specified directories.","ref":"Mix.Tasks.AshPhoenix.Gen.Html.html"},{"type":"task","title":"Positional Arguments - mix ash_phoenix.gen.html","doc":"- `domain` - The domain (e.g. \"Shop\").\n- `resource` - The resource (e.g. \"Product\").","ref":"Mix.Tasks.AshPhoenix.Gen.Html.html#module-positional-arguments"},{"type":"task","title":"Options - mix ash_phoenix.gen.html","doc":"- `--resource-plural` - The plural resource name (e.g. \"products\")\n\n\nmix ash_phoenix.gen.html MyApp.Shop MyApp.Shop.Product --plural-name products","ref":"Mix.Tasks.AshPhoenix.Gen.Html.html#module-options"},{"type":"function","title":"Mix.Tasks.AshPhoenix.Gen.Html.run/1","doc":"","ref":"Mix.Tasks.AshPhoenix.Gen.Html.html#run/1"},{"type":"task","title":"mix ash_phoenix.gen.live","doc":"Generates liveviews for a given domain and resource.\n\nThe domain and resource must already exist, this task does not define them.","ref":"Mix.Tasks.AshPhoenix.Gen.Live.html"},{"type":"task","title":"Positional Arguments - mix ash_phoenix.gen.live","doc":"- `domain` - The domain (e.g. \"Shop\").\n- `resource` - The resource (e.g. \"Product\").","ref":"Mix.Tasks.AshPhoenix.Gen.Live.html#module-positional-arguments"},{"type":"task","title":"Options - mix ash_phoenix.gen.live","doc":"- `--resource-plural` - The plural resource name (e.g. \"products\")\n\n\nFor example:\n\n```bash\nmix ash_phoenix.gen.live ExistingDomainName ExistingResourceName\n```","ref":"Mix.Tasks.AshPhoenix.Gen.Live.html#module-options"},{"type":"function","title":"Mix.Tasks.AshPhoenix.Gen.Live.run/1","doc":"","ref":"Mix.Tasks.AshPhoenix.Gen.Live.html#run/1"},{"type":"module","title":"AshPhoenix.Form","doc":"A module to allow you to fluidly use resources with Phoenix forms.","ref":"AshPhoenix.Form.html"},{"type":"module","title":"Life cycle - AshPhoenix.Form","doc":"The general workflow is, with either LiveView or Phoenix forms:\n\n1. Create a form with `AshPhoenix.Form`\n2. Render the form with `Phoenix.Component.form` (or `CoreComponents.simple_form`), or, if using Surface, ` `\n3. To validate the form (e.g with `phx-change` for liveview), pass the submitted params to `AshPhoenix.Form.validate/3`\n4. On form submission, pass the params to `AshPhoenix.Form.submit/2`\n5. On success, use the result to redirect or assign. On failure, reassign the provided form.\n\nThe following keys exist on the form to show where in the lifecycle you are:\n\n- `submitted_once?` - If the form has ever been submitted. Useful for not showing any errors on the first attempt to fill out a form.\n- `just_submitted?` - If the form has just been submitted and *no validation* has happened since. Useful for things like\n  triggering a UI effect that should stop when the form is modified again.\n- `.changed?` - If something about the form is different than it originally was. Note that in some cases this can yield a\n  false positive, specifically if a nested form is removed and then a new one is added with the exact same values.\n- `.touched_forms` - A MapSet containing all keys in the form that have been modified. When submitting a form, only these keys are included in the parameters.","ref":"AshPhoenix.Form.html#module-life-cycle"},{"type":"module","title":"Working with related data - AshPhoenix.Form","doc":"If your resource action accepts related data, (for example a managed relationship argument, or an embedded resource attribute), you can\nuse Phoenix's `inputs_for` for that field, *but* you must do one of two things:\n\n1. Tell AshPhoenix.Form to automatically derive this behavior from your action, for example:\n\n```elixir\nform =\n  user\n  |> AshPhoenix.Form.for_update(:update, forms: [auto?: true])\n  |> to_form()\n```\n\n2. Explicitly configure the behavior of it using the `forms` option. See `for_create/3` for more.\n\nFor example:\n\n```elixir\nform =\n  user\n  |> AshPhoenix.Form.for_update(:update,\n    forms: [\n      profile: [\n        resource: MyApp.Profile,\n        data: user.profile,\n        create_action: :create,\n        update_action: :update\n        forms: [\n          emails: [\n            data: user.profile.emails,\n            resource: MyApp.UserEmail,\n            create_action: :create,\n            update_action: :update\n          ]\n        ]\n      ]\n    ])\n  |> to_form()\n```","ref":"AshPhoenix.Form.html#module-working-with-related-data"},{"type":"module","title":"LiveView - AshPhoenix.Form","doc":"`AshPhoenix.Form` (unlike ecto changeset based forms) expects to be reused throughout the lifecycle of the liveview.\n\nYou can use Phoenix events to add and remove form entries and `submit/2` to submit the form, like so:\n\n```elixir\ndef render(assigns) do\n  ~H\"\"\"\n  <.simple_form for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n    <%!-- Attributes for the parent resource --%>\n    <.input type=\"email\" label=\"Email\" field={@form[:email]} />\n    <%!-- Render nested forms for related data --%>\n    <.inputs_for :let={item_form} field={@form[:items]}>\n      <.input type=\"text\" label=\"Item\" field={item_form[:name]} />\n      <.input type=\"number\" label=\"Amount\" field={item_form[:amount]} />\n      <.button type=\"button\" phx-click=\"remove_form\" phx-value-path={item_form.name}>\n        Remove\n      </.button>\n    </.inputs_for>\n    <:actions>\n      <.button type=\"button\" phx-click=\"add_form\" phx-value-path={@form[:items].name}>\n        Add Item\n      </.button>\n      <.button>Save</.button>\n    </:actions>\n  </.simple_form>\n  \"\"\"\nend\n\ndef mount(_params, _session, socket) do\n  form =\n    MyApp.Grocery.Order\n    |> AshPhoenix.Form.for_create(:create,\n      forms: [\n        items: [\n          type: :list,\n          resource: MyApp.Grocery.Item,\n          create_action: :create\n        ]\n      ]\n    )\n    |> AshPhoenix.Form.add_form([:items])\n    |> to_form()\n\n  {:ok, assign(socket, form: form)}\nend\n\n# In order to use the `add_form` and `remove_form` helpers, you\n# need to make sure that you are validating the form on change\ndef handle_event(\"validate\", %{\"form\" => params}, socket) do\n  form = AshPhoenix.Form.validate(socket.assigns.form, params)\n  {:noreply, assign(socket, form: form)}\nend\n\ndef handle_event(\"submit\", %{\"form\" => params}, socket) do\n  case AshPhoenix.Form.submit(socket.assigns.form, params: params) do\n    {:ok, order} ->\n      {:noreply,\n       socket\n       |> put_flash(:info, \"Saved order for #{order.email}!\")\n       |> push_navigate(to: ~p\"/\")}\n\n    {:error, form} ->\n      {:noreply, assign(socket, form: form)}\n  end\nend\n\ndef handle_event(\"add_form\", %{\"path\" => path}, socket) do\n  form = AshPhoenix.Form.add_form(socket.assigns.form, path)\n  {:noreply, assign(socket, form: form)}\nend\n\ndef handle_event(\"remove_form\", %{\"path\" => path}, socket) do\n  form = AshPhoenix.Form.remove_form(socket.assigns.form, path)\n  {:noreply, assign(socket, form: form)}\nend\n```","ref":"AshPhoenix.Form.html#module-liveview"},{"type":"function","title":"AshPhoenix.Form.add_error/3","doc":"Adds an error to the source underlying the form.\n\nThis can be used for adding errors from different sources to a form. Keep in mind, if they don't match\na field on the form (typically extracted via the `field` key in the error), they won't be displayed by default.\n\n# Options\n\n- `:path` - The path to add the error to. If the error(s) already have a path, don't specify a path yourself.","ref":"AshPhoenix.Form.html#add_error/3"},{"type":"function","title":"AshPhoenix.Form.add_form/3","doc":"Adds a new form at the provided path.\n\nDoing this requires that the form has a `create_action` and a `resource` configured.\n\n`path` can be one of two things:\n\n1. A list of atoms and integers that lead to a form in the `forms` option provided. `[:posts, 0, :comments]` to add a comment to the first post.\n2. The html name of the form, e.g `form[posts][0][comments]` to mimic the above\n\nIf you pass parameters to this function, keep in mind that, unless they are string keyed in\nthe same shape they might come from your form, then the result of `params/1` will reflect that,\ni.e `add_form(form, \"foo\", params: %{bar: 10})`, could produce params like `%{\"field\" => value, \"foo\" => [%{bar: 10}]}`.\nNotice how they are not string keyed as you would expect. However, once the form is changed (in liveview) and a call\nto `validate/2` is made with that input, then the parameters would become what you'd expect. In this way, if you are using\n`add_form` with not string keys/values you may not be able to depend on the shape of the `params` map (which you should ideally\nnot depend on anyway).\n\n* `:prepend` (`t:boolean/0`) - If specified, the form is placed at the beginning of the list instead of the end of the list The default value is `false`.\n\n* `:params` (`t:term/0`) - The initial parameters to add the form with. The default value is `%{}`.\n\n* `:validate?` (`t:boolean/0`) - Validates the new full form. The default value is `true`.\n\n* `:validate_opts` (`t:term/0`) - Options to pass to `validate`. Only used if `validate?` is set to `true` (the default) The default value is `[]`.\n\n* `:type` - If `type` is set to `:read`, the form will be created for a read action. A hidden field will be set in the form called `_form_type` to track this information. Valid values are :read, :create, :update, :destroy The default value is `:create`.\n\n* `:data` (`t:term/0`) - The data to set backing the form. Generally you'd only want to do this if you are adding a form with `type: :read` additionally.","ref":"AshPhoenix.Form.html#add_form/3"},{"type":"function","title":"AshPhoenix.Form.arguments/1","doc":"A utility to get the list of arguments the action underlying the form accepts","ref":"AshPhoenix.Form.html#arguments/1"},{"type":"function","title":"AshPhoenix.Form.ash_errors/2","doc":"","ref":"AshPhoenix.Form.html#ash_errors/2"},{"type":"function","title":"AshPhoenix.Form.attributes/1","doc":"A utility to get the list of attributes the action underlying the form accepts","ref":"AshPhoenix.Form.html#attributes/1"},{"type":"function","title":"AshPhoenix.Form.can_submit?/1","doc":"","ref":"AshPhoenix.Form.html#can_submit?/1"},{"type":"function","title":"AshPhoenix.Form.clear_value/2","doc":"Clears a given input's value on a form.\n\nAccepts a field (atom) or a list of fields (atoms) as a second argument.","ref":"AshPhoenix.Form.html#clear_value/2"},{"type":"function","title":"AshPhoenix.Form.ensure_can_submit!/1","doc":"","ref":"AshPhoenix.Form.html#ensure_can_submit!/1"},{"type":"function","title":"AshPhoenix.Form.errors/2","doc":"Returns the errors on the form.\n\nBy default, only errors on the form being passed in (not nested forms) are provided.\nUse `for_path` to get errors for nested forms.\n\n* `:format` - Values:\n      - `:raw` - `[field:, {message, substitutions}}]` (for translation)\n      - `:simple` - `[field: \"message w/ variables substituted\"]`\n      - `:plaintext` - `[\"field: message w/ variables substituted\"]`\n   Valid values are :simple, :raw, :plaintext The default value is `:simple`.\n\n* `:for_path` (`t:term/0`) - The path of the form you want errors for, either as a list or as a string, e.g `[:comments, 0]` or `form[comments][0]`\n  Passing `:all` will cause this function to return a map of path to its errors, like so:  \n  `%{[:comments, 0] => [body: \"is invalid\"], ...}` The default value is `[]`.","ref":"AshPhoenix.Form.html#errors/2"},{"type":"function","title":"AshPhoenix.Form.for_action/3","doc":"Calls the corresponding `for_*` function depending on the action type","ref":"AshPhoenix.Form.html#for_action/3"},{"type":"function","title":"AshPhoenix.Form.for_create/3","doc":"Creates a form corresponding to a create action on a resource.","ref":"AshPhoenix.Form.html#for_create/3"},{"type":"function","title":"Options - AshPhoenix.Form.for_create/3","doc":"Options not listed below are passed to the underlying call to build the changeset/query, i.e `Ash.Changeset.for_create/4`\n\n* `:actor` (`t:term/0`) - The actor performing the action. Passed through to the underlying action.\n\n* `:forms` (`t:keyword/0`) - Nested form configurations. See `for_create/3` \"Nested Form Options\" docs for more.\n\n* `:warn_on_unhandled_errors?` (`t:boolean/0`) - Warns on any errors that don't match the form pattern of `{:field, \"message\", [replacement: :vars]}` or implement the `AshPhoenix.FormData.Error` protocol. The default value is `true`.\n\n* `:domain` (`t:atom/0`) - The domain to use when calling the action\n\n* `:as` (`t:String.t/0`) - The name of the form in the submitted params. You will need to pull the form params out using this key. The default value is `\"form\"`.\n\n* `:id` (`t:String.t/0`) - The html id of the form. Defaults to the value of `:as` if provided, otherwise \"form\"\n\n* `:transform_errors` (`t:term/0`) - Allows for manual manipulation and transformation of errors.  \n  If possible, try to implement `AshPhoenix.FormData.Error` for the error (if it as a custom one, for example).\n  If that isn't possible, you can provide this function which will get the changeset and the error, and should\n  return a list of ash phoenix formatted errors, e.g `[{field :: atom, message :: String.t(), substituations :: Keyword.t()}]`\n\n* `:prepare_source` - A 1-argument function the receives the initial changeset (or query) and makes any relevant changes to it.\n  This can be used to do things like:  \n  * Set default argument values before the validations are run using `Ash.Changeset.set_arguments/2` or `Ash.Changeset.set_argument/3`\n  * Set changeset context\n  * Do any other pre-processing on the changeset\n\n* `:prepare_params` - A 2-argument function that receives the params map and the :validate atom and should return prepared params.\n  Called before the form is validated.\n\n* `:transform_params` - A function for post-processing the form parameters before they are used for changeset validation/submission.\n  Use a 3-argument function to pattern match on the `AshPhoenix.Form` struct.\n\n* `:method` (`t:String.t/0`) - The http method to associate with the form. Defaults to `post` for creates, and `put` for everything else.\n\n* `:exclude_fields_if_empty` - These fields will be ignored if they are empty strings.  \n  This list of fields supports dead view forms. When a form is submitted from dead view\n  empty fields are submitted as empty strings. This is problematic for fields that allow_nil\n  or those that have default values.\n\n* `:tenant` (`t:term/0`) - The current tenant. Passed through to the underlying action.","ref":"AshPhoenix.Form.html#for_create/3-options"},{"type":"function","title":"Nested Form Options - AshPhoenix.Form.for_create/3","doc":"To automatically determine the nested forms available for a given form, use `forms: [auto?: true]`.\nYou can add additional nested forms by including them in the `forms` config alongside `auto?: true`.\nSee the module documentation of `AshPhoenix.Form.Auto` for more information. If you want to do some\nmanipulation of the auto forms, you can also call `AshPhoenix.Form.Auto.auto/2`, and then manipulate the\nresult and pass it to the `forms` option. To pass options, use `auto?: [option1: :value]`. See the\ndocumentation of `AshPhoenix.Form.Auto` for more.\n\n* `:type` - The cardinality of the nested form - `:list` or `:single`. Valid values are :list, :single The default value is `:single`.\n\n* `:sparse?` (`t:boolean/0`) - If the nested form is `sparse`, the form won't expect all inputs for all forms to be present.  \n  Has no effect if the type is `:single`.  \n  Normally, if you leave some forms out of a list of nested forms, they are removed from the parameters\n  passed to the action. For example, if you had a `post` with two comments `[%Comment{id: 1}, %Comment{id: 2}]`\n  and you passed down params like `comments[0][id]=1&comments[1][text]=new_text`, we would remove the second comment\n  from the input parameters, resulting in the following being passed into the action: `%{\"comments\" => [%{\"id\" => 1, \"text\" => \"new\"}]}`.\n  By setting it to sparse, you have to explicitly use `remove_form` for that removal to happen. So in the same scenario above, the parameters\n  that would be sent would actually be `%{\"comments\" => [%{\"id\" => 1, \"text\" => \"new\"}, %{\"id\" => 2}]}`.  \n  One major difference with `sparse?` is that the form actually ignores the *index* provided, e.g `comments[0]...`, and instead uses the primary\n  key e.g `comments[0][id]` to match which form is being updated. This prevents you from having to find the index of the specific item you want to\n  update. Which could be very gnarly on deeply nested forms. If there is no primary key, or the primary key does not match anything, it is treated\n  as a new form.  \n  REMEMBER: You need to use `Phoenix.Components.inputs_for` to render the nested forms, or manually add hidden inputs using\n  `hidden_inputs_for` (or `HiddenInputs` if using Surface) for the id to be automatically placed into the form.\n\n* `:forms` (`t:keyword/0`) - Forms nested inside the current nesting level in all cases\n\n* `:for_type` - What action types the form applies for. Leave blank for it to apply to all action types. Valid values are :read, :create, :update\n\n* `:merge?` (`t:boolean/0`) - When building parameters, this input will be merged with its parent input. This allows for combining multiple forms into a single input. The default value is `false`.\n\n* `:for` (`t:atom/0`) - When creating parameters for the action, the key that the forms should be gathered into. Defaults to the key used to configure the nested form. Ignored if `merge?` is `true`.\n\n* `:resource` (`t:atom/0`) - The resource of the nested forms. Unnecessary if you are providing the `data` key, and not adding additional forms to this path.\n\n* `:create_action` (`t:atom/0`) - The create action to use when building new forms. Only necessary if you want to use `add_form/3` with this path.\n\n* `:update_action` (`t:atom/0`) - The update action to use when building forms for data. Only necessary if you supply the `data` key.\n\n* `:data` (`t:term/0`) - The current value or values that should have update forms built by default.  \n  You can also provide a single argument function that will return the data based on the\n  data of the parent form. This is important for multiple nesting levels of `:list` type\n  forms, because the data depends on which parent is being rendered.","ref":"AshPhoenix.Form.html#for_create/3-nested-form-options"},{"type":"function","title":"AshPhoenix.Form.for_destroy/3","doc":"Creates a form corresponding to a destroy action on a record.\n\nOptions:\n* `:actor` (`t:term/0`) - The actor performing the action. Passed through to the underlying action.\n\n* `:forms` (`t:keyword/0`) - Nested form configurations. See `for_create/3` \"Nested Form Options\" docs for more.\n\n* `:warn_on_unhandled_errors?` (`t:boolean/0`) - Warns on any errors that don't match the form pattern of `{:field, \"message\", [replacement: :vars]}` or implement the `AshPhoenix.FormData.Error` protocol. The default value is `true`.\n\n* `:domain` (`t:atom/0`) - The domain to use when calling the action\n\n* `:as` (`t:String.t/0`) - The name of the form in the submitted params. You will need to pull the form params out using this key. The default value is `\"form\"`.\n\n* `:id` (`t:String.t/0`) - The html id of the form. Defaults to the value of `:as` if provided, otherwise \"form\"\n\n* `:transform_errors` (`t:term/0`) - Allows for manual manipulation and transformation of errors.  \n  If possible, try to implement `AshPhoenix.FormData.Error` for the error (if it as a custom one, for example).\n  If that isn't possible, you can provide this function which will get the changeset and the error, and should\n  return a list of ash phoenix formatted errors, e.g `[{field :: atom, message :: String.t(), substituations :: Keyword.t()}]`\n\n* `:prepare_source` - A 1-argument function the receives the initial changeset (or query) and makes any relevant changes to it.\n  This can be used to do things like:  \n  * Set default argument values before the validations are run using `Ash.Changeset.set_arguments/2` or `Ash.Changeset.set_argument/3`\n  * Set changeset context\n  * Do any other pre-processing on the changeset\n\n* `:prepare_params` - A 2-argument function that receives the params map and the :validate atom and should return prepared params.\n  Called before the form is validated.\n\n* `:transform_params` - A function for post-processing the form parameters before they are used for changeset validation/submission.\n  Use a 3-argument function to pattern match on the `AshPhoenix.Form` struct.\n\n* `:method` (`t:String.t/0`) - The http method to associate with the form. Defaults to `post` for creates, and `put` for everything else.\n\n* `:exclude_fields_if_empty` - These fields will be ignored if they are empty strings.  \n  This list of fields supports dead view forms. When a form is submitted from dead view\n  empty fields are submitted as empty strings. This is problematic for fields that allow_nil\n  or those that have default values.\n\n* `:tenant` (`t:term/0`) - The current tenant. Passed through to the underlying action.\n\n\n\nAny *additional* options will be passed to the underlying call to `Ash.Changeset.for_destroy/4`. This means\nyou can set things like the tenant/actor. These will be retained, and provided again when `Form.submit/3` is called.","ref":"AshPhoenix.Form.html#for_destroy/3"},{"type":"function","title":"AshPhoenix.Form.for_read/3","doc":"Creates a form corresponding to a read action on a resource.\n\nOptions:\n* `:actor` (`t:term/0`) - The actor performing the action. Passed through to the underlying action.\n\n* `:forms` (`t:keyword/0`) - Nested form configurations. See `for_create/3` \"Nested Form Options\" docs for more.\n\n* `:warn_on_unhandled_errors?` (`t:boolean/0`) - Warns on any errors that don't match the form pattern of `{:field, \"message\", [replacement: :vars]}` or implement the `AshPhoenix.FormData.Error` protocol. The default value is `true`.\n\n* `:domain` (`t:atom/0`) - The domain to use when calling the action\n\n* `:as` (`t:String.t/0`) - The name of the form in the submitted params. You will need to pull the form params out using this key. The default value is `\"form\"`.\n\n* `:id` (`t:String.t/0`) - The html id of the form. Defaults to the value of `:as` if provided, otherwise \"form\"\n\n* `:transform_errors` (`t:term/0`) - Allows for manual manipulation and transformation of errors.  \n  If possible, try to implement `AshPhoenix.FormData.Error` for the error (if it as a custom one, for example).\n  If that isn't possible, you can provide this function which will get the changeset and the error, and should\n  return a list of ash phoenix formatted errors, e.g `[{field :: atom, message :: String.t(), substituations :: Keyword.t()}]`\n\n* `:prepare_source` - A 1-argument function the receives the initial changeset (or query) and makes any relevant changes to it.\n  This can be used to do things like:  \n  * Set default argument values before the validations are run using `Ash.Changeset.set_arguments/2` or `Ash.Changeset.set_argument/3`\n  * Set changeset context\n  * Do any other pre-processing on the changeset\n\n* `:prepare_params` - A 2-argument function that receives the params map and the :validate atom and should return prepared params.\n  Called before the form is validated.\n\n* `:transform_params` - A function for post-processing the form parameters before they are used for changeset validation/submission.\n  Use a 3-argument function to pattern match on the `AshPhoenix.Form` struct.\n\n* `:method` (`t:String.t/0`) - The http method to associate with the form. Defaults to `post` for creates, and `put` for everything else.\n\n* `:exclude_fields_if_empty` - These fields will be ignored if they are empty strings.  \n  This list of fields supports dead view forms. When a form is submitted from dead view\n  empty fields are submitted as empty strings. This is problematic for fields that allow_nil\n  or those that have default values.\n\n* `:tenant` (`t:term/0`) - The current tenant. Passed through to the underlying action.\n\n\n\nAny *additional* options will be passed to the underlying call to `Ash.Query.for_read/4`. This means\nyou can set things like the tenant/actor. These will be retained, and provided again when `Form.submit/3` is called.\n\nKeep in mind that the `source` of the form in this case is a query, not a changeset. This means that, very likely,\nyou would not want to use nested forms here. However, it could make sense if you had a query argument that was an\nembedded resource, so the capability remains.","ref":"AshPhoenix.Form.html#for_read/3"},{"type":"function","title":"Nested Form Options - AshPhoenix.Form.for_read/3","doc":"* `:type` - The cardinality of the nested form - `:list` or `:single`. Valid values are :list, :single The default value is `:single`.\n\n* `:sparse?` (`t:boolean/0`) - If the nested form is `sparse`, the form won't expect all inputs for all forms to be present.  \n  Has no effect if the type is `:single`.  \n  Normally, if you leave some forms out of a list of nested forms, they are removed from the parameters\n  passed to the action. For example, if you had a `post` with two comments `[%Comment{id: 1}, %Comment{id: 2}]`\n  and you passed down params like `comments[0][id]=1&comments[1][text]=new_text`, we would remove the second comment\n  from the input parameters, resulting in the following being passed into the action: `%{\"comments\" => [%{\"id\" => 1, \"text\" => \"new\"}]}`.\n  By setting it to sparse, you have to explicitly use `remove_form` for that removal to happen. So in the same scenario above, the parameters\n  that would be sent would actually be `%{\"comments\" => [%{\"id\" => 1, \"text\" => \"new\"}, %{\"id\" => 2}]}`.  \n  One major difference with `sparse?` is that the form actually ignores the *index* provided, e.g `comments[0]...`, and instead uses the primary\n  key e.g `comments[0][id]` to match which form is being updated. This prevents you from having to find the index of the specific item you want to\n  update. Which could be very gnarly on deeply nested forms. If there is no primary key, or the primary key does not match anything, it is treated\n  as a new form.  \n  REMEMBER: You need to use `Phoenix.Components.inputs_for` to render the nested forms, or manually add hidden inputs using\n  `hidden_inputs_for` (or `HiddenInputs` if using Surface) for the id to be automatically placed into the form.\n\n* `:forms` (`t:keyword/0`) - Forms nested inside the current nesting level in all cases\n\n* `:for_type` - What action types the form applies for. Leave blank for it to apply to all action types. Valid values are :read, :create, :update\n\n* `:merge?` (`t:boolean/0`) - When building parameters, this input will be merged with its parent input. This allows for combining multiple forms into a single input. The default value is `false`.\n\n* `:for` (`t:atom/0`) - When creating parameters for the action, the key that the forms should be gathered into. Defaults to the key used to configure the nested form. Ignored if `merge?` is `true`.\n\n* `:resource` (`t:atom/0`) - The resource of the nested forms. Unnecessary if you are providing the `data` key, and not adding additional forms to this path.\n\n* `:create_action` (`t:atom/0`) - The create action to use when building new forms. Only necessary if you want to use `add_form/3` with this path.\n\n* `:update_action` (`t:atom/0`) - The update action to use when building forms for data. Only necessary if you supply the `data` key.\n\n* `:data` (`t:term/0`) - The current value or values that should have update forms built by default.  \n  You can also provide a single argument function that will return the data based on the\n  data of the parent form. This is important for multiple nesting levels of `:list` type\n  forms, because the data depends on which parent is being rendered.","ref":"AshPhoenix.Form.html#for_read/3-nested-form-options"},{"type":"function","title":"AshPhoenix.Form.for_update/3","doc":"Creates a form corresponding to an update action on a record.\n\nOptions:\n* `:actor` (`t:term/0`) - The actor performing the action. Passed through to the underlying action.\n\n* `:forms` (`t:keyword/0`) - Nested form configurations. See `for_create/3` \"Nested Form Options\" docs for more.\n\n* `:warn_on_unhandled_errors?` (`t:boolean/0`) - Warns on any errors that don't match the form pattern of `{:field, \"message\", [replacement: :vars]}` or implement the `AshPhoenix.FormData.Error` protocol. The default value is `true`.\n\n* `:domain` (`t:atom/0`) - The domain to use when calling the action\n\n* `:as` (`t:String.t/0`) - The name of the form in the submitted params. You will need to pull the form params out using this key. The default value is `\"form\"`.\n\n* `:id` (`t:String.t/0`) - The html id of the form. Defaults to the value of `:as` if provided, otherwise \"form\"\n\n* `:transform_errors` (`t:term/0`) - Allows for manual manipulation and transformation of errors.  \n  If possible, try to implement `AshPhoenix.FormData.Error` for the error (if it as a custom one, for example).\n  If that isn't possible, you can provide this function which will get the changeset and the error, and should\n  return a list of ash phoenix formatted errors, e.g `[{field :: atom, message :: String.t(), substituations :: Keyword.t()}]`\n\n* `:prepare_source` - A 1-argument function the receives the initial changeset (or query) and makes any relevant changes to it.\n  This can be used to do things like:  \n  * Set default argument values before the validations are run using `Ash.Changeset.set_arguments/2` or `Ash.Changeset.set_argument/3`\n  * Set changeset context\n  * Do any other pre-processing on the changeset\n\n* `:prepare_params` - A 2-argument function that receives the params map and the :validate atom and should return prepared params.\n  Called before the form is validated.\n\n* `:transform_params` - A function for post-processing the form parameters before they are used for changeset validation/submission.\n  Use a 3-argument function to pattern match on the `AshPhoenix.Form` struct.\n\n* `:method` (`t:String.t/0`) - The http method to associate with the form. Defaults to `post` for creates, and `put` for everything else.\n\n* `:exclude_fields_if_empty` - These fields will be ignored if they are empty strings.  \n  This list of fields supports dead view forms. When a form is submitted from dead view\n  empty fields are submitted as empty strings. This is problematic for fields that allow_nil\n  or those that have default values.\n\n* `:tenant` (`t:term/0`) - The current tenant. Passed through to the underlying action.\n\n\n\nAny *additional* options will be passed to the underlying call to `Ash.Changeset.for_update/4`. This means\nyou can set things like the tenant/actor. These will be retained, and provided again when `Form.submit/3` is called.","ref":"AshPhoenix.Form.html#for_update/3"},{"type":"function","title":"AshPhoenix.Form.get_form/2","doc":"Gets the form at the specified path","ref":"AshPhoenix.Form.html#get_form/2"},{"type":"function","title":"AshPhoenix.Form.has_form?/2","doc":"Returns true if a given form path exists in the form","ref":"AshPhoenix.Form.html#has_form?/2"},{"type":"function","title":"AshPhoenix.Form.hidden_fields/1","doc":"Returns the hidden fields for a form as a keyword list","ref":"AshPhoenix.Form.html#hidden_fields/1"},{"type":"function","title":"AshPhoenix.Form.ignore/1","doc":"Toggles the form to be ignored or not ignored.\n\nTo set this manually in an html form, use the field `:_ignored` and set it\nto the string \"true\". Any other value will not result in the form being ignored.","ref":"AshPhoenix.Form.html#ignore/1"},{"type":"function","title":"AshPhoenix.Form.ignored?/1","doc":"Returns true if the form is ignored","ref":"AshPhoenix.Form.html#ignored?/1"},{"type":"function","title":"AshPhoenix.Form.merge_options/2","doc":"Merge the new options with the saved options on a form. See `update_options/2` for more.","ref":"AshPhoenix.Form.html#merge_options/2"},{"type":"function","title":"AshPhoenix.Form.params/2","doc":"Returns the parameters from the form that would be submitted to the action.\n\nThis can be useful if you want to get the parameters and manipulate them/build a custom changeset\nafterwards.","ref":"AshPhoenix.Form.html#params/2"},{"type":"function","title":"AshPhoenix.Form.parse_path!/3","doc":"A utility for parsing paths of nested forms in query encoded format.\n\nFor example:\n\n```elixir\nparse_path!(form, \"post[comments][0][sub_comments][0])\n\n[:comments, 0, :sub_comments, 0]\n```","ref":"AshPhoenix.Form.html#parse_path!/3"},{"type":"function","title":"AshPhoenix.Form.remove_form/3","doc":"Removes a form at the provided path.\n\nSee `add_form/3` for more information on the `path` argument.\n\nIf you are not using liveview, and you want to support removing forms that were created based on the `data`\noption from the browser, you'll need to include in the form submission a custom list of strings to remove, and\nthen manually iterate over them in your controller, for example:\n\n```elixir\nEnum.reduce(removed_form_paths, form, &AshPhoenix.Form.remove_form(&2, &1))\n```\n\n* `:validate?` (`t:boolean/0`) - Validates the new full form. The default value is `true`.\n\n* `:validate_opts` (`t:term/0`) - Options to pass to `validate`. Only used if `validate?` is set to `true` (the default) The default value is `[]`.","ref":"AshPhoenix.Form.html#remove_form/3"},{"type":"function","title":"AshPhoenix.Form.set_data/2","doc":"Sets the data of the form, in addition to the data of the underlying source, if applicable.\n\nQueries do not track data (because that wouldn't make sense), so this will not update the data\nfor read actions","ref":"AshPhoenix.Form.html#set_data/2"},{"type":"function","title":"AshPhoenix.Form.submit/2","doc":"Submits the form.\n\nIf the submission returns an error, the resulting form can be rerendered. Any nested\nerrors will be passed down to the corresponding form for that input.\n\nOptions:\n\n* `:force?` (`t:boolean/0`) - Submit the form even if it is invalid in its current state. The default value is `false`.\n\n* `:action_opts` (`t:keyword/0`) - Opts to pass to the call to Ash when calling the action The default value is `[]`.\n\n* `:errors` (`t:boolean/0`) - Wether or not to show errors after submitting. The default value is `true`.\n\n* `:override_params` (`t:term/0`) - If specified, then the params are not extracted from the form.  \n  How this different from `params`: providing `params` is simply results in calling `validate(form, params)` before proceeding.\n  The values that are passed into the action are then extracted from the form using `params/2`. With `override_params`, the form\n  is not validated again, and the `override_params` are passed directly into the action.\n\n* `:params` (`t:term/0`) - If specified, `validate/3` is called with the new params before submitting the form.  \n  This is a shortcut to avoid needing to explicitly validate before every submit.  \n  For example:  \n  ```elixir\n  form\n  |> AshPhoenix.Form.validate(params)\n  |> AshPhoenix.Form.submit()\n  ```  \n  Is the same as:  \n  ```elixir\n  form\n  |> AshPhoenix.Form.submit(params: params)\n  ```\n\n* `:read_one?` (`t:boolean/0`) - If submitting a read form, a single result will be returned (via read_one) instead of a list of results.  \n  Ignored for non-read forms. The default value is `false`.\n\n* `:before_submit` (function of arity 1) - A function to apply to the source (changeset or query) just before submitting the action. Must return the modified changeset.","ref":"AshPhoenix.Form.html#submit/2"},{"type":"function","title":"AshPhoenix.Form.submit!/2","doc":"Same as `submit/2`, but raises an error if the submission fails.","ref":"AshPhoenix.Form.html#submit!/2"},{"type":"function","title":"AshPhoenix.Form.touch/2","doc":"Mark a field or fields as touched\n\nTo mark nested fields as touched use with `update_form/4` or `update_forms_at_path/4`","ref":"AshPhoenix.Form.html#touch/2"},{"type":"function","title":"AshPhoenix.Form.update_form/4","doc":"Updates the form at the provided path using the given function.\n\nMarks all forms along the path as touched by default. To prevent it, provide `mark_as_touched?: false`.\n\nThis can be useful if you have a button that should modify a nested form in some way, for example.","ref":"AshPhoenix.Form.html#update_form/4"},{"type":"function","title":"AshPhoenix.Form.update_forms_at_path/4","doc":"Updates the list of forms matching a given path. Does not validate that the path points at a single form like `update_form/4`.\n\nAdditionally, if it gets to a list of child forms and the next part of the path is not an integer,\nit will update all of the forms at that path.","ref":"AshPhoenix.Form.html#update_forms_at_path/4"},{"type":"function","title":"AshPhoenix.Form.update_options/2","doc":"Update the saved options on a form.\n\nWhen a form is created, options like `actor` and `authorize?` are stored in the `opts` key.\nIf you have a case where these options change over time, for example a select box that determines the actor, use this function to override those opts.\n\nYou may want to validate again after this has been changed if it can change the results of your form validation.","ref":"AshPhoenix.Form.html#update_options/2"},{"type":"function","title":"AshPhoenix.Form.validate/3","doc":"Validates the parameters against the form.\n\nOptions:\n\n* `:errors` (`t:boolean/0`) - Set to false to hide errors after validation The default value is `true`.\n\n* `:target` (list of `t:String.t/0`) - The `_target` param provided by phoenix. Used to support the `only_touched?` option.\n\n* `:only_touched?` (`t:boolean/0`) - If set to true, only fields that have been marked as touched will be used  \n  If you use this for validation you likely want to use it when submitting as well. The default value is `false`.","ref":"AshPhoenix.Form.html#validate/3"},{"type":"function","title":"AshPhoenix.Form.value/2","doc":"Gets the value for a given field in the form.","ref":"AshPhoenix.Form.html#value/2"},{"type":"type","title":"AshPhoenix.Form.path/0","doc":"","ref":"AshPhoenix.Form.html#t:path/0"},{"type":"type","title":"AshPhoenix.Form.t/0","doc":"","ref":"AshPhoenix.Form.html#t:t/0"},{"type":"module","title":"AshPhoenix.Form.Auto","doc":"A tool to automatically generate available nested forms based on a resource and action.\n\nTo use this, specify `forms: [auto?: true]` when creating the form.\n\nKeep in mind, you can always specify these manually when creating a form by simply specifying the `forms` option.\n\nThere are two things that this builds forms for:\n\n1. Attributes/arguments who's type is an embedded resource.\n2. Arguments that have a corresponding `change manage_relationship(..)` configured.\n\nFor more on relationships see the documentation for `Ash.Changeset.manage_relationship/4`.\n\nWhen building forms, you can switch on the action type and/or resource of the form, in order to have different\nfields depending on the form. For example, if you have a simple relationship called `:comments` with\n`on_match: :update` and `on_no_match: :create`, there are two types of forms that can be in `inputs_for(form, :comments)`.\n\nIn which case you may have something like this:\n\n```elixir\n<%= for comment_form <- inputs_for(f, :comments) do %>\n  <%= hidden_inputs_for(comment_form) %>\n  <%= if comment_form.source.type == :create do %>\n    <%= text_input comment_form, :text %>\n    <%= text_input comment_form, :on_create_field %>\n  <% else %>\n    <%= text_input comment_form, :text %>\n    <%= text_input comment_form, :on_update_field %>\n  <% end %>\n\n   Add Comment \n   Add Comment \n<% end %>\n```\n\nThis also applies to adding forms of different types manually. For instance, if you had a \"search\" field\nto allow them to search for a record (e.g in a liveview), and you had an `on_lookup` read action, you could\nrender a search form for that read action, and once they've selected a record, you could render the fields\nto update that record (in the case of `on_lookup: :relate_and_update` configurations).","ref":"AshPhoenix.Form.Auto.html"},{"type":"module","title":"Options - AshPhoenix.Form.Auto","doc":"* `:relationship_fetcher` (`t:term/0`) - A two argument function that receives the parent data, the relationship to fetch.\n  The default simply fetches the relationship value, and if it isn't loaded, it uses `[]` or `nil`.\n\n* `:sparse_lists?` (`t:boolean/0`) - Sets all list type forms to `sparse?: true` by default. Has no effect on forms derived for embedded resources. The default value is `false`.\n\n* `:include_non_map_types?` (`t:boolean/0`) - Creates form for non map or array of map type inputs The default value is `false`.","ref":"AshPhoenix.Form.Auto.html#module-options"},{"type":"module","title":"Special Considerations - AshPhoenix.Form.Auto","doc":"### `on_lookup: :relate_and_update`\n\nFor `on_lookup: :relate_and_update` configurations, the \"read\" form for that relationship will use the appropriate read action.\nHowever, you may also want to include the relevant fields for the update that would subsequently occur. To that end, a special\nnested form called `:_update` is created, that uses an empty instance of that resource as the base of its changeset. This may require\nsome manual manipulation of that data before rendering the relevant form because it assumes all the default values. To solve for this,\nif you are using liveview, you could actually look up the record using the input from the read action, and then use `AshPhoenix.Form.update_form/3`\nto set that looked up record as the data of the `_update` form.","ref":"AshPhoenix.Form.Auto.html#module-special-considerations"},{"type":"module","title":"Many to Many Relationships - AshPhoenix.Form.Auto","doc":"In the case that a manage_change option points to a join relationship, that form is presented via a special nested form called\n`_join`. So the first form in `inputs_for(form, :relationship)` would be for the destination, and then inside of that you could say\n`inputs_for(nested_form, :_join)`. The parameters are merged together during submission.","ref":"AshPhoenix.Form.Auto.html#module-many-to-many-relationships"},{"type":"function","title":"AshPhoenix.Form.Auto.auto/3","doc":"","ref":"AshPhoenix.Form.Auto.html#auto/3"},{"type":"function","title":"AshPhoenix.Form.Auto.embedded/3","doc":"","ref":"AshPhoenix.Form.Auto.html#embedded/3"},{"type":"function","title":"AshPhoenix.Form.Auto.related/3","doc":"","ref":"AshPhoenix.Form.Auto.html#related/3"},{"type":"function","title":"AshPhoenix.Form.Auto.unions/3","doc":"","ref":"AshPhoenix.Form.Auto.html#unions/3"},{"type":"module","title":"AshPhoenix.Form.WrappedValue","doc":"A sentinal value used when editing a union that has non-map values","ref":"AshPhoenix.Form.WrappedValue.html"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.apply_constraints_array/2","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#apply_constraints_array/2"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.cast_input/2","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#cast_input/2"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.cast_stored/2","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#cast_stored/2"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.check_atomic/2","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#check_atomic/2"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.default_short_name/0","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#default_short_name/0"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.dump_to_native/2","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#dump_to_native/2"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.fetch_key/2","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#fetch_key/2"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.get_rewrites/4","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#get_rewrites/4"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.handle_change_array/3","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#handle_change_array/3"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.input/1","doc":"Validates that the keys in the provided input are valid for at least one action on the resource.\n\nRaises a KeyError error at compile time if not. This exists because generally a struct should only ever\nbe created by Ash as a result of a successful action. You should not be creating records manually in code,\ne.g `%MyResource{value: 1, value: 2}`. Generally that is fine, but often with embedded resources it is nice\nto be able to validate the keys that are being provided, e.g\n\n```elixir\nResource\n|> Ash.Changeset.for_create(:create, %{embedded: EmbeddedResource.input(foo: 1, bar: 2)})\n|> Ash.create()\n```","ref":"AshPhoenix.Form.WrappedValue.html#input/1"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.input/2","doc":"Same as `input/1`, except restricts the keys to values accepted by the action provided.","ref":"AshPhoenix.Form.WrappedValue.html#input/2"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.load/4","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#load/4"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.prepare_change_array/3","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#prepare_change_array/3"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.rewrite/3","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#rewrite/3"},{"type":"function","title":"AshPhoenix.Form.WrappedValue.storage_type/1","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#storage_type/1"},{"type":"type","title":"AshPhoenix.Form.WrappedValue.t/0","doc":"","ref":"AshPhoenix.Form.WrappedValue.html#t:t/0"},{"type":"protocol","title":"AshPhoenix.FormData.Error","doc":"A protocol for allowing errors to be rendered into a form.\n\nTo implement, define a `to_form_error/1` and return a single error or list of errors of the following shape:\n\n`{:field_name, message, replacements}`\n\nReplacements is a keyword list to allow for translations, by extracting out the constants like numbers from the message.","ref":"AshPhoenix.FormData.Error.html"},{"type":"function","title":"AshPhoenix.FormData.Error.to_form_error/1","doc":"","ref":"AshPhoenix.FormData.Error.html#to_form_error/1"},{"type":"type","title":"AshPhoenix.FormData.Error.t/0","doc":"All the types that implement this protocol.","ref":"AshPhoenix.FormData.Error.html#t:t/0"},{"type":"module","title":"AshPhoenix.FilterForm","doc":"A module to help you create complex forms that generate Ash filters.\n\n```elixir\n# Create a FilterForm\nfilter_form = AshPhoenix.FilterForm.new(MyApp.Payroll.Employee)\n```\n\nFilterForm's comprise 2 concepts, predicates and groups. Predicates are the simple boolean\nexpressions you can use to build a query (`name == \"Joe\"`), and groups can be used to group\npredicates and more groups together. Groups can apply `and` or `or` operators to its nested\ncomponents.\n\n```elixir\n# Add a predicate to the root of the form (which is itself a group)\nfilter_form = AshPhoenix.add_predicate(filter_form, :some_field, :eq, \"Some Value\")\n\n# Add a group and another predicate to that group\n{filter_form, group_id} = AshPhoenix.add_group(filter_form, operator: :or, return_id?: true)\nfilter_form = AshPhoenix.add_predicate(filter_form, :another, :eq, \"Other\", to: group_id)\n```\n\n`validate/1` is used to merge the submitted form params into the filter form, and one of the\nprovided filter functions to apply the filter as a query, or generate an expression map,\ndepending on your requirements:\n\n```elixir\nfilter_form = AshPhoenix.validate(socket.assigns.filter_form, params)\n\n# Generate a query and pass it to the Domain\nquery = AshPhoenix.FilterForm.filter!(MyApp.Payroll.Employee, filter_form)\nfiltered_employees = MyApp.Payroll.read!(query)\n\n# Or use one of the other filter functions\nAshPhoenix.FilterForm.to_filter_expression(filter_form)\nAshPhoenix.FilterForm.to_filter_map(filter_form)\n```","ref":"AshPhoenix.FilterForm.html"},{"type":"module","title":"LiveView Example - AshPhoenix.FilterForm","doc":"You can build a form and handle adding and removing nested groups and predicates with the following:\n\n```elixir\nalias MyApp.Payroll.Employee\n\n@impl true\ndef render(assigns) do\n  ~H\"\"\"\n  <.simple_form\n    :let={filter_form}\n    for={@filter_form}\n    phx-change=\"filter_validate\"\n    phx-submit=\"filter_submit\"\n  >\n    <.filter_form_component component={filter_form} />\n    <:actions>\n      <.button>Submit</.button>\n    </:actions>\n  </.simple_form>\n  <.table id=\"employees\" rows={@employees}>\n    <:col :let={employee} label=\"Payroll ID\"><%= employee.employee_id %></:col>\n    <:col :let={employee} label=\"Name\"><%= employee.name %></:col>\n    <:col :let={employee} label=\"Position\"><%= employee.position %></:col>\n  </.table>\n  \"\"\"\nend\n\nattr :component, :map, required: true, doc: \"Could be a FilterForm (group) or a Predicate\"\n\ndefp filter_form_component(%{component: %{source: %AshPhoenix.FilterForm{}}} = assigns) do\n  ~H\"\"\"\n   \n     \n       Filter \n       \n        <.input type=\"select\" field={@component[:operator]} options={[\"and\", \"or\"]} />\n        <.button phx-click=\"add_filter_group\" phx-value-component-id={@component.source.id} type=\"button\">\n          Add Group\n        </.button>\n        <.button\n          phx-click=\"add_filter_predicate\"\n          phx-value-component-id={@component.source.id}\n          type=\"button\"\n        >\n          Add Predicate\n        </.button>\n        <.button\n          phx-click=\"remove_filter_component\"\n          phx-value-component-id={@component.source.id}\n          type=\"button\"\n        >\n          Remove Group\n        </.button>\n       \n     \n    <.inputs_for :let={component} field={@component[:components]}>\n      <.filter_form_component component={component} />\n    </.inputs_for>\n   \n  \"\"\"\nend\n\ndefp filter_form_component(\n       %{component: %{source: %AshPhoenix.FilterForm.Predicate{}}} = assigns\n     ) do\n  ~H\"\"\"\n   \n    <.input\n      type=\"select\"\n      options={AshPhoenix.FilterForm.fields(Employee)}\n      field={@component[:field]}\n    />\n    <.input\n      type=\"select\"\n      options={AshPhoenix.FilterForm.predicates(Employee)}\n      field={@component[:operator]}\n    />\n    <.input field={@component[:value]} />\n    <.button\n      phx-click=\"remove_filter_component\"\n      phx-value-component-id={@component.source.id}\n      type=\"button\"\n    >\n      Remove\n    </.button>\n   \n  \"\"\"\nend\n\n@impl true\ndef mount(_params, _session, socket) do\n  socket =\n    socket\n    |> assign(:filter_form, AshPhoenix.FilterForm.new(Employee))\n    |> assign(:employees, Employee.read_all!())\n\n  {:ok, socket}\nend\n\n@impl true\ndef handle_event(\"filter_validate\", %{\"filter\" => params}, socket) do\n  {:noreply,\n   assign(socket,\n     filter_form: AshPhoenix.FilterForm.validate(socket.assigns.filter_form, params)\n   )}\nend\n\ndef handle_event(\"filter_submit\", %{\"filter\" => params}, socket) do\n  filter_form = AshPhoenix.FilterForm.validate(socket.assigns.filter_form, params)\n\n  case AshPhoenix.FilterForm.filter(Employee, filter_form) do\n    {:ok, query} ->\n      {:noreply,\n       socket\n       |> assign(:employees, Employee.read_all!(query: query))\n       |> assign(:filter_form, filter_form)}\n\n    {:error, filter_form} ->\n      {:noreply, assign(socket, filter_form: filter_form)}\n  end\nend\n\ndef handle_event(\"remove_filter_component\", %{\"component-id\" => component_id}, socket) do\n  {:noreply,\n   assign(socket,\n     filter_form:\n       AshPhoenix.FilterForm.remove_component(socket.assigns.filter_form, component_id)\n   )}\nend\n\ndef handle_event(\"add_filter_group\", %{\"component-id\" => component_id}, socket) do\n  {:noreply,\n   assign(socket,\n     filter_form: AshPhoenix.FilterForm.add_group(socket.assigns.filter_form, to: component_id)\n   )}\nend\n\ndef handle_event(\"add_filter_predicate\", %{\"component-id\" => component_id}, socket) do\n  {:noreply,\n   assign(socket,\n     filter_form:\n       AshPhoenix.FilterForm.add_predicate(socket.assigns.filter_form, :name, :contains, nil,\n         to: component_id\n       )\n   )}\nend\n```","ref":"AshPhoenix.FilterForm.html#module-liveview-example"},{"type":"function","title":"AshPhoenix.FilterForm.add_group/2","doc":"Add a group to the filter. A group can contain predicates and other groups,\nallowing you to build quite complex nested filters.\n\nOptions:\n\n* `:to` (`t:String.t/0`) - The nested group id to add the group to.\n\n* `:operator` - The operator that the group should have internally. Valid values are :and, :or The default value is `:and`.\n\n* `:return_id?` (`t:boolean/0`) - If set to `true`, the function returns `{form, predicate_id}` The default value is `false`.","ref":"AshPhoenix.FilterForm.html#add_group/2"},{"type":"function","title":"AshPhoenix.FilterForm.add_predicate/5","doc":"Add a predicate to the filter.\n\nOptions:\n\n* `:to` (`t:String.t/0`) - The group id to add the predicate to. If not set, will be added to the top level group.\n\n* `:return_id?` (`t:boolean/0`) - If set to `true`, the function returns `{form, predicate_id}` The default value is `false`.\n\n* `:path` - The relationship path to apply the predicate to","ref":"AshPhoenix.FilterForm.html#add_predicate/5"},{"type":"function","title":"AshPhoenix.FilterForm.errors/2","doc":"Returns a flat list of all errors on all predicates in the filter.","ref":"AshPhoenix.FilterForm.html#errors/2"},{"type":"function","title":"AshPhoenix.FilterForm.fields/1","doc":"Returns the list of available fields, which may be attributes, calculations, or aggregates.","ref":"AshPhoenix.FilterForm.html#fields/1"},{"type":"function","title":"AshPhoenix.FilterForm.filter/2","doc":"Converts the form into a filter, and filters the provided query or resource with that filter.","ref":"AshPhoenix.FilterForm.html#filter/2"},{"type":"function","title":"AshPhoenix.FilterForm.filter!/2","doc":"Same as `filter/2` but raises on errors.","ref":"AshPhoenix.FilterForm.html#filter!/2"},{"type":"function","title":"AshPhoenix.FilterForm.new/2","doc":"Create a new filter form.\n\nOptions:\n* `:params` (`t:term/0`) - Initial parameters to create the form with The default value is `%{}`.\n\n* `:as` (`t:String.t/0`) - Set the parameter name for the form. The default value is `\"filter\"`.\n\n* `:transform_errors` (`t:term/0`) - Allows for manual manipulation and transformation of errors.  \n  If possible, try to implement `AshPhoenix.FormData.Error` for the error (if it as a custom one, for example).\n  If that isn't possible, you can provide this function which will get the predicate and the error, and should\n  return a list of ash phoenix formatted errors, e.g `[{field :: atom, message :: String.t(), substituations :: Keyword.t()}]`\n\n* `:remove_empty_groups?` (`t:boolean/0`) - If true (the default), then any time a group would be made empty by removing a group or predicate, it is removed instead.  \n  An empty form can still be added, this only affects a group if its last component is removed. The default value is `false`.","ref":"AshPhoenix.FilterForm.html#new/2"},{"type":"function","title":"AshPhoenix.FilterForm.params_for_query/1","doc":"Returns the minimal set of params (at the moment just strips ids) for use in a query string.","ref":"AshPhoenix.FilterForm.html#params_for_query/1"},{"type":"function","title":"AshPhoenix.FilterForm.predicates/1","doc":"Returns the list of available predicates for the given resource, which may be functions or operators.","ref":"AshPhoenix.FilterForm.html#predicates/1"},{"type":"function","title":"AshPhoenix.FilterForm.remove_component/2","doc":"Removes the group *or* predicate with the given id","ref":"AshPhoenix.FilterForm.html#remove_component/2"},{"type":"function","title":"AshPhoenix.FilterForm.remove_group/2","doc":"Remove the group with the given id","ref":"AshPhoenix.FilterForm.html#remove_group/2"},{"type":"function","title":"AshPhoenix.FilterForm.remove_predicate/2","doc":"Remove the predicate with the given id","ref":"AshPhoenix.FilterForm.html#remove_predicate/2"},{"type":"function","title":"AshPhoenix.FilterForm.to_filter!/1","doc":"","ref":"AshPhoenix.FilterForm.html#to_filter!/1"},{"type":"function","title":"AshPhoenix.FilterForm.to_filter_expression/1","doc":"Returns a filter expression that can be provided to Ash.Query.filter/2\n\nTo add this to a query, remember to use `^`, for example:\n```elixir\nfilter = AshPhoenix.FilterForm.to_filter_expression(form)\n\nAsh.Query.filter(MyApp.Post, ^filter)\n```\n\nAlternatively, you can use the shorthand: `filter/2` to apply the expression directly to a query.","ref":"AshPhoenix.FilterForm.html#to_filter_expression/1"},{"type":"function","title":"AshPhoenix.FilterForm.to_filter_expression!/1","doc":"Same as `to_filter_expression/1` but raises on errors.","ref":"AshPhoenix.FilterForm.html#to_filter_expression!/1"},{"type":"function","title":"AshPhoenix.FilterForm.to_filter_map/1","doc":"Returns a filter map that can be provided to `Ash.Filter.parse`\n\nThis allows for things like saving a stored filter. Does not currently support parameterizing calculations or functions.","ref":"AshPhoenix.FilterForm.html#to_filter_map/1"},{"type":"function","title":"AshPhoenix.FilterForm.update_predicate/3","doc":"Update the predicate with the given id","ref":"AshPhoenix.FilterForm.html#update_predicate/3"},{"type":"function","title":"AshPhoenix.FilterForm.validate/3","doc":"Updates the filter with the provided input and validates it.\n\nAt present, no validation actually occurs, but this will eventually be added.\n\nPassing `reset_on_change?: false` into `opts` will prevent predicates to reset\nthe `value` and `operator` fields to `nil` if the predicate `field` changes.","ref":"AshPhoenix.FilterForm.html#validate/3"},{"type":"module","title":"AshPhoenix.FilterForm.Arguments","doc":"Represents the arguments to a calculation being filtered on","ref":"AshPhoenix.FilterForm.Arguments.html"},{"type":"function","title":"AshPhoenix.FilterForm.Arguments.errors/2","doc":"","ref":"AshPhoenix.FilterForm.Arguments.html#errors/2"},{"type":"function","title":"AshPhoenix.FilterForm.Arguments.new/2","doc":"","ref":"AshPhoenix.FilterForm.Arguments.html#new/2"},{"type":"function","title":"AshPhoenix.FilterForm.Arguments.validate_arguments/2","doc":"","ref":"AshPhoenix.FilterForm.Arguments.html#validate_arguments/2"},{"type":"module","title":"AshPhoenix.FilterForm.Predicate","doc":"Represents an individual predicate appearing in a filter form.\n\nPredicates are grouped up in an `AshPhoenix.FilterForm` to create boolean\nfilter statements.","ref":"AshPhoenix.FilterForm.Predicate.html"},{"type":"function","title":"AshPhoenix.FilterForm.Predicate.errors/2","doc":"","ref":"AshPhoenix.FilterForm.Predicate.html#errors/2"},{"type":"exception","title":"AshPhoenix.Form.InvalidPath","doc":"Raised when an invalid path is used to find, update or remove a form","ref":"AshPhoenix.Form.InvalidPath.html"},{"type":"function","title":"AshPhoenix.Form.InvalidPath.message/1","doc":"","ref":"AshPhoenix.Form.InvalidPath.html#message/1"},{"type":"exception","title":"AshPhoenix.Form.NoActionConfigured","doc":"Raised when a form action should happen but no action of the appropriate type has been configured","ref":"AshPhoenix.Form.NoActionConfigured.html"},{"type":"function","title":"AshPhoenix.Form.NoActionConfigured.message/1","doc":"","ref":"AshPhoenix.Form.NoActionConfigured.html#message/1"},{"type":"exception","title":"AshPhoenix.Form.NoDataLoaded","doc":"Raised when a data needed to be used but the required data was not loaded","ref":"AshPhoenix.Form.NoDataLoaded.html"},{"type":"function","title":"AshPhoenix.Form.NoDataLoaded.message/1","doc":"","ref":"AshPhoenix.Form.NoDataLoaded.html#message/1"},{"type":"exception","title":"AshPhoenix.Form.NoFormConfigured","doc":"Raised when attempting to refer to a form but no nested form with that name was configured.","ref":"AshPhoenix.Form.NoFormConfigured.html"},{"type":"function","title":"AshPhoenix.Form.NoFormConfigured.message/1","doc":"","ref":"AshPhoenix.Form.NoFormConfigured.html#message/1"},{"type":"exception","title":"AshPhoenix.Form.NoResourceConfigured","doc":"Raised when a form needed to be constructed but the resource for that form could not be determined","ref":"AshPhoenix.Form.NoResourceConfigured.html"},{"type":"function","title":"AshPhoenix.Form.NoResourceConfigured.message/1","doc":"","ref":"AshPhoenix.Form.NoResourceConfigured.html#message/1"},{"type":"extras","title":"Home","doc":"![Logo](https://github.com/ash-project/ash/blob/main/logos/cropped-for-header-black-text.png?raw=true#gh-light-mode-only)\n![Logo](https://github.com/ash-project/ash/blob/main/logos/cropped-for-header-white-text.png?raw=true#gh-dark-mode-only)\n\n![Elixir CI](https://github.com/ash-project/ash_phoenix/workflows/CI/badge.svg)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Hex version badge](https://img.shields.io/hexpm/v/ash_phoenix.svg)](https://hex.pm/packages/ash_phoenix)\n[![Hexdocs badge](https://img.shields.io/badge/docs-hexdocs-purple)](https://hexdocs.pm/ash_phoenix)\n\n# AshPhoenix\n\nWelcome! This is the package for integrating [Phoenix Framework](https://www.phoenixframework.org) and [Ash Framework](https://hexdocs.pm/ash). It provides tools for integrating with Phoenix forms (`AshPhoenix.Form`), Phoenix LiveViews (`AshPhoenix.LiveView`) and more.","ref":"readme.html"},{"type":"extras","title":"Installation - Home","doc":"Add `ash_phoenix` to your list of dependencies in `mix.exs`:\n\n```elixir\n{:ash_phoenix, \"~> 2.1.2\"}\n```","ref":"readme.html#installation"},{"type":"extras","title":"Whats in the box? - Home","doc":"- `AshPhoenix.Form` - A form data structure for using resource actions with phoenix forms\n- `AshPhoenix.Form.Auto` - Tools to automatically determine nested form structures based on calls to `manage_relationship` for an action.\n- `AshPhoenix.FilterForm` - A form data structure for building filter statements\n- `AshPhoenix.LiveView` - Helpers for querying data and integrating changes\n- `AshPhoenix.SubdomainPlug` - A plug to determine a tenant using subdomains for multitenancy\n- `AshPhoenix.FormData.Error` - A protocol to allow errors to be rendered in forms\n- `Phoenix.HTML.Safe` implementations for `Ash.CiString`, `Ash.NotLoaded` and `Decimal`\n- `mix ash_phoenix.gen.live` for generating liveview modules\n- `mix ash_phoenix.gen.html` for generating controllers and views","ref":"readme.html#whats-in-the-box"},{"type":"extras","title":"Tutorials - Home","doc":"- [Getting Started with Ash and Phoenix](documentation/tutorials/getting-started-with-ash-and-phoenix.md)","ref":"readme.html#tutorials"},{"type":"extras","title":"Topics - Home","doc":"- [Union Forms](documentation/topics/union-forms.md)","ref":"readme.html#topics"},{"type":"extras","title":"Get Started with Ash and Phoenix","doc":"# Get Started with Ash and Phoenix","ref":"getting-started-with-ash-and-phoenix.html"},{"type":"extras","title":"Goals - Get Started with Ash and Phoenix","doc":"In this guide we will:\n\n1. Create a new Phoenix project\n2. Setup Ash, AshPhoenix and AshPostgres as dependencies\n3. Create a basic `Blog.Post` resource\n4. Create and migrate the database\n5. Learn how to interact with your resource\n6. Integrate a minimal Phoenix LiveView with Ash","ref":"getting-started-with-ash-and-phoenix.html#goals"},{"type":"extras","title":"Preparation - Get Started with Ash and Phoenix","doc":"- [Install Elixir](https://elixir-lang.org/install.html)\n- [Phoenix - Up and Running Guide](https://hexdocs.pm/phoenix/up_and_running.html)\n- [Design Principles](https://hexdocs.pm/ash/design-principles.html)","ref":"getting-started-with-ash-and-phoenix.html#preparation"},{"type":"extras","title":"Requirements - Get Started with Ash and Phoenix","doc":"If you want to follow along yourself, you will need the following things:\n\n1. Elixir (1.12 or later) and Erlang (22 or later) installed\n2. PostgreSQL installed\n3. A text editor\n4. A terminal to run the examples","ref":"getting-started-with-ash-and-phoenix.html#requirements"},{"type":"extras","title":"Setup - Get Started with Ash and Phoenix","doc":"","ref":"getting-started-with-ash-and-phoenix.html#setup"},{"type":"extras","title":"Create a New Phoenix Project - Get Started with Ash and Phoenix","doc":">","ref":"getting-started-with-ash-and-phoenix.html#create-a-new-phoenix-project"},{"type":"extras","title":"Install Phoenix {: .info} - Get Started with Ash and Phoenix","doc":">\n> _This section is based on the [Phoenix installation docs](https://hexdocs.pm/phoenix/installation.html). For more details go there._\n\nFirst we need to install the Phoenix project generator, then we'll run the generator to create our new project.\n\n```bash\n# install Phoenix project generator\n$ mix archive.install hex phx_new\n\n# generate Phoenix project\n$ mix phx.new my_ash_phoenix_app\n\n# cd into project\n$ cd my_ash_phoenix_app\n```\n\n>","ref":"getting-started-with-ash-and-phoenix.html#install-phoenix-info"},{"type":"extras","title":"Don't run `mix ecto.create` {: .warning} - Get Started with Ash and Phoenix","doc":">\n> Do _not_ run `mix ecto.create`, (as it asks you to) we will do this the Ash way later.","ref":"getting-started-with-ash-and-phoenix.html#don-t-run-mix-ecto-create-warning"},{"type":"extras","title":"Add Dependencies - Get Started with Ash and Phoenix","doc":"We now need to add Ash, AshPhoenix and AshPostgres to our Phoenix project. We need to add the dependencies to the `deps` function in our `mix.exs`. We'll also need to add dependencies to our `.formatter.exs` to ensure consistent formatting when using `mix format`.\n\n```elixir\n# mix.exs\n\n  def deps do\n    [\n      # use `mix hex.info  ` to get the latest versions of each dependency, for example, `mix hex.info phoenix`\n      {:phoenix, \"~> x.x\"},\n      # ...\n      {:ash, \"~> x.x\"},\n      {:picosat_elixir, \"~> x.x\"},\n      {:ash_postgres, \"~> x.x\"},\n      {:ash_phoenix, \"~> x.x\"}\n    ]\n  end\n```\n\nAdd `:ash`, `:ash_phoenix`, and `:ash_postgres` to your `.formatter.exs` file.\n\n```elixir\n# .formatter.exs\n[\n  import_deps: [..., :ash, :ash_phoenix, :ash_postgres],\n  ...\n]\n```\n\nNow in the terminal install these new dependencies.\n\n```bash\n$ mix deps.get\n```\n\n>","ref":"getting-started-with-ash-and-phoenix.html#add-dependencies"},{"type":"extras","title":"Picosat installation issues? {: .info} - Get Started with Ash and Phoenix","doc":">\n> If you have trouble compiling `picosat_elixir`, then replace `{:picosat_elixir, \"~> 0.2\"}` with `{:simple_sat, \"~> 0.1\"}` to use a simpler (but mildly slower) solver. You can always switch back to `picosat_elixir` later once you're done with the tutorial.","ref":"getting-started-with-ash-and-phoenix.html#picosat-installation-issues-info"},{"type":"extras","title":"Use `AshPostgres.Repo` - Get Started with Ash and Phoenix","doc":"We need to swap `Ecto.Repo` for `AshPostgres.Repo`. `AshPostgres.Repo` enriches your repo with additional AshPostgres specific behaviour, but is essentially a thin wrapper around `Ecto.Repo`.\nTo use `AshPostgres.Repo` change your repo module to look like this:\n\n```elixir\n# lib/my_ash_phoenix_app/repo.ex\n\ndefmodule MyAshPhoenixApp.Repo do\n  use AshPostgres.Repo, otp_app: :my_ash_phoenix_app\n\n  # Installs extensions that ash commonly uses\n  def installed_extensions do\n    [\"ash-functions\", \"uuid-ossp\", \"citext\"]\n  end\nend\n```","ref":"getting-started-with-ash-and-phoenix.html#use-ashpostgres-repo"},{"type":"extras","title":"Edit Config - Get Started with Ash and Phoenix","doc":"We need to specify the Ash domains that our application uses.\n\nAdd this to your config:\n\n```elixir\n# config/config.exs\n\nimport Config\n\nconfig :my_ash_phoenix_app,\n  ash_domains: [MyAshPhoenixApp.Blog]\n```","ref":"getting-started-with-ash-and-phoenix.html#edit-config"},{"type":"extras","title":"Create the Domain and add Resources - Get Started with Ash and Phoenix","doc":"An Ash domain can be thought of as a [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) in Domain Driven Design terms and can seen as analogous to a Phoenix context. Put simply, its a way of grouping related resources together. In our case our domain will be called `MyAshPhoenixApp.Blog`.\n\nAn Ash domain points to Ash resources. An Ash domain can point to one or more resources. In our case we will only have a single resource `MyAshPhoenixApp.Blog.Post`. We'll be taking a deeper look into that in the next section.\n\nFor now take a look at the `Blog` domain and the associated resources:\n\n```elixir\n# lib/my_ash_phoenix_app/blog/blog.ex\n\ndefmodule MyAshPhoenixApp.Blog do\n  use Ash.Domain\n\n  resources do\n    resource MyAshPhoenixApp.Blog.Post do\n      # Define an interface for calling resource actions.\n      define :create_post, action: :create\n      define :list_posts, action: :read\n      define :update_post, action: :update\n      define :destroy_post, action: :destroy\n      define :get_post, args: [:id], action: :by_id\n    end\n  end\nend\n```","ref":"getting-started-with-ash-and-phoenix.html#create-the-domain-and-add-resources"},{"type":"extras","title":"Creating Resources - Get Started with Ash and Phoenix","doc":"","ref":"getting-started-with-ash-and-phoenix.html#creating-resources"},{"type":"extras","title":"Creating the `Post` Resource - Get Started with Ash and Phoenix","doc":"A resource is a central concept in Ash. In short, a resource is a domain model object in your system. A resource defines the data it holds and defines the actions that can operate on that data.\n\nWhen we create `Post` we will place it in `lib/my_ash_phoenix_app/blog/post.ex`. So the structure after making the resource should look like so:\n\n```\nlib/\n my_ash_phoenix_app/\n   blog/\n     blog.ex\n     post.ex\n```\n\nBelow is the resource module. Read the comments carefully, every line is explained:\n\n```elixir\n# lib/my_ash_phoenix_app/blog/post.ex\n\ndefmodule MyAshPhoenixApp.Blog.Post do\n  # Using Ash.Resource turns this module into an Ash resource.\n  use Ash.Resource,\n    # Tells Ash where the generated code interface belongs\n    domain: MyAshPhoenixApp.Blog,\n    # Tells Ash you want this resource to store its data in Postgres.\n    data_layer: AshPostgres.DataLayer\n\n  # The Postgres keyword is specific to the AshPostgres module.\n  postgres do\n    # Tells Postgres what to call the table\n    table \"posts\"\n    # Tells Ash how to interface with the Postgres table\n    repo MyAshPhoenixApp.Repo\n  end\n\n  actions do\n    # Exposes default built in actions to manage the resource\n    defaults [:read, :destroy]\n\n    create :create do\n      # accept title as input\n      accept [:title]\n    end\n\n    update :update do\n      # accept content as input\n      accept [:content]\n    end\n\n    # Defines custom read action which fetches post by id.\n    read :by_id do\n      # This action has one argument :id of type :uuid\n      argument :id, :uuid, allow_nil?: false\n      # Tells us we expect this action to return a single result\n      get? true\n      # Filters the `:id` given in the argument\n      # against the `id` of each element in the resource\n      filter expr(id == ^arg(:id))\n    end\n  end\n\n  # Attributes are simple pieces of data that exist in your resource\n  attributes do\n    # Add an autogenerated UUID primary key called `:id`.\n    uuid_primary_key :id\n    # Add a string type attribute called `:title`\n    attribute :title, :string do\n      # We don't want the title to ever be `nil`\n      allow_nil? false\n    end\n\n    # Add a string type attribute called `:content`\n    # If allow_nil? is not specified, then content can be nil\n    attribute :content, :string\n  end\nend\n```","ref":"getting-started-with-ash-and-phoenix.html#creating-the-post-resource"},{"type":"extras","title":"Creating and Migrating the Database - Get Started with Ash and Phoenix","doc":"We have specified the resource in Ash. But we have yet to create it in our data layer (in our case Postgres).\n\nFirst we need to create our database:\n\n```bash\n$ mix ash.setup\n\nRunning setup for AshPostgres.DataLayer...\nThe database for MyAshPhoenixApp.Repo has been created\n\n01:23:45.678 [info] Migrations already up\n```\n\nNow we need to populate our database. We do this by generating and performing a migration.\n\nWe can use a generator to produce a migration for us. Ash can deduce what needs to go into the migration and do the hard work for us, to do this use the command below:\n\n```bash\n$ mix ash.codegen initial_migration\n\n# ... don't worry about other files it creates\n\nGenerating Migrations:\n* creating priv/repo/migrations/20230208045101_initial_migration.exs\n```\n\nHere is the migration file commented in detail:\n\n```elixir\n# priv/repo/migrations/20230208045101_initial_migration.exs\n\ndefmodule MyAshPhoenixApp.Repo.Migrations.InitialMigration do\n  use Ecto.Migration\n\n  # This function runs when migrating forward\n  def up do\n    # Creates the `:posts` table\n    create table(:posts, primary_key: false) do\n      # Adds primary key attribute `:id` of type `:uuid`\n      # null values are not allowed\n      add :id, :uuid, null: false, default: fragment(\"gen_random_uuid()\"), primary_key: true\n\n      # Adds attribute `:title` of type `:text`, null values are not allowed\n      add :title, :text, null: false\n      # Adds attribute `:content` of type `:text`, null values are allowed\n      add :content, :text\n    end\n  end\n\n  # This is the function that runs if you want to rollback the migration.\n  def down do\n    # Deletes the `:posts` table\n    drop table(:posts)\n  end\nend\n```\n\nWe can run the `up/0` function which will perform the desired operations on the Postgres database. We do this with the migrate command:\n\n```bash\n$ mix ash.migrate\n```\n\n> In case you want to drop the database and start over again during development you can use `mix ash.reset`.","ref":"getting-started-with-ash-and-phoenix.html#creating-and-migrating-the-database"},{"type":"extras","title":"Interacting with your Resources - Get Started with Ash and Phoenix","doc":"**All interaction with your resource attributes always occur through an action**. In our resource we are using the default actions for `:create, :read, :update, :destroy` along with a custom action `:by_id`.\n\n`:create` and `:update` and `:destroy` actions require a changeset. Ash changesets are conceptually similar to [Ecto changesets](https://hexdocs.pm/ecto/Ecto.Changeset.html). They're data structures which represent an intended change to an Ash resource and provide validation.\n\nThe `:read` action takes a query instead of a changeset.\n\nBelow is the most verbose way of calling your resource. All other ways of interaction are some kind of shorthand of these. This means at some point a changeset is being created and passed to the domain, even if it's encapsulated within another function.\n\n```elixir\n# create post\nnew_post =\n  MyAshPhoenixApp.Blog.Post\n  |> Ash.Changeset.for_create(:create, %{title: \"hello world\"})\n  |> Ash.create!()\n\n# read all posts\nMyAshPhoenixApp.Blog.Post\n|> Ash.Query.for_read(:read)\n|> Ash.read!()\n\n# get single post by id\nMyAshPhoenixApp.Blog.Post\n|> Ash.Query.for_read(:by_id, %{id: new_post.id})\n|> Ash.read_one!()\n\n# update post\nupdated_post =\n  new_post\n  |> Ash.Changeset.for_update(:update, %{content: \"hello to you too!\"})\n  |> Ash.update!()\n\n# delete post\nnew_post\n|> Ash.Changeset.for_destroy(:destroy)\n|> Ash.destroy!()\n```\n\nAs stated above, this is verbose so Ash has a built in shortcut - The `code_interface`. You may notice this has already been done in your `Post` resource inside of the domain module.\n\n>","ref":"getting-started-with-ash-and-phoenix.html#interacting-with-your-resources"},{"type":"extras","title":"you can call code interfaces whatever you like {: .info} - Get Started with Ash and Phoenix","doc":">\n> The function name doesn't have to match the action name in any way. You could also write:\n>\n> ```elixir\n> define :make_post, action: :create\n> ```\n>\n> That's perfectly valid and could be called via `Blog.make_post/2`.\n\nNow we can call our resource like so:\n\n```elixir\n# create post\nnew_post = MyAshPhoenixApp.Blog.create_post!(%{title: \"hello world\"})\n\n# read post\nMyAshPhoenixApp.Blog.list_posts!()\n\n# get post by id\nMyAshPhoenixApp.Blog.get_post!(new_post.id)\n\n# update post\nupdated_post = MyAshPhoenixApp.Blog.update_post!(new_post, %{content: \"hello to you too!\"})\n\n# delete post\nMyAshPhoenixApp.Blog.destroy_post!(updated_post)\n```\n\nNow isn't that more convenient?\n\n>","ref":"getting-started-with-ash-and-phoenix.html#you-can-call-code-interfaces-whatever-you-like-info"},{"type":"extras","title":"raising and non-raising functions {: .info} - Get Started with Ash and Phoenix","doc":">\n> All functions that interact with an Ash resource have a raising and non-raising version. For example there are two create functions `create/2` and `create!/2`. `create/2` returns `{:ok, resource}` or `{:error, reason}`. `create!/2` will return just the record on success and will raise an error on failure.","ref":"getting-started-with-ash-and-phoenix.html#raising-and-non-raising-functions-info"},{"type":"extras","title":"Connecting your Resource to a Phoenix LiveView - Get Started with Ash and Phoenix","doc":"Now we know how to interact with our resource, let's connect it to a simple Phoenix LiveView. Here is the LiveView below. If you are using phoenix live_view <= 0.18, you will need to use `let={}` instead of `:let={}`.\n\n```elixir\n# lib/my_ash_phoenix_app_web/posts_live.ex\n\ndefmodule MyAshPhoenixAppWeb.PostsLive do\n  use MyAshPhoenixAppWeb, :live_view\n\n  alias MyAshPhoenixApp.Blog\n  alias MyAshPhoenixApp.Blog.Post\n\n  def render(assigns) do\n    ~H\"\"\"\n     Your Posts \n     \n       \n        No posts created yet\n       \n       \n         \n           <%= post.title %> \n           <%= if Map.get(post, :content), do: post.content, else: \"\" %> \n           \n            Delete post\n           \n         \n       \n     \n     Create Post \n    <.form :let={f} for={@create_form} phx-submit=\"create_post\">\n      <.input type=\"text\" field={f[:title]} placeholder=\"input title\" />\n      <.button class=\"mt-2\" type=\"submit\">Create</.button>\n    </.form>\n     Update Post \n    <.form :let={f} for={@update_form} phx-submit=\"update_post\">\n      <.label>Post Name</.label>\n      <.input type=\"select\" field={f[:post_id]} options={@post_selector} />\n      <.input type=\"text\" field={f[:content]} placeholder=\"input content\" />\n      <.button class=\"mt-2\" type=\"submit\">Update</.button>\n    </.form>\n    \"\"\"\n  end\n\n  def mount(_params, _session, socket) do\n    posts = Blog.list_posts!()\n\n    socket =\n      assign(socket,\n        posts: posts,\n        post_selector: post_selector(posts),\n        create_form: AshPhoenix.Form.for_create(Post, :create) |> to_form(),\n        update_form: AshPhoenix.Form.for_update(List.first(posts, %Post{}), :update) |> to_form()\n      )\n\n    {:ok, socket}\n  end\n\n  def handle_event(\"delete_post\", %{\"post-id\" => post_id}, socket) do\n    post_id |> Blog.get_post!() |> Blog.destroy_post!()\n    posts = Blog.list_posts!()\n\n    {:noreply, assign(socket, posts: posts, post_selector: post_selector(posts))}\n  end\n\n  def handle_event(\"create_post\", %{\"form\" => form_params}, socket) do\n    case AshPhoenix.Form.submit(socket.assigns.create_form, params: form_params) do\n      {:ok, _post} ->\n        posts = Blog.list_posts!()\n\n        {:noreply, assign(socket, posts: posts, post_selector: post_selector(posts))}\n\n      {:error, create_form} ->\n        {:noreply, assign(socket, create_form: create_form)}\n    end\n  end\n\n  def handle_event(\"update_post\", %{\"form\" => form_params}, socket) do\n    case AshPhoenix.Form.submit(socket.assigns.update_form, params: form_params) do\n      {:ok, _post} ->\n        posts = Blog.list_posts!()\n\n        {:noreply, assign(socket, posts: posts, post_selector: post_selector(posts))}\n\n      {:error, update_form} ->\n        {:noreply, assign(socket, update_form: update_form)}\n    end\n  end\n\n  defp post_selector(posts) do\n    for post <- posts do\n      {post.title, post.id}\n    end\n  end\nend\n```\n\nDon't forget to add the LiveView to your router.\n\n```elixir\n# lib/my_ash_phoenix_app_web/router.ex\n  scope \"/\", MyAshPhoenixAppWeb do\n    # ...\n    live \"/posts\", PostsLive\n  end\n```\n\nNow, start the web server by running `mix phx.server`. Then, visit http://localhost:4000/posts in your browser to see what we have just created.\n\nYou can see how using functions created by our `code_interface` makes it easy to integrate Ash with Phoenix.\n\nYou may also notice this is the first time we've used the AshPhoenix library. The AshPhoenix library contains utilities to help Ash integrate with Phoenix and LiveView Seamlessly. One of these utilities is `AshPhoenix.Form` which can automatically produce changesets to be used in the forms.\n\nThat's it for this guide. We've gone from 0 to a fully working Phoenix App using Ash. To get a closer look, see the accompanying repo [here](https://github.com/team-alembic/my_ash_phoenix_project).","ref":"getting-started-with-ash-and-phoenix.html#connecting-your-resource-to-a-phoenix-liveview"},{"type":"extras","title":"Where to Next? - Get Started with Ash and Phoenix","doc":"We are really just scratching the surface of what can be done in Ash. Look below for what to look at next.","ref":"getting-started-with-ash-and-phoenix.html#where-to-next"},{"type":"extras","title":"Continue Learning - Get Started with Ash and Phoenix","doc":"There's a few places you can go to learn more about how to use ash:\n\n- Read more about how to query the data in your resources - `Ash.Query`\n- [Dig deeper into actions.](https://hexdocs.pm/ash/actions.html)\n- [Study resource relationship management](https://hexdocs.pm/ash/managing-relationships.html)","ref":"getting-started-with-ash-and-phoenix.html#continue-learning"},{"type":"extras","title":"Ash Authentication & Ash Authentication Phoenix - Get Started with Ash and Phoenix","doc":"See the power Ash can bring to your web app or API. [Get authentication working in minutes](https://hexdocs.pm/ash_authentication_phoenix/get-started.html).","ref":"getting-started-with-ash-and-phoenix.html#ash-authentication-ash-authentication-phoenix"},{"type":"extras","title":"Add an API (or two) - Get Started with Ash and Phoenix","doc":"Check out the [AshJsonApi](https://hexdocs.pm/ash_json_api/getting-started-with-json-api.html) and [AshGraphql](https://hexdocs.pm/ash_graphql/getting-started-with-graphql.html) extensions to effortlessly build APIs around your resources.","ref":"getting-started-with-ash-and-phoenix.html#add-an-api-or-two"},{"type":"extras","title":"Union Forms","doc":"# Union Forms\n\nWhen building a form for a union, you use `inputs_for` as normal, but a few things are done for you under the hood.\n\nLets take this example union:\n\n```elixir\ndefmodule NormalContent do\n  use Ash.Resource, data_layer: :embedded\n\n  attributes do\n    attribute :body, :string, allow_nil?: false\n  end\n\n  actions do\n    defaults [:read, create: [:body], update: [:body]]\n  end\nend\n\ndefmodule SpecialContent do\n  use Ash.Resource, data_layer: :embedded\n\n  attributes do\n    attribute :text, :string, allow_nil?: false\n  end\n\n  actions do\n    defaults [:read, create: [:text], update: [:text]]\n  end\nend\n\ndefmodule Content do\n  use Ash.Type.NewType,\n    subtype_of: :union,\n    constraints: [\n      types: [\n        normal: [\n          type: NormalContent,\n          tag: :type,\n          tag_value: :normal\n        ],\n        special: [\n          type: SpecialContent,\n          tag: :type,\n          tag_value: :special\n        ]\n      ]\n    ]\nend\n```","ref":"union-forms.html"},{"type":"extras","title":"Determining the type for a union form - Union Forms","doc":"We track the type of the value in a hidden param called `_union_type`. You can use this to show a different form depending on the type of thing.","ref":"union-forms.html#determining-the-type-for-a-union-form"},{"type":"extras","title":"Changing the type of a union form - Union Forms","doc":"If you want to let the user _change_ the union type, you would use `AshPhoenix.Form.remove_form/3` and `AshPhoenix.Form.add_form/3`. See the example below for the template, and here is an example event handler\n\n```elixir\ndef handle_event(\"type-changed\", %{\"_target\" => path} = params, socket) do\n  new_type = get_in(params, path)\n  # The last part of the path in this case is the field name\n  path = :lists.droplast(path)\n\n  form =\n    socket.assigns.form\n    |> AshPhoenix.Form.remove_form(path)\n    |> AshPhoenix.Form.add_form(path, params: %{\"_union_type\" => new_type})\n\n  {:noreply, assign(socket, :form, form)}\nend\n```","ref":"union-forms.html#changing-the-type-of-a-union-form"},{"type":"extras","title":"Non-embedded types - Union Forms","doc":"If one of your union values is a _non_ embedded type, like `:integer`, it will still be a nested form, but you would access the single value with `<.input field={nested_form[:value]} .../>`","ref":"union-forms.html#non-embedded-types"},{"type":"extras","title":"Example - Union Forms","doc":"We might have a form like this:\n\n```heex\n<.inputs_for :let={fc} field={@form[:content]}>\n  <!-- Dropdown for setting the union type -->\n  <.input\n    field={fc[:_union_type}\n    phx-change=\"type-changed\"\n    type=\"select\"\n    options={[Normal: \"normal\", Special: \"special\"]}\n  />\n\n  <!-- switch on the union type to display a form -->\n  <%= case fc.params[\"_union_type\"] do %>\n    <% \"normal\" -> %>\n      <.input  type=\"text\" field={fc[:body]} />\n    <% \"special\" -> %>\n      <.input type=\"text\" field={fc[:text]} />\n  <% end %>\n</.inputs_for>\n```","ref":"union-forms.html#example"},{"type":"extras","title":"Change Log","doc":"# Change Log\n\nAll notable changes to this project will be documented in this file.\nSee [Conventional Commits](Https://conventionalcommits.org) for commit guidelines.\n\n<!-- changelog -->\n\n## [v2.1.2](https://github.com/ash-project/ash_phoenix/compare/v2.1.1...v2.1.2) (2024-09-03)","ref":"changelog.html"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* spec `update_form` to accept functions of lists\n\n## [v2.1.1](https://github.com/ash-project/ash_phoenix/compare/v2.1.0...v2.1.1) (2024-08-01)","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* Use :public? instead of :private? (#221)","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Improvements: - Change Log","doc":"* raise an error on usage of old option name\n\n## [v2.1.0](https://github.com/ash-project/ash_phoenix/compare/v2.0.4...v2.1.0) (2024-07-26)","ref":"changelog.html#improvements"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* ensure we `prepare_source` for all read action forms\n\n## [v2.0.4](https://github.com/ash-project/ash_phoenix/compare/v2.0.3...v2.0.4) (2024-06-13)","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* various fixes for union form handling\n\n* properly fill union values on update\n\n* ensure changing union type is reflected in param transformer","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Improvements: - Change Log","doc":"* honor `_union_type` when applying input\n\n## [v2.0.3](https://github.com/ash-project/ash_phoenix/compare/v2.0.2...v2.0.3) (2024-06-05)","ref":"changelog.html#improvements"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* properly (i.e safely) encode ci strings to iodata and params\n\n* various union param handling fixes\n\n* properly transform nested params\n\n* make sure that _index is correctly updated before and after removal for sparse forms (#196) (#197)\n\n## [v2.0.2](https://github.com/ash-project/ash_phoenix/compare/v2.0.1...v2.0.2) (2024-05-22)","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* don't assume all embeds have a create/update action\n\n## [v2.0.1](https://github.com/ash-project/ash_phoenix/compare/v2.0.0...v2.0.1) (2024-05-17)","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"* improve union handling\n\n* Convert entered action names into atoms for lookup in the resource (#187)\n\n* various fixes around union forms","ref":"changelog.html#bug-fixes"},{"type":"extras","title":"Improvements: - Change Log","doc":"* support adding a form by inserting to an index\n\n## [v2.0.0](https://github.com/ash-project/ash_phoenix/compare/v2.0.0...v1.3.4) (2024-04-30)\n\nThe changelog is being restarted. See `/documentation/1.0-CHANGELOG.md` in GitHub for the old changelog.","ref":"changelog.html#improvements"},{"type":"extras","title":"Improvements: - Change Log","doc":"- [AshPhoenix.Form] better error message with hints for accepted/non accepted missing forms","ref":"changelog.html#improvements"},{"type":"extras","title":"Bug Fixes: - Change Log","doc":"- [AshPhoenix.Form] don't use `public_attributes?`, check for all accepted attributes. In Ash 3.0, private attributes can be accepted\n- [AshPhoenix.Form]\n\n- Pass the tenant to `Ash.can/3` and `Ash.can?/3`. (#165)\n\n- Pass the tenant to `Ash.can/3` and `Ash.can?/3`.","ref":"changelog.html#bug-fixes"}],"content_type":"text/markdown","producer":{"name":"ex_doc","version":[48,46,51,52,46,50]}}