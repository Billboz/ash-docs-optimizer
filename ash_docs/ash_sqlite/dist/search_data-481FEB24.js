searchData={"content_type":"text/markdown","items":[{"doc":"The name of the foreign key to generate in the database. Defaults to <table>_<source_attribute>_fkey","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-reference-name","title":"AshSqlite.DataLayer.sqlite.references.reference.name","type":"DSL"},{"doc":"Wether or not the constraint is deferrable. This only affects the migration generator.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-reference-deferrable","title":"AshSqlite.DataLayer.sqlite.references.reference.deferrable","type":"DSL"},{"doc":"What should happen to records of this resource when the referenced destination_attribute of the *destination* record is update.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-reference-on_update","title":"AshSqlite.DataLayer.sqlite.references.reference.on_update","type":"DSL"},{"doc":"What should happen to records of this resource when the referenced record of the *destination* resource is deleted.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-reference-on_delete","title":"AshSqlite.DataLayer.sqlite.references.reference.on_delete","type":"DSL"},{"doc":"If set to true, no reference is created for the given relationship. This is useful if you need to define it in some custom way","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-reference-ignore?","title":"AshSqlite.DataLayer.sqlite.references.reference.ignore?","type":"DSL"},{"doc":"The relationship to be configured","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-reference-relationship","title":"AshSqlite.DataLayer.sqlite.references.reference.relationship","type":"DSL"},{"doc":"Configures the reference for a relationship in resource migrations.\n\nKeep in mind that multiple relationships can theoretically involve the same destination and foreign keys.\nIn those cases, you only need to configure the `reference` behavior for one of them. Any conflicts will result\nin an error, across this resource and any other resources that share a table with this one. For this reason,\ninstead of adding a reference configuration for `:nothing`, its best to just leave the configuration out, as that\nis the default behavior if *no* relationship anywhere has configured the behavior of that reference.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-reference","title":"AshSqlite.DataLayer.sqlite.references.reference","type":"DSL"},{"doc":"For polymorphic resources, configures the on_update behavior of the automatically generated foreign keys to source tables.","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-polymorphic_name","title":"AshSqlite.DataLayer.sqlite.references.polymorphic_name","type":"DSL"},{"doc":"For polymorphic resources, configures the on_update behavior of the automatically generated foreign keys to source tables.","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-polymorphic_on_update","title":"AshSqlite.DataLayer.sqlite.references.polymorphic_on_update","type":"DSL"},{"doc":"For polymorphic resources, configures the on_delete behavior of the automatically generated foreign keys to source tables.","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-polymorphic_on_delete","title":"AshSqlite.DataLayer.sqlite.references.polymorphic_on_delete","type":"DSL"},{"doc":"A section for configuring the references (foreign keys) in resource migrations.\n\nThis section is only relevant if you are using the migration generator with this resource.\nOtherwise, it has no effect.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-references","title":"AshSqlite.DataLayer.sqlite.references","type":"DSL"},{"doc":"How to tear down the structure of the statement","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_statements-statement-down","title":"AshSqlite.DataLayer.sqlite.custom_statements.statement.down","type":"DSL"},{"doc":"How to create the structure of the statement\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_statements-statement-up","title":"AshSqlite.DataLayer.sqlite.custom_statements.statement.up","type":"DSL"},{"doc":"By default, we place the strings inside of ecto migration's `execute/1` function and assume they are sql. Use this option if you want to provide custom elixir code to be placed directly in the migrations\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_statements-statement-code?","title":"AshSqlite.DataLayer.sqlite.custom_statements.statement.code?","type":"DSL"},{"doc":"The name of the statement, must be unique within the resource\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_statements-statement-name","title":"AshSqlite.DataLayer.sqlite.custom_statements.statement.name","type":"DSL"},{"doc":"Add a custom statement for migrations.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_statements-statement","title":"AshSqlite.DataLayer.sqlite.custom_statements.statement","type":"DSL"},{"doc":"A section for configuring custom statements to be added to migrations.\n\nChanging custom statements may require manual intervention, because Ash can't determine what order they should run\nin (i.e if they depend on table structure that you've added, or vice versa). As such, any `down` statements we run\nfor custom statements happen first, and any `up` statements happen last.\n\nAdditionally, when changing a custom statement, we must make some assumptions, i.e that we should migrate\nthe old structure down using the previously configured `down` and recreate it.\n\nThis may not be desired, and so what you may end up doing is simply modifying the old migration and deleting whatever was\ngenerated by the migration generator. As always: read your migrations after generating them!\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_statements","title":"AshSqlite.DataLayer.sqlite.custom_statements","type":"DSL"},{"doc":"specify fields for a covering index. This is not supported by all databases. For more information on SQLite support, please read the official docs.","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes-index-include","title":"AshSqlite.DataLayer.sqlite.custom_indexes.index.include","type":"DSL"},{"doc":"A custom message to use for unique indexes that have been violated","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes-index-message","title":"AshSqlite.DataLayer.sqlite.custom_indexes.index.message","type":"DSL"},{"doc":"specify conditions for a partial index.","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes-index-where","title":"AshSqlite.DataLayer.sqlite.custom_indexes.index.where","type":"DSL"},{"doc":"configures the index type.","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes-index-using","title":"AshSqlite.DataLayer.sqlite.custom_indexes.index.using","type":"DSL"},{"doc":"indicates whether the index should be unique.","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes-index-unique","title":"AshSqlite.DataLayer.sqlite.custom_indexes.index.unique","type":"DSL"},{"doc":"the name of the index. Defaults to \"#{table}_#{column}_index\".","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes-index-name","title":"AshSqlite.DataLayer.sqlite.custom_indexes.index.name","type":"DSL"},{"doc":"The fields to include in the index.","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes-index-fields","title":"AshSqlite.DataLayer.sqlite.custom_indexes.index.fields","type":"DSL"},{"doc":"Add an index to be managed by the migration generator.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes-index","title":"AshSqlite.DataLayer.sqlite.custom_indexes.index","type":"DSL"},{"doc":"A section for configuring indexes to be created by the migration generator.\n\nIn general, prefer to use `identities` for simple unique constraints. This is a tool to allow\nfor declaring more complex indexes.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes","title":"AshSqlite.DataLayer.sqlite.custom_indexes","type":"DSL"},{"doc":"Declares this resource as polymorphic. See the [polymorphic resources guide](/documentation/topics/resources/polymorphic-resources.md) for more.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-polymorphic?","title":"AshSqlite.DataLayer.sqlite.polymorphic?","type":"DSL"},{"doc":"The table to store and read the resource from. If this is changed, the migration generator will not remove the old table.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-table","title":"AshSqlite.DataLayer.sqlite.table","type":"DSL"},{"doc":"A list of attributes that will be ignored when generating migrations.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-migration_ignore_attributes","title":"AshSqlite.DataLayer.sqlite.migration_ignore_attributes","type":"DSL"},{"doc":"A list of foreign keys that could raise errors, or an mfa to a function that takes a changeset and returns a list. In the format: `{:key, \"name_of_constraint\"}` or `{:key, \"name_of_constraint\", \"custom error message\"}`\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-foreign_key_names","title":"AshSqlite.DataLayer.sqlite.foreign_key_names","type":"DSL"},{"doc":"A keyword list of identity names to the unique index name that they should use when being managed by the migration generator.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-identity_index_names","title":"AshSqlite.DataLayer.sqlite.identity_index_names","type":"DSL"},{"doc":"A list of exclusion constraint names that could raise errors. Must be in the format `{:affected_key, \"name_of_constraint\"}` or `{:affected_key, \"name_of_constraint\", \"custom error message\"}`\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-exclusion_constraint_names","title":"AshSqlite.DataLayer.sqlite.exclusion_constraint_names","type":"DSL"},{"doc":"A list of unique index names that could raise errors that are not configured in identities, or an mfa to a function that takes a changeset and returns the list. In the format `{[:affected, :keys], \"name_of_constraint\"}` or `{[:affected, :keys], \"name_of_constraint\", \"custom error message\"}`\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-unique_index_names","title":"AshSqlite.DataLayer.sqlite.unique_index_names","type":"DSL"},{"doc":"Skip generating unique indexes when generating migrations","ref":"dsl-ashsqlite-datalayer.html#sqlite-skip_unique_indexes","title":"AshSqlite.DataLayer.sqlite.skip_unique_indexes","type":"DSL"},{"doc":"A raw sql version of the base_filter, e.g `representative = true`. Required if trying to create a unique constraint on a resource with a base_filter","ref":"dsl-ashsqlite-datalayer.html#sqlite-base_filter_sql","title":"AshSqlite.DataLayer.sqlite.base_filter_sql","type":"DSL"},{"doc":"A keyword list of attribute names to the ecto migration default that should be used for that attribute. The string you use will be placed verbatim in the migration. Use fragments like `fragment(\\\\\"now()\\\\\")`, or for `nil`, use `\\\\\"nil\\\\\"`.\n","ref":"dsl-ashsqlite-datalayer.html#sqlite-migration_defaults","title":"AshSqlite.DataLayer.sqlite.migration_defaults","type":"DSL"},{"doc":"A keyword list of attribute names to the ecto migration type that should be used for that attribute. Only necessary if you need to override the defaults.","ref":"dsl-ashsqlite-datalayer.html#sqlite-migration_types","title":"AshSqlite.DataLayer.sqlite.migration_types","type":"DSL"},{"doc":"Whether or not to include this resource in the generated migrations with `mix ash.generate_migrations`","ref":"dsl-ashsqlite-datalayer.html#sqlite-migrate?","title":"AshSqlite.DataLayer.sqlite.migrate?","type":"DSL"},{"doc":"The repo that will be used to fetch your data. See the `AshSqlite.Repo` documentation for more","ref":"dsl-ashsqlite-datalayer.html#sqlite-repo","title":"AshSqlite.DataLayer.sqlite.repo","type":"DSL"},{"doc":"Sqlite data layer configuration\n","ref":"dsl-ashsqlite-datalayer.html#sqlite","title":"AshSqlite.DataLayer.sqlite","type":"DSL"},{"doc":"The AshSqlite extension gives you tools to map a resource to a sqlite database table.\n\nFor more, check out the [getting started guide](/documentation/tutorials/getting-started-with-ash-sqlite.md)","ref":"AshSqlite.html","title":"AshSqlite","type":"module"},{"doc":"A sqlite data layer that leverages Ecto's sqlite capabilities.","ref":"AshSqlite.DataLayer.html","title":"AshSqlite.DataLayer","type":"module"},{"doc":"","ref":"AshSqlite.DataLayer.html#add_known_binding/3","title":"AshSqlite.DataLayer.add_known_binding/3","type":"function"},{"doc":"","ref":"AshSqlite.DataLayer.html#codegen/1","title":"AshSqlite.DataLayer.codegen/1","type":"function"},{"doc":"","ref":"AshSqlite.DataLayer.html#from_ecto/1","title":"AshSqlite.DataLayer.from_ecto/1","type":"function"},{"doc":"","ref":"AshSqlite.DataLayer.html#migrate/1","title":"AshSqlite.DataLayer.migrate/1","type":"function"},{"doc":"","ref":"AshSqlite.DataLayer.html#rollback/1","title":"AshSqlite.DataLayer.rollback/1","type":"function"},{"doc":"","ref":"AshSqlite.DataLayer.html#setup/1","title":"AshSqlite.DataLayer.setup/1","type":"function"},{"doc":"","ref":"AshSqlite.DataLayer.html#tear_down/1","title":"AshSqlite.DataLayer.tear_down/1","type":"function"},{"doc":"","ref":"AshSqlite.DataLayer.html#to_ecto/1","title":"AshSqlite.DataLayer.to_ecto/1","type":"function"},{"doc":"Resources that use `AshSqlite.DataLayer` use a `Repo` to access the database.\n\nThis repo is a thin wrapper around an `Ecto.Repo`.\n\nYou can use `Ecto.Repo`'s `init/2` to configure your repo like normal, but\ninstead of returning `{:ok, config}`, use `super(config)` to pass the\nconfiguration to the `AshSqlite.Repo` implementation.","ref":"AshSqlite.Repo.html","title":"AshSqlite.Repo","type":"behaviour"},{"doc":"Use this to inform the data layer about what extensions are installed","ref":"AshSqlite.Repo.html#c:installed_extensions/0","title":"AshSqlite.Repo.installed_extensions/0","type":"callback"},{"doc":"The path where your migrations are stored","ref":"AshSqlite.Repo.html#c:migrations_path/0","title":"AshSqlite.Repo.migrations_path/0","type":"callback"},{"doc":"Use this to inform the data layer about the oldest potential sqlite version it will be run on.\n\nMust be an integer greater than or equal to 13.","ref":"AshSqlite.Repo.html#c:min_pg_version/0","title":"AshSqlite.Repo.min_pg_version/0","type":"callback"},{"doc":"Allows overriding a given migration type for *all* fields, for example if you wanted to always use :timestamptz for :utc_datetime fields","ref":"AshSqlite.Repo.html#c:override_migration_type/1","title":"AshSqlite.Repo.override_migration_type/1","type":"callback"},{"doc":"A behavior for sqlite-specific manual relationship functionality","ref":"AshSqlite.ManualRelationship.html","title":"AshSqlite.ManualRelationship","type":"behaviour"},{"doc":"","ref":"AshSqlite.ManualRelationship.html#c:ash_sqlite_join/6","title":"AshSqlite.ManualRelationship.ash_sqlite_join/6","type":"callback"},{"doc":"","ref":"AshSqlite.ManualRelationship.html#c:ash_sqlite_subquery/4","title":"AshSqlite.ManualRelationship.ash_sqlite_subquery/4","type":"callback"},{"doc":"A custom extension implementation.","ref":"AshSqlite.CustomExtension.html","title":"AshSqlite.CustomExtension","type":"behaviour"},{"doc":"","ref":"AshSqlite.CustomExtension.html#c:install/1","title":"AshSqlite.CustomExtension.install/1","type":"callback"},{"doc":"","ref":"AshSqlite.CustomExtension.html#c:uninstall/1","title":"AshSqlite.CustomExtension.uninstall/1","type":"callback"},{"doc":"Represents a custom index on the table backing a resource","ref":"AshSqlite.CustomIndex.html","title":"AshSqlite.CustomIndex","type":"module"},{"doc":"","ref":"AshSqlite.CustomIndex.html#fields/0","title":"AshSqlite.CustomIndex.fields/0","type":"function"},{"doc":"","ref":"AshSqlite.CustomIndex.html#name/2","title":"AshSqlite.CustomIndex.name/2","type":"function"},{"doc":"","ref":"AshSqlite.CustomIndex.html#schema/0","title":"AshSqlite.CustomIndex.schema/0","type":"function"},{"doc":"","ref":"AshSqlite.CustomIndex.html#transform/1","title":"AshSqlite.CustomIndex.transform/1","type":"function"},{"doc":"Introspection functions for","ref":"AshSqlite.DataLayer.Info.html","title":"AshSqlite.DataLayer.Info","type":"module"},{"doc":"A stringified version of the base_filter, to be used in a where clause when generating unique indexes","ref":"AshSqlite.DataLayer.Info.html#base_filter_sql/1","title":"AshSqlite.DataLayer.Info.base_filter_sql/1","type":"function"},{"doc":"The configured custom_indexes for a resource","ref":"AshSqlite.DataLayer.Info.html#custom_indexes/1","title":"AshSqlite.DataLayer.Info.custom_indexes/1","type":"function"},{"doc":"The configured custom_statements for a resource","ref":"AshSqlite.DataLayer.Info.html#custom_statements/1","title":"AshSqlite.DataLayer.Info.custom_statements/1","type":"function"},{"doc":"The configured exclusion_constraint_names","ref":"AshSqlite.DataLayer.Info.html#exclusion_constraint_names/1","title":"AshSqlite.DataLayer.Info.exclusion_constraint_names/1","type":"function"},{"doc":"The configured foreign_key_names","ref":"AshSqlite.DataLayer.Info.html#foreign_key_names/1","title":"AshSqlite.DataLayer.Info.foreign_key_names/1","type":"function"},{"doc":"A list of keys to always include in upserts.","ref":"AshSqlite.DataLayer.Info.html#global_upsert_keys/1","title":"AshSqlite.DataLayer.Info.global_upsert_keys/1","type":"function"},{"doc":"The configured identity_index_names","ref":"AshSqlite.DataLayer.Info.html#identity_index_names/1","title":"AshSqlite.DataLayer.Info.identity_index_names/1","type":"function"},{"doc":"Whether or not the resource should be included when generating migrations","ref":"AshSqlite.DataLayer.Info.html#migrate?/1","title":"AshSqlite.DataLayer.Info.migrate?/1","type":"function"},{"doc":"A keyword list of customized migration defaults","ref":"AshSqlite.DataLayer.Info.html#migration_defaults/1","title":"AshSqlite.DataLayer.Info.migration_defaults/1","type":"function"},{"doc":"A list of attributes to be ignored when generating migrations","ref":"AshSqlite.DataLayer.Info.html#migration_ignore_attributes/1","title":"AshSqlite.DataLayer.Info.migration_ignore_attributes/1","type":"function"},{"doc":"A keyword list of customized migration types","ref":"AshSqlite.DataLayer.Info.html#migration_types/1","title":"AshSqlite.DataLayer.Info.migration_types/1","type":"function"},{"doc":"The configured polymorphic? for a resource","ref":"AshSqlite.DataLayer.Info.html#polymorphic?/1","title":"AshSqlite.DataLayer.Info.polymorphic?/1","type":"function"},{"doc":"The configured polymorphic_reference_name for a resource","ref":"AshSqlite.DataLayer.Info.html#polymorphic_name/1","title":"AshSqlite.DataLayer.Info.polymorphic_name/1","type":"function"},{"doc":"The configured polymorphic_reference_on_delete for a resource","ref":"AshSqlite.DataLayer.Info.html#polymorphic_on_delete/1","title":"AshSqlite.DataLayer.Info.polymorphic_on_delete/1","type":"function"},{"doc":"The configured polymorphic_reference_on_update for a resource","ref":"AshSqlite.DataLayer.Info.html#polymorphic_on_update/1","title":"AshSqlite.DataLayer.Info.polymorphic_on_update/1","type":"function"},{"doc":"The configured reference for a given relationship of a  resource","ref":"AshSqlite.DataLayer.Info.html#reference/2","title":"AshSqlite.DataLayer.Info.reference/2","type":"function"},{"doc":"The configured references for a resource","ref":"AshSqlite.DataLayer.Info.html#references/1","title":"AshSqlite.DataLayer.Info.references/1","type":"function"},{"doc":"The configured repo for a resource","ref":"AshSqlite.DataLayer.Info.html#repo/1","title":"AshSqlite.DataLayer.Info.repo/1","type":"function"},{"doc":"Identities not to include in the migrations","ref":"AshSqlite.DataLayer.Info.html#skip_identities/1","title":"AshSqlite.DataLayer.Info.skip_identities/1","type":"function"},{"doc":"Skip generating unique indexes when generating migrations","ref":"AshSqlite.DataLayer.Info.html#skip_unique_indexes/1","title":"AshSqlite.DataLayer.Info.skip_unique_indexes/1","type":"function"},{"doc":"The configured table for a resource","ref":"AshSqlite.DataLayer.Info.html#table/1","title":"AshSqlite.DataLayer.Info.table/1","type":"function"},{"doc":"The configured unique_index_names","ref":"AshSqlite.DataLayer.Info.html#unique_index_names/1","title":"AshSqlite.DataLayer.Info.unique_index_names/1","type":"function"},{"doc":"Represents the configuration of a reference (i.e foreign key).","ref":"AshSqlite.Reference.html","title":"AshSqlite.Reference","type":"module"},{"doc":"","ref":"AshSqlite.Reference.html#schema/0","title":"AshSqlite.Reference.schema/0","type":"function"},{"doc":"Represents a custom statement to be run in generated migrations","ref":"AshSqlite.Statement.html","title":"AshSqlite.Statement","type":"module"},{"doc":"","ref":"AshSqlite.Statement.html#fields/0","title":"AshSqlite.Statement.fields/0","type":"function"},{"doc":"","ref":"AshSqlite.Statement.html#schema/0","title":"AshSqlite.Statement.schema/0","type":"function"},{"doc":"Sqlite specific callbacks for `Ash.Type`.\n\nUse this in addition to `Ash.Type`.","ref":"AshSqlite.Type.html","title":"AshSqlite.Type","type":"behaviour"},{"doc":"","ref":"AshSqlite.Type.html#c:value_to_sqlite_default/3","title":"AshSqlite.Type.value_to_sqlite_default/3","type":"callback"},{"doc":"Maps to the builtin sqlite function `like`.","ref":"AshSqlite.Functions.Like.html","title":"AshSqlite.Functions.Like","type":"module"},{"doc":"","ref":"AshSqlite.Functions.Like.html#args/0","title":"AshSqlite.Functions.Like.args/0","type":"function"},{"doc":"Maps to the builtin sqlite function `ilike`.","ref":"AshSqlite.Functions.ILike.html","title":"AshSqlite.Functions.ILike","type":"module"},{"doc":"","ref":"AshSqlite.Functions.ILike.html#args/0","title":"AshSqlite.Functions.ILike.args/0","type":"function"},{"doc":"Create the storage for repos in all resources for the given (or configured) domains.","ref":"Mix.Tasks.AshSqlite.Create.html","title":"mix ash_sqlite.create","type":"task"},{"doc":"mix ash_sqlite.create\n    mix ash_sqlite.create --domains MyApp.Domain1,MyApp.Domain2","ref":"Mix.Tasks.AshSqlite.Create.html#module-examples","title":"Examples - mix ash_sqlite.create","type":"task"},{"doc":"* `--domains` - the domains who's repos you want to migrate.\n  * `--quiet` - do not log output\n  * `--no-compile` - do not compile before creating\n  * `--no-deps-check` - do not compile before creating","ref":"Mix.Tasks.AshSqlite.Create.html#module-command-line-options","title":"Command line options - mix ash_sqlite.create","type":"task"},{"doc":"Drop the storage for the given repository.","ref":"Mix.Tasks.AshSqlite.Drop.html","title":"mix ash_sqlite.drop","type":"task"},{"doc":"mix ash_sqlite.drop\n    mix ash_sqlite.drop -r MyApp.Domain1,MyApp.Domain2","ref":"Mix.Tasks.AshSqlite.Drop.html#module-examples","title":"Examples - mix ash_sqlite.drop","type":"task"},{"doc":"* `--doains` - the domains who's repos should be dropped\n  * `-q`, `--quiet` - run the command quietly\n  * `-f`, `--force` - do not ask for confirmation when dropping the database.\n    Configuration is asked only when `:start_permanent` is set to true\n    (typically in production)\n  * `--no-compile` - do not compile before dropping\n  * `--no-deps-check` - do not compile before dropping","ref":"Mix.Tasks.AshSqlite.Drop.html#module-command-line-options","title":"Command line options - mix ash_sqlite.drop","type":"task"},{"doc":"Generates migrations, and stores a snapshot of your resources.\n\nOptions:\n\n* `domains` - a comma separated list of domain modules, for which migrations will be generated\n* `snapshot-path` - a custom path to store the snapshots, defaults to \"priv/resource_snapshots\"\n* `migration-path` - a custom path to store the migrations, defaults to \"priv\".\n  Migrations are stored in a folder for each repo, so `priv/repo_name/migrations`\n* `drop-columns` - whether or not to drop columns as attributes are removed. See below for more\n* `name` -\n    names the generated migrations, prepending with the timestamp. The default is `migrate_resources_ `,\n    where ` ` is the count of migrations matching `*migrate_resources*` plus one.\n    For example, `--name add_special_column` would get a name like `20210708181402_add_special_column.exs`\n\nFlags:\n\n* `quiet` - messages for file creations will not be printed\n* `no-format` - files that are created will not be formatted with the code formatter\n* `dry-run` - no files are created, instead the new migration is printed\n* `check` - no files are created, returns an exit(1) code if the current snapshots and resources don't fit\n\n#### Snapshots\n\nSnapshots are stored in a folder for each table that migrations are generated for. Each snapshot is\nstored in a file with a timestamp of when it was generated.\nThis is important because it allows for simultaneous work to be done on separate branches, and for rolling back\nchanges more easily, e.g removing a generated migration, and deleting the most recent snapshot, without having to redo\nall of it\n\n#### Dropping columns\n\nGenerally speaking, it is bad practice to drop columns when you deploy a change that\nwould remove an attribute. The main reasons for this are backwards compatibility and rolling restarts.\nIf you deploy an attribute removal, and run migrations. Regardless of your deployment sstrategy, you\nwon't be able to roll back, because the data has been deleted. In a rolling restart situation, some of\nthe machines/pods/whatever may still be running after the column has been deleted, causing errors. With\nthis in mind, its best not to delete those columns until later, after the data has been confirmed unnecessary.\nTo that end, the migration generator leaves the column dropping code commented. You can pass `--drop_columns`\nto tell it to uncomment those statements. Additionally, you can just uncomment that code on a case by case\nbasis.\n\n#### Conflicts/Multiple Resources\n\nIt will raise on conflicts that it can't resolve, like the same field with different\ntypes. It will prompt to resolve conflicts that can be resolved with human input.\nFor example, if you remove an attribute and add an attribute, it will ask you if you are renaming\nthe column in question. If not, it will remove one column and add the other.\n\nAdditionally, it lowers things to the database where possible:\n\n#### Defaults\nThere are three anonymous functions that will translate to database-specific defaults currently:\n\n* `&DateTime.utc_now/0`\n\nNon-function default values will be dumped to their native type and inspected. This may not work for some types,\nand may require manual intervention/patches to the migration generator code.\n\n#### Identities\n\nIdentities will cause the migration generator to generate unique constraints. If multiple\nresources target the same table, you will be asked to select the primary key, and any others\nwill be added as unique constraints.","ref":"Mix.Tasks.AshSqlite.GenerateMigrations.html","title":"mix ash_sqlite.generate_migrations","type":"task"},{"doc":"","ref":"Mix.Tasks.AshSqlite.GenerateMigrations.html#run/1","title":"Mix.Tasks.AshSqlite.GenerateMigrations.run/1","type":"function"},{"doc":"Runs the pending migrations for the given repository.\n\nMigrations are expected at \"priv/YOUR_REPO/migrations\" directory\nof the current application, where \"YOUR_REPO\" is the last segment\nin your repository name. For example, the repository `MyApp.Repo`\nwill use \"priv/repo/migrations\". The repository `Whatever.MyRepo`\nwill use \"priv/my_repo/migrations\".\n\nThis task runs all pending migrations by default. To migrate up to a\nspecific version number, supply `--to version_number`. To migrate a\nspecific number of times, use `--step n`.\n\nThis is only really useful if your domain or domains only use a single repo.\nIf you have multiple repos and you want to run a single migration and/or\nmigrate/roll them back to different points, you will need to use the\necto specific task, `mix ecto.migrate` and provide your repo name.\n\nIf a repository has not yet been started, one will be started outside\nyour application supervision tree and shutdown afterwards.","ref":"Mix.Tasks.AshSqlite.Migrate.html","title":"mix ash_sqlite.migrate","type":"task"},{"doc":"mix ash_sqlite.migrate\n    mix ash_sqlite.migrate --domains MyApp.Domain1,MyApp.Domain2\n\n    mix ash_sqlite.migrate -n 3\n    mix ash_sqlite.migrate --step 3\n\n    mix ash_sqlite.migrate --to 20080906120000","ref":"Mix.Tasks.AshSqlite.Migrate.html#module-examples","title":"Examples - mix ash_sqlite.migrate","type":"task"},{"doc":"* `--domains` - the domains who's repos should be migrated\n\n  * `--all` - run all pending migrations\n\n  * `--step`, `-n` - run n number of pending migrations\n\n  * `--to` - run all migrations up to and including version\n\n  * `--quiet` - do not log migration commands\n\n  * `--pool-size` - the pool size if the repository is started only for the task (defaults to 2)\n\n  * `--log-sql` - log the raw sql migrations are running\n\n  * `--strict-version-order` - abort when applying a migration with old timestamp\n\n  * `--no-compile` - does not compile applications before migrating\n\n  * `--no-deps-check` - does not check depedendencies before migrating\n\n  * `--migrations-path` - the path to load the migrations from, defaults to\n    `\"priv/repo/migrations\"`. This option may be given multiple times in which case the migrations\n    are loaded from all the given directories and sorted as if they were in the same one.\n\n    Note, if you have migrations paths e.g. `a/` and `b/`, and run\n    `mix ecto.migrate --migrations-path a/`, the latest migrations from `a/` will be run (even\n    if `b/` contains the overall latest migrations.)","ref":"Mix.Tasks.AshSqlite.Migrate.html#module-command-line-options","title":"Command line options - mix ash_sqlite.migrate","type":"task"},{"doc":"Reverts applied migrations in the given repository.\nMigrations are expected at \"priv/YOUR_REPO/migrations\" directory\nof the current application but it can be configured by specifying\nthe `:priv` key under the repository configuration.\nRuns the latest applied migration by default. To roll back to\na version number, supply `--to version_number`. To roll back a\nspecific number of times, use `--step n`. To undo all applied\nmigrations, provide `--all`.\n\nThis is only really useful if your domain or domains only use a single repo.\nIf you have multiple repos and you want to run a single migration and/or\nmigrate/roll them back to different points, you will need to use the\necto specific task, `mix ecto.migrate` and provide your repo name.","ref":"Mix.Tasks.AshSqlite.Rollback.html","title":"mix ash_sqlite.rollback","type":"task"},{"doc":"mix ash_sqlite.rollback\n    mix ash_sqlite.rollback -r Custom.Repo\n    mix ash_sqlite.rollback -n 3\n    mix ash_sqlite.rollback --step 3\n    mix ash_sqlite.rollback -v 20080906120000\n    mix ash_sqlite.rollback --to 20080906120000","ref":"Mix.Tasks.AshSqlite.Rollback.html#module-examples","title":"Examples - mix ash_sqlite.rollback","type":"task"},{"doc":"* `--domains` - the domains who's repos should be rolledback\n  * `--all` - revert all applied migrations\n  * `--step` / `-n` - revert n number of applied migrations\n  * `--to` / `-v` - revert all migrations down to and including version\n  * `--quiet` - do not log migration commands\n  * `--pool-size` - the pool size if the repository is started only for the task (defaults to 1)\n  * `--log-sql` - log the raw sql migrations are running","ref":"Mix.Tasks.AshSqlite.Rollback.html#module-command-line-options","title":"Command line options - mix ash_sqlite.rollback","type":"task"},{"doc":"![Logo](https://github.com/ash-project/ash/blob/main/logos/cropped-for-header-black-text.png?raw=true#gh-light-mode-only)\n![Logo](https://github.com/ash-project/ash/blob/main/logos/cropped-for-header-white-text.png?raw=true#gh-dark-mojde-only)\n\n[![CI](https://github.com/ash-project/ash_sqlite/actions/workflows/elixir.yml/badge.svg)](https://github.com/ash-project/ash_sqlite/actions/workflows/elixir.yml)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Hex version badge](https://img.shields.io/hexpm/v/ash_sqlite.svg)](https://hex.pm/packages/ash_sqlite)\n[![Hexdocs badge](https://img.shields.io/badge/docs-hexdocs-purple)](https://hexdocs.pm/ash_sqlite)\n\n# AshSqlite\n\nWelcome! `AshSqlite` is the SQLite data layer for [Ash Framework](https://hexdocs.pm/ash).","ref":"readme.html","title":"Home","type":"extras"},{"doc":"- [Get Started](documentation/tutorials/getting-started-with-ash-sqlite.md)","ref":"readme.html#tutorials","title":"Tutorials - Home","type":"extras"},{"doc":"- [What is AshSqlite?](documentation/topics/about-ash-sqlite/what-is-ash-sqlite.md)","ref":"readme.html#topics","title":"Topics - Home","type":"extras"},{"doc":"- [References](documentation/topics/resources/references.md)\n- [Polymorphic Resources](documentation/topics/resources/polymorphic-resources.md)","ref":"readme.html#resources","title":"Resources - Home","type":"extras"},{"doc":"- [Migrations and tasks](documentation/topics/development/migrations-and-tasks.md)\n- [Testing](documentation/topics/development/testing.md)","ref":"readme.html#development","title":"Development - Home","type":"extras"},{"doc":"- [Expressions](documentation/topics/advanced/expressions.md)\n- [Manual Relationships](documentation/topics/advanced/manual-relationships.md)","ref":"readme.html#advanced","title":"Advanced - Home","type":"extras"},{"doc":"- [AshSqlite.DataLayer DSL](documentation/dsls/DSL:-AshSqlite.DataLayer.md)","ref":"readme.html#reference","title":"Reference - Home","type":"extras"},{"doc":"# Getting Started With AshSqlite","ref":"getting-started-with-ash-sqlite.html","title":"Getting Started With AshSqlite","type":"extras"},{"doc":"In this guide we will:\n\n1. Setup AshSqlite, which includes setting up [Ecto](https://hexdocs.pm/ecto/Ecto.html)\n2. Add AshSqlite to the resources created in [the Ash getting started guide](https://hexdocs.pm/ash/get-started.html)\n3. Show how the various features of AshSqlite can help you work quickly and cleanly against a sqlite database\n4. Highlight some of the more advanced features you can use when using AshSqlite.\n5. Point you to additional resources you may need on your journey","ref":"getting-started-with-ash-sqlite.html#goals","title":"Goals - Getting Started With AshSqlite","type":"extras"},{"doc":"- A working SQLite installation, with a sufficiently permissive user\n- If you would like to follow along, you will need to add begin with [the Ash getting started guide](https://hexdocs.pm/ash/get-started.html)","ref":"getting-started-with-ash-sqlite.html#requirements","title":"Requirements - Getting Started With AshSqlite","type":"extras"},{"doc":"","ref":"getting-started-with-ash-sqlite.html#steps","title":"Steps - Getting Started With AshSqlite","type":"extras"},{"doc":"Add the `:ash_sqlite` dependency to your application\n\n`{:ash_sqlite, \"~> 0.1.3\"}`\n\nAdd `:ash_sqlite` to your `.formatter.exs` file\n\n```elixir\n[\n  # import the formatter rules from `:ash_sqlite`\n  import_deps: [..., :ash_sqlite],\n  inputs: [...]\n]\n```","ref":"getting-started-with-ash-sqlite.html#add-ashsqlite","title":"Add AshSqlite - Getting Started With AshSqlite","type":"extras"},{"doc":"Create `lib/helpdesk/repo.ex` with the following contents. `AshSqlite.Repo` is a thin wrapper around `Ecto.Repo`, so see their documentation for how to use it if you need to use it directly. For standard Ash usage, all you will need to do is configure your resources to use your repo.\n\n```elixir\n# in lib/helpdesk/repo.ex\n\ndefmodule Helpdesk.Repo do\n  use AshSqlite.Repo, otp_app: :helpdesk\nend\n```\n\nNext we will need to create configuration files for various environments. Run the following to create the configuration files we need.\n\n```bash\nmkdir -p config\ntouch config/config.exs\ntouch config/dev.exs\ntouch config/runtime.exs\ntouch config/test.exs\n```\n\nPlace the following contents in those files, ensuring that the credentials match the user you created for your database. For most conventional installations this will work out of the box. If you've followed other guides before this one, they may have had you create these files already, so just make sure these contents are there.\n\n```elixir\n# in config/config.exs\nimport Config\n\n# This should already have been added in the first\n# getting started guide\nconfig :helpdesk,\n  ash_apis: [Helpdesk.Support]\n\nconfig :helpdesk,\n  ecto_repos: [Helpdesk.Repo]\n\n# Import environment specific config. This must remain at the bottom\n# of this file so it overrides the configuration defined above.\nimport_config \"#{config_env()}.exs\"\n```\n\n```elixir\n# in config/dev.exs\n\nimport Config\n\n# Configure your database\nconfig :helpdesk, Helpdesk.Repo,\n  database: Path.join(__DIR__, \"../path/to/your.db\"),\n  port: 5432,\n  show_sensitive_data_on_connection_error: true,\n  pool_size: 10\n```\n\n```elixir\n# in config/runtime.exs\n\nimport Config\n\nif config_env() == :prod do\n  config :helpdesk, Helpdesk.Repo,\n    pool_size: String.to_integer(System.get_env(\"POOL_SIZE\") || \"10\")\nend\n```\n\n```elixir\n# in config/test.exs\n\nimport Config\n\n# Configure your database\n#\n# The MIX_TEST_PARTITION environment variable can be used\n# to provide built-in test partitioning in CI environment.\n# Run `mix help test` for more information.\nconfig :helpdesk, Helpdesk.Repo,\n  database: Path.join(__DIR__, \"../path/to/your#{System.get_env(\"MIX_TEST_PARTITION\")}.db\"),\n  pool_size: 10\n```\n\nAnd finally, add the repo to your application\n\n```elixir\n# in lib/helpdesk/application.ex\n\n  def start(_type, _args) do\n    children = [\n      # Starts a worker by calling: Helpdesk.Worker.start_link(arg)\n      # {Helpdesk.Worker, arg}\n      Helpdesk.Repo\n    ]\n\n    ...\n```","ref":"getting-started-with-ash-sqlite.html#create-and-configure-your-repo","title":"Create and configure your Repo - Getting Started With AshSqlite","type":"extras"},{"doc":"Now we can add the data layer to our resources. The basic configuration for a resource requires the `d:AshSqlite.sqlite|table` and the `d:AshSqlite.sqlite|repo`.\n\n```elixir\n# in lib/helpdesk/support/resources/ticket.ex\n\n  use Ash.Resource,\n    domain: MyApp.Domain,\n    data_layer: AshSqlite.DataLayer\n\n  sqlite do\n    table \"tickets\"\n    repo Helpdesk.Repo\n  end\n```\n\n```elixir\n# in lib/helpdesk/support/resources/representative.ex\n\n  use Ash.Resource,\n    domain: MyApp.Domain,\n    data_layer: AshSqlite.DataLayer\n\n  sqlite do\n    table \"representatives\"\n    repo Helpdesk.Repo\n  end\n```","ref":"getting-started-with-ash-sqlite.html#add-ashsqlite-to-our-resources","title":"Add AshSqlite to our resources - Getting Started With AshSqlite","type":"extras"},{"doc":"First, we'll create the database with `mix ash_sqlite.create`.\n\nThen we will generate database migrations. This is one of the many ways that AshSqlite can save time and reduce complexity.\n\n```bash\nmix ash_sqlite.generate_migrations --name add_tickets_and_representatives\n```\n\nIf you are unfamiliar with database migrations, it is a good idea to get a rough idea of what they are and how they work. See the links at the bottom of this guide for more. A rough overview of how migrations work is that each time you need to make changes to your database, they are saved as small, reproducible scripts that can be applied in order. This is necessary both for clean deploys as well as working with multiple developers making changes to the structure of a single database.\n\nTypically, you need to write these by hand. AshSqlite, however, will store snapshots each time you run the command to generate migrations and will figure out what migrations need to be created.\n\nYou should always look at the generated migrations to ensure that they look correct. Do so now by looking at the generated file in `priv/repo/migrations`.\n\nFinally, we will create the local database and apply the generated migrations:\n\n```bash\nmix ash_sqlite.create\nmix ash_sqlite.migrate\n```","ref":"getting-started-with-ash-sqlite.html#create-the-database-and-tables","title":"Create the database and tables - Getting Started With AshSqlite","type":"extras"},{"doc":"And now we're ready to try it out! Run the following in iex:\n\nLets create some data. We'll make a representative and give them some open and some closed tickets.\n\n```elixir\nrequire Ash.Query\n\nrepresentative = (\n  Helpdesk.Support.Representative\n  |> Ash.Changeset.for_create(:create, %{name: \"Joe Armstrong\"})\n  |> Helpdesk.Support.create!()\n)\n\nfor i <- 0..5 do\n  ticket =\n    Helpdesk.Support.Ticket\n    |> Ash.Changeset.for_create(:open, %{subject: \"Issue #{i}\"})\n    |> Helpdesk.Support.create!()\n    |> Ash.Changeset.for_update(:assign, %{representative_id: representative.id})\n    |> Helpdesk.Support.update!()\n\n  if rem(i, 2) == 0 do\n    ticket\n    |> Ash.Changeset.for_update(:close)\n    |> Helpdesk.Support.update!()\n  end\nend\n```\n\nAnd now we can read that data. You should see some debug logs that show the sql queries AshSqlite is generating.\n\n```elixir\nrequire Ash.Query\n\n# Show the tickets where the subject equals \"foobar\"\nHelpdesk.Support.Ticket\n|> Ash.Query.filter(subject == \"foobar\")\n|> Helpdesk.Support.read!()\n```\n\n```elixir\nrequire Ash.Query\n\n# Show the tickets that are closed and their subject does not equal \"barbaz\"\nHelpdesk.Support.Ticket\n|> Ash.Query.filter(status == :closed and not(subject == \"barbaz\"))\n|> Helpdesk.Support.read!()\n```\n\nAnd, naturally, now that we are storing this in sqlite, this database is persisted even if we stop/start our application. The nice thing, however, is that this was the _exact_ same code that we ran against our resources when they were backed by ETS.","ref":"getting-started-with-ash-sqlite.html#try-it-out","title":"Try it out - Getting Started With AshSqlite","type":"extras"},{"doc":"Calculations can be pushed down into SQL using expressions.\n\nFor example, we can determine the percentage of tickets that are open:\n\n```elixir\n# in lib/helpdesk/support/resources/representative.ex\n\n  calculations do\n    calculate :percent_open, :float, expr(open_tickets / total_tickets )\n  end\n```\n\nCalculations can be loaded.\n\n```elixir\nrequire Ash.Query\n\nHelpdesk.Support.Representative\n|> Ash.Query.filter(percent_open > 0.25)\n|> Ash.Query.sort(:percent_open)\n|> Ash.Query.load(:percent_open)\n|> Helpdesk.Support.read!()\n```","ref":"getting-started-with-ash-sqlite.html#calculations","title":"Calculations - Getting Started With AshSqlite","type":"extras"},{"doc":"Take a look at the DSL documentation for more information on what you can configure. You can add check constraints, configure the behavior of foreign keys and more!","ref":"getting-started-with-ash-sqlite.html#rich-configuration-options","title":"Rich Configuration Options - Getting Started With AshSqlite","type":"extras"},{"doc":"When deploying, you will need to ensure that the file you are using in production is persisted in some way (probably, unless you want it to disappear whenever your deployed system restarts). For example with fly.io this might mean adding a volume to your deployment.","ref":"getting-started-with-ash-sqlite.html#deployment","title":"Deployment - Getting Started With AshSqlite","type":"extras"},{"doc":"- Check out the data layer docs: `AshSqlite.DataLayer`\n\n- [Ecto's documentation](https://hexdocs.pm/ecto/Ecto.html). AshSqlite (and much of Ash itself) is made possible by the amazing Ecto. If you find yourself looking for escape hatches when using Ash or ways to work directly with your database, you will want to know how Ecto works. Ash and AshSqlite intentionally do not hide Ecto, and in fact encourages its use whenever you need an escape hatch.\n\n- [Ecto's Migration documentation](https://hexdocs.pm/ecto_sql/Ecto.Migration.html) read more about migrations. Even with the ash_sqlite migration generator, you will very likely need to modify your own migrations some day.","ref":"getting-started-with-ash-sqlite.html#what-next","title":"What next? - Getting Started With AshSqlite","type":"extras"},{"doc":"# What is AshSqlite?\n\nAshSqlite is the SQLite `Ash.DataLayer` for [Ash Framework](https://hexdocs.pm/ash). This doesn't have all of the features of [AshPostgres](https://hexdocs.pm/ash_postgres), but it does support most of the features of Ash data layers. The main feature missing is Aggregate support.\n\nUse this to persist records in a SQLite table. For example, the resource below would be persisted in a table called `tweets`:\n\n```elixir\ndefmodule MyApp.Tweet do\n  use Ash.Resource,\n    data_layer: AshSQLite.DataLayer\n\n  attributes do\n    integer_primary_key :id\n    attribute :text, :string\n  end\n\n  relationships do\n    belongs_to :author, MyApp.User\n  end\n\n  sqlite do\n    table \"tweets\"\n    repo MyApp.Repo\n  end\nend\n```\n\nThe table might look like this:\n\n| id  | text            | author_id |\n| --- | --------------- | --------- |\n| 1   | \"Hello, world!\" | 1         |\n\nCreating records would add to the table, destroying records would remove from the table, and updating records would update the table.","ref":"what-is-ash-sqlite.html","title":"What is AshSqlite?","type":"extras"},{"doc":"# References\n\nTo configure the foreign keys on a resource, we use the `references` block.\n\nFor example:\n\n```elixir\nreferences do\n  reference :post, on_delete: :delete, on_update: :update, name: \"comments_to_posts_fkey\"\nend\n```","ref":"references.html","title":"References","type":"extras"},{"doc":"No resource logic is applied with these operations! No authorization rules or validations take place, and no notifications are issued. This operation happens *directly* in the database. That","ref":"references.html#important","title":"Important - References","type":"extras"},{"doc":"The difference between `:nothing` and `:restrict` is subtle and, if you are unsure, choose `:nothing` (the default behavior). `:restrict` will prevent the deletion from happening *before* the end of the database transaction, whereas `:nothing` allows the transaction to complete before doing so. This allows for things like updating or deleting the destination row and *then* updating updating or deleting the reference(as long as you are in a transaction).","ref":"references.html#nothing-vs-restrict","title":"Nothing vs Restrict - References","type":"extras"},{"doc":"This option is called `on_delete`, instead of `on_destroy`, because it is hooking into the database level deletion, *not* a `destroy` action in your resource.","ref":"references.html#on-delete","title":"On Delete - References","type":"extras"},{"doc":"# Polymorphic Resources\n\nTo support leveraging the same resource backed by multiple tables (useful for things like polymorphic associations), AshSqlite supports setting the `data_layer.table` context for a given resource. For this example, lets assume that you have a `MyApp.Post` resource and a `MyApp.Comment` resource. For each of those resources, users can submit `reactions`. However, you want a separate table for `post_reactions` and `comment_reactions`. You could accomplish that like so:\n\n```elixir\ndefmodule MyApp.Reaction do\n  use Ash.Resource,\n    domain: MyApp.Domain,\n    data_layer: AshSqlite.DataLayer\n\n   sqlite do\n    polymorphic? true # Without this, `table` is a required configuration\n  end\n\n  attributes do\n    attribute(:resource_id, :uuid)\n  end\n\n  ...\nend\n```\n\nThen, in your related resources, you set the table context like so:\n\n```elixir\ndefmodule MyApp.Post do\n  use Ash.Resource,\n    domain: MyApp.Domain,\n    data_layer: AshSqlite.DataLayer\n\n  ...\n\n  relationships do\n    has_many :reactions, MyApp.Reaction,\n      relationship_context: %{data_layer: %{table: \"post_reactions\"}},\n      destination_attribute: :resource_id\n  end\nend\n\ndefmodule MyApp.Comment do\n  use Ash.Resource,\n    domain: MyApp.Domain,\n    data_layer: AshSqlite.DataLayer\n\n  ...\n\n  relationships do\n    has_many :reactions, MyApp.Reaction,\n      relationship_context: %{data_layer: %{table: \"comment_reactions\"}},\n      destination_attribute: :resource_id\n  end\nend\n```\n\nWith this, when loading or editing related data, ash will automatically set that context.\nFor managing related data, see `Ash.Changeset.manage_relationship/4` and other relationship functions\nin `Ash.Changeset`","ref":"polymorphic-resources.html","title":"Polymorphic Resources","type":"extras"},{"doc":"To make actions use a specific table, you can use the `set_context` query preparation/change.\n\nFor example:\n\n```elixir\ndefmodule MyApp.Reaction do\n  actions do\n    read :for_comments do\n      prepare set_context(%{data_layer: %{table: \"comment_reactions\"}})\n    end\n\n    read :for_posts do\n      prepare set_context(%{data_layer: %{table: \"post_reactions\"}})\n    end\n  end\nend\n```","ref":"polymorphic-resources.html#table-specific-actions","title":"Table specific actions - Polymorphic Resources","type":"extras"},{"doc":"When a migration is marked as `polymorphic? true`, the migration generator will look at\nall resources that are related to it, that set the `%{data_layer: %{table: \"table\"}}` context.\nFor each of those, a migration is generated/managed automatically. This means that adding reactions\nto a new resource is as easy as adding the relationship and table context, and then running\n`mix ash_sqlite.generate_migrations`.","ref":"polymorphic-resources.html#migrations","title":"Migrations - Polymorphic Resources","type":"extras"},{"doc":"# Migrations","ref":"migrations-and-tasks.html","title":"Migrations","type":"extras"},{"doc":"Ash comes with its own tasks, and AshSqlite exposes lower level tasks that you can use if necessary. This guide shows the process using `ash.*` tasks, and the `ash_sqlite.*` tasks are illustrated at the bottom.","ref":"migrations-and-tasks.html#tasks","title":"Tasks - Migrations","type":"extras"},{"doc":"- Make resource changes\n- Run `mix ash.codegen --name add_a_combobulator` to generate migrations and resource snapshots\n- Run `mix ash.migrate` to run those migrations\n\nFor more information on generating migrations, run `mix help ash_sqlite.generate_migrations` (the underlying task that is called by `mix ash.migrate`)","ref":"migrations-and-tasks.html#basic-workflow","title":"Basic Workflow - Migrations","type":"extras"},{"doc":"Often, you will run into a situation where you want to make a slight change to a resource after you've already generated and run migrations. If you are using git and would like to undo those changes, then regenerate the migrations, this script may prove useful:\n\n```bash\n#!/bin/bash\n\n# Get count of untracked migrations\nN_MIGRATIONS=$(git ls-files --others priv/repo/migrations | wc -l)\n\n# Rollback untracked migrations\nmix ash_sqlite.rollback -n $N_MIGRATIONS\n\n# Delete untracked migrations and snapshots\ngit ls-files --others priv/repo/migrations | xargs rm\ngit ls-files --others priv/resource_snapshots | xargs rm\n\n# Regenerate migrations\nmix ash.codegen --name $1\n\n# Run migrations if flag\nif echo $* | grep -e \"-m\" -q\nthen\n  mix ash.migrate\nfi\n```\n\nAfter saving this file to something like `regen.sh`, make it executable with `chmod +x regen.sh`. Now you can run it with `./regen.sh name_of_operation`. If you would like the migrations to automatically run after regeneration, add the `-m` flag: `./regen.sh name_of_operation -m`.","ref":"migrations-and-tasks.html#regenerating-migrations","title":"Regenerating Migrations - Migrations","type":"extras"},{"doc":"If you are using multiple repos, you will likely need to use `mix ecto.migrate` and manage it separately for each repo, as the options would\nbe applied to both repo, which wouldn't make sense.","ref":"migrations-and-tasks.html#multiple-repos","title":"Multiple Repos - Migrations","type":"extras"},{"doc":"Define a module similar to the following:\n\n```elixir\ndefmodule MyApp.Release do\n  @moduledoc \"\"\"\n  Houses tasks that need to be executed in the released application (because mix is not present in releases).\n  \"\"\"\n  @app :my_ap\n  def migrate do\n    load_app()\n\n    for repo <- repos() do\n      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :up, all: true))\n    end\n  end\n\n  def rollback(repo, version) do\n    load_app()\n    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :down, to: version))\n  end\n\n  defp repos do\n    domains()\n    |> Enum.flat_map(fn domain ->\n      domain\n      |> Ash.Domain.Info.resources()\n      |> Enum.map(&AshSqlite.repo/1)\n    end)\n    |> Enum.uniq()\n  end\n\n  defp domains do\n    Application.fetch_env!(:my_app, :ash_domains)\n  end\n\n  defp load_app do\n    Application.load(@app)\n  end\nend\n```\n\n# AshSqlite-specific tasks\n\n- `mix ash_sqlite.generate_migrations`\n- `mix ash_sqlite.create`\n- `mix ash_sqlite.migrate`\n- `mix ash_sqlite.rollback`\n- `mix ash_sqlite.drop`","ref":"migrations-and-tasks.html#running-migrations-in-production","title":"Running Migrations in Production - Migrations","type":"extras"},{"doc":"# Testing With Sqlite\n\nTesting resources with SQLite generally requires passing `async?: false` to\nyour tests, due to `SQLite`'s limitation of having a single write transaction\nopen at any one time.\n\nThis should be coupled with to make sure that Ash does not spawn any tasks.\n\n```elixir\nconfig :ash, :disable_async?, true\n```","ref":"testing.html","title":"Testing With Sqlite","type":"extras"},{"doc":"# Expressions\n\nIn addition to the expressions listed in the [Ash expressions guide](https://hexdocs.pm/ash/expressions.html), AshSqlite provides the following expressions\n\n# Fragments\n\nFragments allow you to use arbitrary sqlite expressions in your queries. Fragments can often be an escape hatch to allow you to do things that don't have something officially supported with Ash.","ref":"expressions.html","title":"Expressions","type":"extras"},{"doc":"#### Simple expressions\n\n```elixir\nfragment(\"? / ?\", points, count)\n```\n\n#### Calling functions\n\n```elixir\nfragment(\"repeat('hello', 4)\")\n```\n\n#### Using entire queries\n\n```elixir\nfragment(\"points > (SELECT SUM(points) FROM games WHERE user_id = ? AND id != ?)\", user_id, id)\n```\n\n>","ref":"expressions.html#examples","title":"Examples - Expressions","type":"extras"},{"doc":">\n> Using entire queries as shown above is a last resort, but can sometimes be the best way to accomplish a given task.\n\n#### In calculations\n\n```elixir\ncalculations do\n  calculate :lower_name, :string, expr(\n    fragment(\"LOWER(?)\", name)\n  )\nend\n```\n\n#### In migrations\n\n```elixir\ncreate table(:managers, primary_key: false) do\n  add :id, :uuid, null: false, default: fragment(\"UUID_GENERATE_V4()\"), primary_key: true\nend\n```","ref":"expressions.html#a-last-resport-warning","title":"a last resport {: .warning} - Expressions","type":"extras"},{"doc":"These wrap the sqlite builtin like operator\n\nPlease be aware, these match _patterns_ not raw text. Use `contains/1` if you want to match text without supporting patterns, i.e `%` and `_` have semantic meaning!\n\nFor example:\n\n```elixir\nAsh.Query.filter(User, like(name, \"%obo%\")) # name contains obo anywhere in the string, case sensitively\n```","ref":"expressions.html#like","title":"Like - Expressions","type":"extras"},{"doc":"# Join Manual Relationships\n\nSee [Defining Manual Relationships](https://hexdocs.pm/ash/defining-manual-relationships.html) for an idea of manual relationships in general.\nManual relationships allow for expressing complex/non-typical relationships between resources in a standard way.\nIndividual data layers may interact with manual relationships in their own way, so see their corresponding guides.","ref":"manual-relationships.html","title":"Join Manual Relationships","type":"extras"},{"doc":"```elixir\n# in the resource\n\nrelationships do\n  has_many :tickets_above_threshold, Helpdesk.Support.Ticket do\n    manual Helpdesk.Support.Ticket.Relationships.TicketsAboveThreshold\n  end\nend\n\n# implementation\ndefmodule Helpdesk.Support.Ticket.Relationships.TicketsAboveThreshold do\n  use Ash.Resource.ManualRelationship\n  use AshSqlite.ManualRelationship\n\n  require Ash.Query\n  require Ecto.Query\n\n  def load(records, _opts, %{query: query, actor: actor, authorize?: authorize?}) do\n    # Use existing records to limit resultds\n    rep_ids = Enum.map(records, & &1.id)\n     # Using Ash to get the destination records is ideal, so you can authorize access like normal\n     # but if you need to use a raw ecto query here, you can. As long as you return the right structure.\n\n    {:ok,\n     query\n     |> Ash.Query.filter(representative_id in ^rep_ids)\n     |> Ash.Query.filter(priority > representative.priority_threshold)\n     |> Helpdesk.Support.read!(actor: actor, authorize?: authorize?)\n     # Return the items grouped by the primary key of the source, i.e representative.id => [...tickets above threshold]\n     |> Enum.group_by(& &1.representative_id)}\n  end\n\n  # query is the \"source\" query that is being built. \n\n  # _opts are options provided to the manual relationship, i.e `{Manual, opt: :val}`\n\n  # current_binding is what the source of the relationship is bound to. Access fields with `as(^current_binding).field`\n\n  # as_binding is the binding that your join should create. When you join, make sure you say `as: ^as_binding` on the\n  # part of the query that represents the destination of the relationship\n\n  # type is `:inner` or `:left`.\n  # destination_query is what you should join to to add the destination to the query, i.e `join: dest in ^destination-query`\n  def ash_sqlite_join(query, _opts, current_binding, as_binding, :inner, destination_query) do\n    {:ok,\n     Ecto.Query.from(_ in query,\n       join: dest in ^destination_query,\n       as: ^as_binding,\n       on: dest.representative_id == as(^current_binding).id,\n       on: dest.priority > as(^current_binding).priority_threshold\n     )}\n  end\n\n  def ash_sqlite_join(query, _opts, current_binding, as_binding, :left, destination_query) do\n    {:ok,\n     Ecto.Query.from(_ in query,\n       left_join: dest in ^destination_query,\n       as: ^as_binding,\n       on: dest.representative_id == as(^current_binding).id,\n       on: dest.priority > as(^current_binding).priority_threshold\n     )}\n  end\n\n  # _opts are options provided to the manual relationship, i.e `{Manual, opt: :val}`\n\n  # current_binding is what the source of the relationship is bound to. Access fields with `parent_as(^current_binding).field`\n\n  # as_binding is the binding that has already been created for your join. Access fields on it via `as(^as_binding)`\n\n  # destination_query is what you should use as the basis of your query\n  def ash_sqlite_subquery(_opts, current_binding, as_binding, destination_query) do\n    {:ok,\n     Ecto.Query.from(_ in destination_query,\n       where: parent_as(^current_binding).id == as(^as_binding).representative_id,\n       where: as(^as_binding).priority > parent_as(^current_binding).priority_threshold\n     )}\n  end\nend\n```","ref":"manual-relationships.html#example","title":"Example - Join Manual Relationships","type":"extras"},{"doc":"<!--\nThis file was generated by Spark. Do not edit it by hand.\n-->\n# DSL: AshSqlite.DataLayer\n\nA sqlite data layer that leverages Ecto's sqlite capabilities.","ref":"dsl-ashsqlite-datalayer.html","title":"DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"Sqlite data layer configuration","ref":"dsl-ashsqlite-datalayer.html#sqlite","title":"sqlite - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"* [custom_indexes](#sqlite-custom_indexes)\n   * index\n * [custom_statements](#sqlite-custom_statements)\n   * statement\n * [references](#sqlite-references)\n   * reference","ref":"dsl-ashsqlite-datalayer.html#nested-dsls","title":"Nested DSLs - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```\nsqlite do\n  repo MyApp.Repo\n  table \"organizations\"\nend\n\n```","ref":"dsl-ashsqlite-datalayer.html#examples","title":"Examples - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`repo`](#sqlite-repo){: #sqlite-repo .spark-required} | `atom` |  | The repo that will be used to fetch your data. See the `AshSqlite.Repo` documentation for more |\n| [`migrate?`](#sqlite-migrate?){: #sqlite-migrate? } | `boolean` | `true` | Whether or not to include this resource in the generated migrations with `mix ash.generate_migrations` |\n| [`migration_types`](#sqlite-migration_types){: #sqlite-migration_types } | `keyword` | `[]` | A keyword list of attribute names to the ecto migration type that should be used for that attribute. Only necessary if you need to override the defaults. |\n| [`migration_defaults`](#sqlite-migration_defaults){: #sqlite-migration_defaults } | `keyword` | `[]` | A keyword list of attribute names to the ecto migration default that should be used for that attribute. The string you use will be placed verbatim in the migration. Use fragments like `fragment(\\\\\"now()\\\\\")`, or for `nil`, use `\\\\\"nil\\\\\"`. |\n| [`base_filter_sql`](#sqlite-base_filter_sql){: #sqlite-base_filter_sql } | `String.t` |  | A raw sql version of the base_filter, e.g `representative = true`. Required if trying to create a unique constraint on a resource with a base_filter |\n| [`skip_unique_indexes`](#sqlite-skip_unique_indexes){: #sqlite-skip_unique_indexes } | `atom \\| list(atom)` | `false` | Skip generating unique indexes when generating migrations |\n| [`unique_index_names`](#sqlite-unique_index_names){: #sqlite-unique_index_names } | `list({list(atom), String.t} \\| {list(atom), String.t, String.t})` | `[]` | A list of unique index names that could raise errors that are not configured in identities, or an mfa to a function that takes a changeset and returns the list. In the format `{[:affected, :keys], \"name_of_constraint\"}` or `{[:affected, :keys], \"name_of_constraint\", \"custom error message\"}` |\n| [`exclusion_constraint_names`](#sqlite-exclusion_constraint_names){: #sqlite-exclusion_constraint_names } | `any` | `[]` | A list of exclusion constraint names that could raise errors. Must be in the format `{:affected_key, \"name_of_constraint\"}` or `{:affected_key, \"name_of_constraint\", \"custom error message\"}` |\n| [`identity_index_names`](#sqlite-identity_index_names){: #sqlite-identity_index_names } | `any` | `[]` | A keyword list of identity names to the unique index name that they should use when being managed by the migration generator. |\n| [`foreign_key_names`](#sqlite-foreign_key_names){: #sqlite-foreign_key_names } | `list({atom, String.t} \\| {String.t, String.t})` | `[]` | A list of foreign keys that could raise errors, or an mfa to a function that takes a changeset and returns a list. In the format: `{:key, \"name_of_constraint\"}` or `{:key, \"name_of_constraint\", \"custom error message\"}` |\n| [`migration_ignore_attributes`](#sqlite-migration_ignore_attributes){: #sqlite-migration_ignore_attributes } | `list(atom)` | `[]` | A list of attributes that will be ignored when generating migrations. |\n| [`table`](#sqlite-table){: #sqlite-table } | `String.t` |  | The table to store and read the resource from. If this is changed, the migration generator will not remove the old table. |\n| [`polymorphic?`](#sqlite-polymorphic?){: #sqlite-polymorphic? } | `boolean` | `false` | Declares this resource as polymorphic. See the [polymorphic resources guide](/documentation/topics/resources/polymorphic-resources.md) for more. |","ref":"dsl-ashsqlite-datalayer.html#options","title":"Options - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"A section for configuring indexes to be created by the migration generator.\n\nIn general, prefer to use `identities` for simple unique constraints. This is a tool to allow\nfor declaring more complex indexes.","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes","title":"sqlite.custom_indexes - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"* [index](#sqlite-custom_indexes-index)","ref":"dsl-ashsqlite-datalayer.html#nested-dsls","title":"Nested DSLs - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```\ncustom_indexes do\n  index [:column1, :column2], unique: true, where: \"thing = TRUE\"\nend\n\n```","ref":"dsl-ashsqlite-datalayer.html#examples","title":"Examples - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```elixir\nindex fields\n```\n\n\nAdd an index to be managed by the migration generator.","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_indexes-index","title":"sqlite.custom_indexes.index - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```\nindex [\"column\", \"column2\"], unique: true, where: \"thing = TRUE\"\n```","ref":"dsl-ashsqlite-datalayer.html#examples","title":"Examples - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`fields`](#sqlite-custom_indexes-index-fields){: #sqlite-custom_indexes-index-fields } | `atom \\| String.t \\| list(atom \\| String.t)` |  | The fields to include in the index. |","ref":"dsl-ashsqlite-datalayer.html#arguments","title":"Arguments - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#sqlite-custom_indexes-index-name){: #sqlite-custom_indexes-index-name } | `String.t` |  | the name of the index. Defaults to \"#{table}_#{column}_index\". |\n| [`unique`](#sqlite-custom_indexes-index-unique){: #sqlite-custom_indexes-index-unique } | `boolean` | `false` | indicates whether the index should be unique. |\n| [`using`](#sqlite-custom_indexes-index-using){: #sqlite-custom_indexes-index-using } | `String.t` |  | configures the index type. |\n| [`where`](#sqlite-custom_indexes-index-where){: #sqlite-custom_indexes-index-where } | `String.t` |  | specify conditions for a partial index. |\n| [`message`](#sqlite-custom_indexes-index-message){: #sqlite-custom_indexes-index-message } | `String.t` |  | A custom message to use for unique indexes that have been violated |\n| [`include`](#sqlite-custom_indexes-index-include){: #sqlite-custom_indexes-index-include } | `list(String.t)` |  | specify fields for a covering index. This is not supported by all databases. For more information on SQLite support, please read the official docs. |","ref":"dsl-ashsqlite-datalayer.html#options","title":"Options - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"Target: `AshSqlite.CustomIndex`","ref":"dsl-ashsqlite-datalayer.html#introspection","title":"Introspection - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"A section for configuring custom statements to be added to migrations.\n\nChanging custom statements may require manual intervention, because Ash can't determine what order they should run\nin (i.e if they depend on table structure that you've added, or vice versa). As such, any `down` statements we run\nfor custom statements happen first, and any `up` statements happen last.\n\nAdditionally, when changing a custom statement, we must make some assumptions, i.e that we should migrate\nthe old structure down using the previously configured `down` and recreate it.\n\nThis may not be desired, and so what you may end up doing is simply modifying the old migration and deleting whatever was\ngenerated by the migration generator. As always: read your migrations after generating them!","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_statements","title":"sqlite.custom_statements - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"* [statement](#sqlite-custom_statements-statement)","ref":"dsl-ashsqlite-datalayer.html#nested-dsls","title":"Nested DSLs - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```\ncustom_statements do\n  # the name is used to detect if you remove or modify the statement\n  statement :pgweb_idx do\n    up \"CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', title || ' ' || body));\"\n    down \"DROP INDEX pgweb_idx;\"\n  end\nend\n\n```","ref":"dsl-ashsqlite-datalayer.html#examples","title":"Examples - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```elixir\nstatement name\n```\n\n\nAdd a custom statement for migrations.","ref":"dsl-ashsqlite-datalayer.html#sqlite-custom_statements-statement","title":"sqlite.custom_statements.statement - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```\nstatement :pgweb_idx do\n  up \"CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', title || ' ' || body));\"\n  down \"DROP INDEX pgweb_idx;\"\nend\n\n```","ref":"dsl-ashsqlite-datalayer.html#examples","title":"Examples - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#sqlite-custom_statements-statement-name){: #sqlite-custom_statements-statement-name .spark-required} | `atom` |  | The name of the statement, must be unique within the resource |","ref":"dsl-ashsqlite-datalayer.html#arguments","title":"Arguments - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`up`](#sqlite-custom_statements-statement-up){: #sqlite-custom_statements-statement-up .spark-required} | `String.t` |  | How to create the structure of the statement |\n| [`down`](#sqlite-custom_statements-statement-down){: #sqlite-custom_statements-statement-down .spark-required} | `String.t` |  | How to tear down the structure of the statement |\n| [`code?`](#sqlite-custom_statements-statement-code?){: #sqlite-custom_statements-statement-code? } | `boolean` | `false` | By default, we place the strings inside of ecto migration's `execute/1` function and assume they are sql. Use this option if you want to provide custom elixir code to be placed directly in the migrations |","ref":"dsl-ashsqlite-datalayer.html#options","title":"Options - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"Target: `AshSqlite.Statement`","ref":"dsl-ashsqlite-datalayer.html#introspection","title":"Introspection - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"A section for configuring the references (foreign keys) in resource migrations.\n\nThis section is only relevant if you are using the migration generator with this resource.\nOtherwise, it has no effect.","ref":"dsl-ashsqlite-datalayer.html#sqlite-references","title":"sqlite.references - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"* [reference](#sqlite-references-reference)","ref":"dsl-ashsqlite-datalayer.html#nested-dsls","title":"Nested DSLs - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```\nreferences do\n  reference :post, on_delete: :delete, on_update: :update, name: \"comments_to_posts_fkey\"\nend\n\n```","ref":"dsl-ashsqlite-datalayer.html#examples","title":"Examples - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`polymorphic_on_delete`](#sqlite-references-polymorphic_on_delete){: #sqlite-references-polymorphic_on_delete } | `:delete \\| :nilify \\| :nothing \\| :restrict` |  | For polymorphic resources, configures the on_delete behavior of the automatically generated foreign keys to source tables. |\n| [`polymorphic_on_update`](#sqlite-references-polymorphic_on_update){: #sqlite-references-polymorphic_on_update } | `:update \\| :nilify \\| :nothing \\| :restrict` |  | For polymorphic resources, configures the on_update behavior of the automatically generated foreign keys to source tables. |\n| [`polymorphic_name`](#sqlite-references-polymorphic_name){: #sqlite-references-polymorphic_name } | `:update \\| :nilify \\| :nothing \\| :restrict` |  | For polymorphic resources, configures the on_update behavior of the automatically generated foreign keys to source tables. |","ref":"dsl-ashsqlite-datalayer.html#options","title":"Options - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```elixir\nreference relationship\n```\n\n\nConfigures the reference for a relationship in resource migrations.\n\nKeep in mind that multiple relationships can theoretically involve the same destination and foreign keys.\nIn those cases, you only need to configure the `reference` behavior for one of them. Any conflicts will result\nin an error, across this resource and any other resources that share a table with this one. For this reason,\ninstead of adding a reference configuration for `:nothing`, its best to just leave the configuration out, as that\nis the default behavior if *no* relationship anywhere has configured the behavior of that reference.","ref":"dsl-ashsqlite-datalayer.html#sqlite-references-reference","title":"sqlite.references.reference - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"```\nreference :post, on_delete: :delete, on_update: :update, name: \"comments_to_posts_fkey\"\n```","ref":"dsl-ashsqlite-datalayer.html#examples","title":"Examples - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`relationship`](#sqlite-references-reference-relationship){: #sqlite-references-reference-relationship .spark-required} | `atom` |  | The relationship to be configured |","ref":"dsl-ashsqlite-datalayer.html#arguments","title":"Arguments - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`ignore?`](#sqlite-references-reference-ignore?){: #sqlite-references-reference-ignore? } | `boolean` |  | If set to true, no reference is created for the given relationship. This is useful if you need to define it in some custom way |\n| [`on_delete`](#sqlite-references-reference-on_delete){: #sqlite-references-reference-on_delete } | `:delete \\| :nilify \\| :nothing \\| :restrict` |  | What should happen to records of this resource when the referenced record of the *destination* resource is deleted. |\n| [`on_update`](#sqlite-references-reference-on_update){: #sqlite-references-reference-on_update } | `:update \\| :nilify \\| :nothing \\| :restrict` |  | What should happen to records of this resource when the referenced destination_attribute of the *destination* record is update. |\n| [`deferrable`](#sqlite-references-reference-deferrable){: #sqlite-references-reference-deferrable } | `false \\| true \\| :initially` | `false` | Wether or not the constraint is deferrable. This only affects the migration generator. |\n| [`name`](#sqlite-references-reference-name){: #sqlite-references-reference-name } | `String.t` |  | The name of the foreign key to generate in the database. Defaults to  _ _fkey |","ref":"dsl-ashsqlite-datalayer.html#options","title":"Options - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"Target: `AshSqlite.Reference`\n\n\n\n\n\n\n\n .spark-required::after { content: \"*\"; color: red !important; }","ref":"dsl-ashsqlite-datalayer.html#introspection","title":"Introspection - DSL: AshSqlite.DataLayer","type":"extras"},{"doc":"# Change Log\n\nAll notable changes to this project will be documented in this file.\nSee [Conventional Commits](Https://conventionalcommits.org) for commit guidelines.\n\n<!-- changelog -->\n\n## [v0.1.3](https://github.com/ash-project/ash_sqlite/compare/v0.1.2...v0.1.3) (2024-05-31)","ref":"changelog.html","title":"Change Log","type":"extras"},{"doc":"* use `Ecto.ParameterizedType.init/2`\n\n* handle new/old ecto parameterized type format\n\n## [v0.1.2](https://github.com/ash-project/ash_sqlite/compare/v0.1.2-rc.1...v0.1.2) (2024-05-11)\n\n\n\n\n## [v0.1.2-rc.1](https://github.com/ash-project/ash_sqlite/compare/v0.1.2-rc.0...v0.1.2-rc.1) (2024-05-06)","ref":"changelog.html#bug-fixes","title":"Bug Fixes: - Change Log","type":"extras"},{"doc":"* properly scope deletes to the records in question\n\n* update ash_sqlite to get `ilike` behavior fix","ref":"changelog.html#bug-fixes","title":"Bug Fixes: - Change Log","type":"extras"},{"doc":"* support `contains` function\n\n## [v0.1.2-rc.0](https://github.com/ash-project/ash_sqlite/compare/v0.1.1...v0.1.2-rc.0) (2024-04-15)","ref":"changelog.html#improvements","title":"Improvements: - Change Log","type":"extras"},{"doc":"* reenable mix tasks that we need to call","ref":"changelog.html#bug-fixes","title":"Bug Fixes: - Change Log","type":"extras"},{"doc":"* support `mix ash.rollback`\n\n* support Ash 3.0, leverage `ash_sql` package\n\n* fix datetime migration type discovery\n\n## [v0.1.1](https://github.com/ash-project/ash_sqlite/compare/v0.1.0...v0.1.1) (2023-10-12)","ref":"changelog.html#improvements","title":"Improvements: - Change Log","type":"extras"},{"doc":"* add `SqliteMigrationDefault`\n\n* support query aggregates\n\n## [v0.1.0](https://github.com/ash-project/ash_sqlite/compare/v0.1.0...v0.1.0) (2023-10-12)","ref":"changelog.html#improvements","title":"Improvements: - Change Log","type":"extras"},{"doc":"* Port and adjust `AshPostgres` to `AshSqlite`","ref":"changelog.html#improvements","title":"Improvements: - Change Log","type":"extras"}],"producer":{"name":"ex_doc","version":[48,46,51,51,46,48]}}