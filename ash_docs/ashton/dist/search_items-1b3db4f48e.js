searchNodes=[{"ref":"Ashton.html","title":"Ashton","module":"Ashton","type":"module","doc":"Documentation for Ashton."},{"ref":"Ashton.html#document/1","title":"Ashton.document/1","module":"Ashton","type":"function","doc":"See Ashton.Doc.document/1."},{"ref":"Ashton.html#document/2","title":"Ashton.document/2","module":"Ashton","type":"function","doc":"See Ashton.Doc.document/2"},{"ref":"Ashton.html#merge/2","title":"Ashton.merge/2","module":"Ashton","type":"function","doc":"See Ashton.Schema.merge/2"},{"ref":"Ashton.html#merge/3","title":"Ashton.merge/3","module":"Ashton","type":"function","doc":"See Ashton.Schema.merge/3."},{"ref":"Ashton.html#schema/0","title":"Ashton.schema/0","module":"Ashton","type":"function","doc":"See Ashton.Schema.new/0."},{"ref":"Ashton.html#schema/1","title":"Ashton.schema/1","module":"Ashton","type":"function","doc":"See Ashton.Schema.new/1"},{"ref":"Ashton.html#validate/2","title":"Ashton.validate/2","module":"Ashton","type":"function","doc":""},{"ref":"Ashton.html#validate!/2","title":"Ashton.validate!/2","module":"Ashton","type":"function","doc":"Validates opts according to a schema or the constructor for a schema. Raises on invalid opts. iex&gt; Ashton.validate!([reticulate_splines?: true], opts: [:reticulate_splines?]) [reticulate_splines?: true] iex&gt; Ashton.validate!([reticulate_splines?: true], opts: [:load_textures?], extra_keys?: true) [reticulate_splines?: true] iex&gt; schema = Ashton.schema(opts: [:reticulate_splines?], required: [:reticulate_splines?], extra_keys?: true) ...&gt; Ashton.validate!([reticulate_splines?: true, hack_interwebs?: true], schema) [reticulate_splines?: true, hack_interwebs?: true] iex&gt; Ashton.validate!([], opts: [:reticulate_splines?], required: [:reticulate_splines?]) ** (ArgumentError) Opt Validation Error: reticulate_splines? - is required"},{"ref":"Ashton.html#t:error/0","title":"Ashton.error/0","module":"Ashton","type":"type","doc":""},{"ref":"Ashton.html#t:schema/0","title":"Ashton.schema/0","module":"Ashton","type":"type","doc":""},{"ref":"Ashton.html#t:validation_result/0","title":"Ashton.validation_result/0","module":"Ashton","type":"type","doc":""},{"ref":"Ashton.Doc.html","title":"Ashton.Doc","module":"Ashton.Doc","type":"module","doc":"Automatic opt documentation, to be placed into your function docstrings"},{"ref":"Ashton.Doc.html#document/2","title":"Ashton.Doc.document/2","module":"Ashton.Doc","type":"function","doc":"Opts name(:string): The top level header for the opts documentation - Default: &quot;Opts&quot; header_depth(:int): How many # to prepend before any heading - Default: 1"},{"ref":"Ashton.Doc.html#positive?/1","title":"Ashton.Doc.positive?/1","module":"Ashton.Doc","type":"function","doc":""},{"ref":"Ashton.Schema.html","title":"Ashton.Schema","module":"Ashton.Schema","type":"module","doc":"Functions for generating and validating the opts that generate a schema."},{"ref":"Ashton.Schema.html#merge/3","title":"Ashton.Schema.merge/3","module":"Ashton.Schema","type":"function","doc":"Merges two ashton schemas to create a superset schema. Opts annotate(:string): Annotates the source of the opt, to be used in displaying documentation. add_required?(:boolean): &quot;If true, all required fields from left/right are marked as required. Otherwise, only takes required fields from the left.&quot;"},{"ref":"Ashton.Schema.html#new/0","title":"Ashton.Schema.new/0","module":"Ashton.Schema","type":"function","doc":"Create a new schema. Opts opts([{:list, :atom}, :keyword]): A list of opts accepted, or a keyword of opt name to opt type - Default: [] required({:list, :atom}): A list of required opts (all of which must be in opts as well) - Default: [] defaults(:keyword): A keyword list of option name to a default value. Values must pass type rules - Default: [] extra_keys?(:boolean): If enabled, extra keys not specified by the schema do not fail validation - Default: false custom(:keyword): A keyword list of option name (for errors) and custom validations. See README - Default: [] describe(:keyword): A keyword list of option names to short descriptions (like these) - Default: [] A custom validation is run on the types provided at schema creation time, to ensure they are all valid types."},{"ref":"Ashton.Schema.html#new/1","title":"Ashton.Schema.new/1","module":"Ashton.Schema","type":"function","doc":""},{"ref":"Ashton.Schema.html#t:t/0","title":"Ashton.Schema.t/0","module":"Ashton.Schema","type":"type","doc":""},{"ref":"Ashton.SchemaHelpers.html","title":"Ashton.SchemaHelpers","module":"Ashton.SchemaHelpers","type":"module","doc":"Helpers for building and working with schemas."},{"ref":"Ashton.SchemaHelpers.html#merge_schema/0","title":"Ashton.SchemaHelpers.merge_schema/0","module":"Ashton.SchemaHelpers","type":"function","doc":"The schema of the opts for merging two ashton schemas"},{"ref":"Ashton.SchemaHelpers.html#schema_schema/0","title":"Ashton.SchemaHelpers.schema_schema/0","module":"Ashton.SchemaHelpers","type":"function","doc":"The schema of the opts for making an Ashton schema."},{"ref":"Ashton.Type.html","title":"Ashton.Type","module":"Ashton.Type","type":"module","doc":"Exposes functions for validating types, and determining if a value matches a type."},{"ref":"Ashton.Type.html#format_type/2","title":"Ashton.Type.format_type/2","module":"Ashton.Type","type":"function","doc":""},{"ref":"Ashton.Type.html#matches_type?/2","title":"Ashton.Type.matches_type?/2","module":"Ashton.Type","type":"function","doc":""},{"ref":"Ashton.Type.html#merge/2","title":"Ashton.Type.merge/2","module":"Ashton.Type","type":"function","doc":""},{"ref":"Ashton.Type.html#valid_type?/1","title":"Ashton.Type.valid_type?/1","module":"Ashton.Type","type":"function","doc":""},{"ref":"Ashton.Type.html#validate_types/4","title":"Ashton.Type.validate_types/4","module":"Ashton.Type","type":"function","doc":""},{"ref":"readme.html","title":"Ashton","module":"readme","type":"extras","doc":"Ashton Ashton is forked from albert-io/optimal, which I developed while I worked there. I needed to own its development cycle, so I&#39;ve forked it here to ashton. All credit to those at albert.io who contributed to the development, and thanks to them for allowing it to be contributed to open source! Ashton is a schema based opt validator. It is verbose, but I&#39;ve tried many other data validation libraries, and their succinctness came with a cost when it came to features. There are still a lot of optimizations and improvements that can be made, so contributions are very welcome. This opt validator has a bit of a niche. It fits in just fine with validating any keyword list, but its especially useful for validating compile-time options, like ones provided to functions in a DSL. View the documentation: https://hexdocs.pm/ashton"},{"ref":"readme.html#roadmap","title":"Ashton - Roadmap","module":"readme","type":"extras","doc":"Better error messages, both for type mismatches and in general Optimize. The schema based design allows schemas to be declared at compile time (for instance in module attributes) and that should be leveraged as much as possible to ensure that validating a schema does no work that could be done when building the schema. Macro. We could potentially provide something that can partially validate opts at compile time. For instance, any literal values or known values could be validated at compile time."},{"ref":"readme.html#installation","title":"Ashton - Installation","module":"readme","type":"extras","doc":"If available in Hex, the package can be installed by adding ashton to your list of dependencies in mix.exs: def deps do [ {:ashton, &quot;~&gt; 0.4.1&quot;} ] end"},{"ref":"readme.html#getting-started","title":"Ashton - Getting Started","module":"readme","type":"extras","doc":"Validation Examples To use Ashton, you define your validation rules as an Ashton schema and then validate input against it using the Ashton.validate/2 or Ashton.validate!/2 functions. Validate a keyword list: iex&gt; schema = Ashton.schema(opts: [:foo, :bar, :baz]) iex&gt; my_list = [{:foo, &quot;foo val&quot;}, {:bar, &quot;bar val&quot;}, {:baz, &quot;bazz val&quot;}] iex&gt; Ashton.validate(my_list, schema) {:ok, [foo: &quot;foo val&quot;, bar: &quot;bar val&quot;, baz: &quot;bazz val&quot;]} Or validate a map: iex&gt; my_map = %{foo: &quot;foo val&quot;, bar: &quot;bar val&quot;, baz: &quot;bazz val&quot;} %{bar: &quot;bar val&quot;, baz: &quot;bazz val&quot;, foo: &quot;foo val&quot;} iex&gt; Ashton.validate(my_map, schema) {:ok, [bar: &quot;bar val&quot;, baz: &quot;bazz val&quot;, foo: &quot;foo val&quot;]} Notice that in both cases, a keyword list is returned. Use Ashton.validate!/2 to return an error instead of a tuple: iex&gt; bad_map = %{d: &quot;not allowed&quot;} %{other: &quot;stuff&quot;} iex&gt; schema = Ashton.schema(opts: [:a, :b, :c]) iex&gt; Ashton.validate!(bad_map, schema) ** (ArgumentError) Opt Validation Error: other - is not allowed (no extra keys) (ashton) lib/ashton.ex:44: Ashton.validate!/2 You can require that your inputs be of a certain type: iex&gt; schema = Ashton.schema(opts: [age: :int, name: :string]) iex&gt; my_data = [{:age, 12}, {:name, false}] iex&gt; Ashton.validate(my_data, schema) {:error, [name: &quot;must be string&quot;]} Schema Examples Define your validation rules in your schema. # Allow no opts Ashton.schema() # Allow any opts Ashton.schema(extra_keys?: true) # Allow a specific set of opts Ashton.schema(opts: [:foo, :bar, :baz]) # Allow specific types Ashton.schema(opts: [foo: :int, bar: :string, baz: :pid]) # Require certain opts Ashton.schema(opts: [foo: :int, bar: :string, baz: :pid], required: [:foo, :bar]) # Provide defaults for arguments (defaults will have to pass any type validation) # If they provide they key, but a `nil` value, the default is *not* used. Ashton.schema(opts: [foo: :int, bar: :string, baz: :boolean], defaults: [baz: true]) # Allow only specific values for certain opts Ashton.schema(opts: [foo: {:enum, [1, 2, 3]}]) # Custom validations # Read below for more info def custom(field_value, field_name, all_opts, schema) do if is_special(field_value) do :ok else [{field_name, &quot;must be special&quot;}] end end Ashton.schema(opts: [foo: :integer, bar: :string], custom: [bar: &amp;custom/4])"},{"ref":"readme.html#types","title":"Ashton - Types","module":"readme","type":"extras","doc":"Scalar Types :any :atom :binary :bitstring :boolean :float :function :int :integer :keyword :list :string :map :nil :number :pid :port :reference :tuple :struct Composite/Complex Types {:keyword, value_type} - Keyword where all values are of type value_type {:list, value_type} - List where all values are of type value_type {:function, arity} - A function with the arity given by arity {:struct, Some.Struct} - An instance of Some.Struct %Some.Struct{} - Same as {:struct, Some.Struct} {:enum, [value1, value2]} - Allows any value in the list. {:tuple, tuple_size} - Tuple with size tuple_size. {:tuple, {type1, type2, ...}} - Tuple with given type structure, so the first element is of type type1, etc. {:tuple, tuple_size, value_type} - Tuple with size tuple_size and every element of type value_type. {:const, value} - Passes if the validating value exactly matches the type value A nested ashton schema - Will validate that the provided keyword list adheres to the schema."},{"ref":"readme.html#custom-validations","title":"Ashton - Custom Validations","module":"readme","type":"extras","doc":"Your custom validators are defined as keyword list added to the custom: atom, e.g. Ashton.schema(opts: [foo: :integer, bar: :string], custom: [bar: &amp;my_custom_validator/4]) Custom validations have the ability to add arbitrary errors and can modify the opts as they pass through. They are run in order, and unlike all built in validations, they are only run on valid opts. In other words, the custom validators run after the other validators. Your custom validation functions should receive 4 arguments: field value field id (atom) options schema And they may return several different types of responses: true / false to indicate whether it passed or failed validation :ok to indicate that it passed validation {:ok, updated_options} to provide modifications to the options before output {:error, error_or_errors} to provide a custom message(s) about a failed validation [] to indicate that it passed validation a list of errors to indicate why it failed validation Custom Validator Usage Example Because custom validators can modify the opts, we can change the final output to a map (arbitrarily, this validation rule is attached to the c field): iex&gt; my_data = [{:a, &quot;Apple&quot;}, {:b, &quot;Boy&quot;}, {:c, &quot;Cat&quot;}] iex&gt; schema = Ashton.schema(opts: [a: :string, b: :string, c: :string], custom: [c: fn _, _, opts, _ -&gt; {:ok, Enum.into(opts, %{})} end]) iex&gt; Ashton.validate(my_data, schema) {:ok, %{a: &quot;Apple&quot;, b: &quot;Boy&quot;, c: &quot;Cat&quot;} Custom Validation Function Examples # Simple (returning booleans) def is_ten(field_value, _, _, _) do field_value == 10 end # Custom errors (ok/error tuples) def is_ten(field_value, field, _, _) do if field_value == 10 do :ok else {:error, {field, &quot;should really have equaled ten&quot;}} end end # Returning a list of errors def greater_than_1_and_even(field_value, field, _, _) do errors = if field_value &gt; 1 do [] else [{field, &quot;should be greater than 1&quot;}] end if Integer.is_even(field_value) do errors else [{field, &quot;should be even&quot;} | errors] end end"},{"ref":"readme.html#auto-documentation","title":"Ashton - Auto Documentation","module":"readme","type":"extras","doc":"If your schemas are defined at compile time, it is possible to interpolate a generated documentation for them into your docstrings. If you are doing this, you may also want to leverage the describe opt when building schemas, that lets you attach descriptions. For example: @opts Ashton.schema(opts: [ foo: [:int, :string], bars: {:list, :int} ], required: [:foo], describe: [ foo: &quot;The id of the foo you want&quot;, bars: &quot;The ids of all of the bars you want&quot; ], defaults: [ bars: [] ], extra_keys?: true ) @doc &quot;&quot;&quot; This does a special thing. \#{Ashton.Doc.document(@opts)} More in-depth documentation &quot;&quot;&quot; def my_special_function(opts) do end This would generate a docstring that looks like: Doc Example This does a special thing."},{"ref":"readme.html#opts","title":"Ashton - Opts","module":"readme","type":"extras","doc":"foo([:int, :string]) Required: The id of the foo you want bars({:list, :int}): The ids of all of the bars you want - Default: [] Also accepts extra opts that are not named here. More in-depth documentation"},{"ref":"readme.html#schema-merging","title":"Ashton - Schema merging","module":"readme","type":"extras","doc":"This behavior is not set in stone, and will probably need to take a strategy option to support different kinds of merging opt schemas. This is very useful when working with many functions that are more specific versions of some generic action, or that all eventually call into the same function and need to accept that function&#39;s opts as well. schema1 = Ashton.schema(opts: [foo: :int]) schema2 = Ashton.schema(opts: [foo: :string, bar: :int]) Ashton.merge(schema1, schema2) == Ashton.schema(opts: [foo: [:int, :string], bar: :int]) Merge annotations You can provide an annotation when merging, and options will be further grouped by that annotation. Ashton.merge(schema1, schema2, annotate: &quot;Shared&quot;) id(:int) Required foo(:int) Shared baz(:int) bar(:int)"}]