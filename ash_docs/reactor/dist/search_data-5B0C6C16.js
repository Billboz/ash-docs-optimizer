searchData={"content_type":"text/markdown","items":[{"doc":"Specify which step result to return upon completion.\n","ref":"dsl-reactor.html#reactor-switch-default-return","title":"Reactor.reactor.switch.default.return","type":"DSL"},{"doc":"If none of the `matches?` branches match the input, then the `default`\nsteps will be run if provided.\n","ref":"dsl-reactor.html#reactor-switch-default","title":"Reactor.reactor.switch.default","type":"DSL"},{"doc":"Specify which step result to return upon completion.\n","ref":"dsl-reactor.html#reactor-switch-matches?-return","title":"Reactor.reactor.switch.matches?.return","type":"DSL"},{"doc":"Whether the emitted steps should be allowed to run asynchronously.\n","ref":"dsl-reactor.html#reactor-switch-matches?-allow_async?","title":"Reactor.reactor.switch.matches?.allow_async?","type":"DSL"},{"doc":"A one-arity function which is used to match the switch input. If the switch returns a truthy value, then the nested steps will be run.\n","ref":"dsl-reactor.html#reactor-switch-matches?-predicate","title":"Reactor.reactor.switch.matches?.predicate","type":"DSL"},{"doc":"A group of steps to run when the predicate matches.\n","ref":"dsl-reactor.html#reactor-switch-matches?","title":"Reactor.reactor.switch.matches?","type":"DSL"},{"doc":"The value to match against.\n","ref":"dsl-reactor.html#reactor-switch-on","title":"Reactor.reactor.switch.on","type":"DSL"},{"doc":"Whether the emitted steps should be allowed to run asynchronously.\n","ref":"dsl-reactor.html#reactor-switch-allow_async?","title":"Reactor.reactor.switch.allow_async?","type":"DSL"},{"doc":"A unique name for the switch.\n","ref":"dsl-reactor.html#reactor-switch-name","title":"Reactor.reactor.switch.name","type":"DSL"},{"doc":"Use a predicate to determine which steps should be executed.\n","ref":"dsl-reactor.html#reactor-switch","title":"Reactor.reactor.switch","type":"DSL"},{"doc":"The name of the step to wait for.\n","ref":"dsl-reactor.html#reactor-step-wait_for-names","title":"Reactor.reactor.step.wait_for.names","type":"DSL"},{"doc":"Wait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`\n","ref":"dsl-reactor.html#reactor-step-wait_for","title":"Reactor.reactor.step.wait_for","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the argument before it is passed to the step.\n","ref":"dsl-reactor.html#reactor-step-argument-transform","title":"Reactor.reactor.step.argument.transform","type":"DSL"},{"doc":"What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.\n","ref":"dsl-reactor.html#reactor-step-argument-source","title":"Reactor.reactor.step.argument.source","type":"DSL"},{"doc":"The name of the argument which will be used as the key in the `arguments` map passed to the implementation.\n","ref":"dsl-reactor.html#reactor-step-argument-name","title":"Reactor.reactor.step.argument.name","type":"DSL"},{"doc":"Specifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.\n","ref":"dsl-reactor.html#reactor-step-argument","title":"Reactor.reactor.step.argument","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the entire argument map before it is passed to the step.\n","ref":"dsl-reactor.html#reactor-step-transform","title":"Reactor.reactor.step.transform","type":"DSL"},{"doc":"When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`.\n","ref":"dsl-reactor.html#reactor-step-async?","title":"Reactor.reactor.step.async?","type":"DSL"},{"doc":"The maximum number of times that the step can be retried before failing. Only used when the result of the `compensate/4` callback is `:retry`.\n","ref":"dsl-reactor.html#reactor-step-max_retries","title":"Reactor.reactor.step.max_retries","type":"DSL"},{"doc":"Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument.\n","ref":"dsl-reactor.html#reactor-step-compensate","title":"Reactor.reactor.step.compensate","type":"DSL"},{"doc":"Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument.\n","ref":"dsl-reactor.html#reactor-step-undo","title":"Reactor.reactor.step.undo","type":"DSL"},{"doc":"Provide an anonymous function which implements the `run/3` callback. Cannot be provided at the same time as the `impl` argument.\n","ref":"dsl-reactor.html#reactor-step-run","title":"Reactor.reactor.step.run","type":"DSL"},{"doc":"A module that implements the `Reactor.Step` behaviour that provides the implementation.\n","ref":"dsl-reactor.html#reactor-step-impl","title":"Reactor.reactor.step.impl","type":"DSL"},{"doc":"A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps.\n","ref":"dsl-reactor.html#reactor-step-name","title":"Reactor.reactor.step.name","type":"DSL"},{"doc":"Specifies a Reactor step.\n\nSteps are the unit of work in a Reactor.  Reactor will calculate the\ndependencies graph between the steps and execute as many as it can in each\niteration.\n\nSee the `Reactor.Step` behaviour for more information.\n","ref":"dsl-reactor.html#reactor-step","title":"Reactor.reactor.step","type":"DSL"},{"doc":"The name of the step to wait for.\n","ref":"dsl-reactor.html#reactor-map-wait_for-names","title":"Reactor.reactor.map.wait_for.names","type":"DSL"},{"doc":"Wait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`\n","ref":"dsl-reactor.html#reactor-map-wait_for","title":"Reactor.reactor.map.wait_for","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the argument before it is passed to the step.\n","ref":"dsl-reactor.html#reactor-map-argument-transform","title":"Reactor.reactor.map.argument.transform","type":"DSL"},{"doc":"What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.\n","ref":"dsl-reactor.html#reactor-map-argument-source","title":"Reactor.reactor.map.argument.source","type":"DSL"},{"doc":"The name of the argument which will be used as the key in the `arguments` map passed to the implementation.\n","ref":"dsl-reactor.html#reactor-map-argument-name","title":"Reactor.reactor.map.argument.name","type":"DSL"},{"doc":"Specifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.\n","ref":"dsl-reactor.html#reactor-map-argument","title":"Reactor.reactor.map.argument","type":"DSL"},{"doc":"Whether the mapped values must be returned in the same order that they were provided.\n","ref":"dsl-reactor.html#reactor-map-strict_ordering?","title":"Reactor.reactor.map.strict_ordering?","type":"DSL"},{"doc":"The name of the nested step to use as the return value.\n","ref":"dsl-reactor.html#reactor-map-return","title":"Reactor.reactor.map.return","type":"DSL"},{"doc":"The iterator or enumerable to use as the source of the iteration.\n","ref":"dsl-reactor.html#reactor-map-source","title":"Reactor.reactor.map.source","type":"DSL"},{"doc":"The number of items to consume off the source when emitting steps.\n","ref":"dsl-reactor.html#reactor-map-batch_size","title":"Reactor.reactor.map.batch_size","type":"DSL"},{"doc":"Whether the emitted steps should be allowed to run asynchronously.\n","ref":"dsl-reactor.html#reactor-map-allow_async?","title":"Reactor.reactor.map.allow_async?","type":"DSL"},{"doc":"A unique name for the step.\n","ref":"dsl-reactor.html#reactor-map-name","title":"Reactor.reactor.map.name","type":"DSL"},{"doc":"Execute nested steps for every item of an iterator.\n\nAllows you to \"map over\" a collection applying a some steps to each element,\nreturning a list of new values.  The input collection must be bounded - ie you\ncannot pass infinite streams into this step or it will just loop forever - and\nbecause it has to keep the results from each batch will eventually just use up\nall available RAM.\n\nUnder the hood we use `Iter` to handle lazy iteration of the collection.  This\nmeans that you can pass an `Iter.t` or any value for which `Iter.IntoIterable`\nis implemented.\n\n> #### A note on ordering {: .tip}\n>\n> If your application doesn't need the results back in the same order that they\n> were provided then setting `strict_ordering?` to `false` will increase\n> performance - especially on large input sets.\n","ref":"dsl-reactor.html#reactor-map","title":"Reactor.reactor.map","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the input before it is passed to any steps.\n","ref":"dsl-reactor.html#reactor-input-transform","title":"Reactor.reactor.input.transform","type":"DSL"},{"doc":"A unique name for this input. Used to allow steps to depend on it.\n","ref":"dsl-reactor.html#reactor-input-name","title":"Reactor.reactor.input.name","type":"DSL"},{"doc":"Specifies an input to the Reactor.\n\nAn input is a value passed in to the Reactor when executing.\nIf a Reactor were a function, these would be it's arguments.\n\nInputs can be transformed with an arbitrary function before being passed\nto any steps.\n","ref":"dsl-reactor.html#reactor-input","title":"Reactor.reactor.input","type":"DSL"},{"doc":"The name of the step to wait for.\n","ref":"dsl-reactor.html#reactor-group-wait_for-names","title":"Reactor.reactor.group.wait_for.names","type":"DSL"},{"doc":"Wait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`\n","ref":"dsl-reactor.html#reactor-group-wait_for","title":"Reactor.reactor.group.wait_for","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the argument before it is passed to the step.\n","ref":"dsl-reactor.html#reactor-group-argument-transform","title":"Reactor.reactor.group.argument.transform","type":"DSL"},{"doc":"What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.\n","ref":"dsl-reactor.html#reactor-group-argument-source","title":"Reactor.reactor.group.argument.source","type":"DSL"},{"doc":"The name of the argument which will be used as the key in the `arguments` map passed to the implementation.\n","ref":"dsl-reactor.html#reactor-group-argument-name","title":"Reactor.reactor.group.argument.name","type":"DSL"},{"doc":"Specifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.\n","ref":"dsl-reactor.html#reactor-group-argument","title":"Reactor.reactor.group.argument","type":"DSL"},{"doc":"Whether the emitted steps should be allowed to run asynchronously.\n","ref":"dsl-reactor.html#reactor-group-allow_async?","title":"Reactor.reactor.group.allow_async?","type":"DSL"},{"doc":"The after function. See `Reactor.Step.Group` for more information.\n","ref":"dsl-reactor.html#reactor-group-after_all","title":"Reactor.reactor.group.after_all","type":"DSL"},{"doc":"The before function. See `Reactor.Step.Group` for more information.\n","ref":"dsl-reactor.html#reactor-group-before_all","title":"Reactor.reactor.group.before_all","type":"DSL"},{"doc":"A unique name for the group of steps.\n","ref":"dsl-reactor.html#reactor-group-name","title":"Reactor.reactor.group.name","type":"DSL"},{"doc":"Call functions before and after a group of steps.\n","ref":"dsl-reactor.html#reactor-group","title":"Reactor.reactor.group","type":"DSL"},{"doc":"The name of the step to wait for.\n","ref":"dsl-reactor.html#reactor-debug-wait_for-names","title":"Reactor.reactor.debug.wait_for.names","type":"DSL"},{"doc":"Wait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`\n","ref":"dsl-reactor.html#reactor-debug-wait_for","title":"Reactor.reactor.debug.wait_for","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the argument before it is passed to the step.\n","ref":"dsl-reactor.html#reactor-debug-argument-transform","title":"Reactor.reactor.debug.argument.transform","type":"DSL"},{"doc":"What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.\n","ref":"dsl-reactor.html#reactor-debug-argument-source","title":"Reactor.reactor.debug.argument.source","type":"DSL"},{"doc":"The name of the argument which will be used as the key in the `arguments` map passed to the implementation.\n","ref":"dsl-reactor.html#reactor-debug-argument-name","title":"Reactor.reactor.debug.argument.name","type":"DSL"},{"doc":"Specifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.\n","ref":"dsl-reactor.html#reactor-debug-argument","title":"Reactor.reactor.debug.argument","type":"DSL"},{"doc":"The log level to send the debug information to.\n","ref":"dsl-reactor.html#reactor-debug-level","title":"Reactor.reactor.debug.level","type":"DSL"},{"doc":"A unique identifier for the step.\n","ref":"dsl-reactor.html#reactor-debug-name","title":"Reactor.reactor.debug.name","type":"DSL"},{"doc":"Inserts a step which will send debug information to the `Logger`.\n","ref":"dsl-reactor.html#reactor-debug","title":"Reactor.reactor.debug","type":"DSL"},{"doc":"The name of the step to wait for.\n","ref":"dsl-reactor.html#reactor-compose-wait_for-names","title":"Reactor.reactor.compose.wait_for.names","type":"DSL"},{"doc":"Wait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`\n","ref":"dsl-reactor.html#reactor-compose-wait_for","title":"Reactor.reactor.compose.wait_for","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the argument before it is passed to the step.\n","ref":"dsl-reactor.html#reactor-compose-argument-transform","title":"Reactor.reactor.compose.argument.transform","type":"DSL"},{"doc":"What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.\n","ref":"dsl-reactor.html#reactor-compose-argument-source","title":"Reactor.reactor.compose.argument.source","type":"DSL"},{"doc":"The name of the argument which will be used as the key in the `arguments` map passed to the implementation.\n","ref":"dsl-reactor.html#reactor-compose-argument-name","title":"Reactor.reactor.compose.argument.name","type":"DSL"},{"doc":"Specifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.\n","ref":"dsl-reactor.html#reactor-compose-argument","title":"Reactor.reactor.compose.argument","type":"DSL"},{"doc":"The reactor module or struct to compose upon.\n","ref":"dsl-reactor.html#reactor-compose-reactor","title":"Reactor.reactor.compose.reactor","type":"DSL"},{"doc":"A unique name for the step. Allows the result of the composed reactor to be depended upon by steps in this reactor.\n","ref":"dsl-reactor.html#reactor-compose-name","title":"Reactor.reactor.compose.name","type":"DSL"},{"doc":"Compose another Reactor into this one.\n\nAllows place another Reactor into this one as if it were a single step.\n","ref":"dsl-reactor.html#reactor-compose","title":"Reactor.reactor.compose","type":"DSL"},{"doc":"The name of the step to wait for.\n","ref":"dsl-reactor.html#reactor-collect-wait_for-names","title":"Reactor.reactor.collect.wait_for.names","type":"DSL"},{"doc":"Wait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`\n","ref":"dsl-reactor.html#reactor-collect-wait_for","title":"Reactor.reactor.collect.wait_for","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the argument before it is passed to the step.\n","ref":"dsl-reactor.html#reactor-collect-argument-transform","title":"Reactor.reactor.collect.argument.transform","type":"DSL"},{"doc":"What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.\n","ref":"dsl-reactor.html#reactor-collect-argument-source","title":"Reactor.reactor.collect.argument.source","type":"DSL"},{"doc":"The name of the argument which will be used as the key in the `arguments` map passed to the implementation.\n","ref":"dsl-reactor.html#reactor-collect-argument-name","title":"Reactor.reactor.collect.argument.name","type":"DSL"},{"doc":"Specifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.\n","ref":"dsl-reactor.html#reactor-collect-argument","title":"Reactor.reactor.collect.argument","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the entire argument map before it is returned.\n","ref":"dsl-reactor.html#reactor-collect-transform","title":"Reactor.reactor.collect.transform","type":"DSL"},{"doc":"A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps.\n","ref":"dsl-reactor.html#reactor-collect-name","title":"Reactor.reactor.collect.name","type":"DSL"},{"doc":"A Reactor step which simply collects and returns it's arguments.\n\nArguments can optionally be transformed before returning.\n","ref":"dsl-reactor.html#reactor-collect","title":"Reactor.reactor.collect","type":"DSL"},{"doc":"The name of the step to wait for.\n","ref":"dsl-reactor.html#reactor-around-wait_for-names","title":"Reactor.reactor.around.wait_for.names","type":"DSL"},{"doc":"Wait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`\n","ref":"dsl-reactor.html#reactor-around-wait_for","title":"Reactor.reactor.around.wait_for","type":"DSL"},{"doc":"An optional transformation function which can be used to modify the argument before it is passed to the step.\n","ref":"dsl-reactor.html#reactor-around-argument-transform","title":"Reactor.reactor.around.argument.transform","type":"DSL"},{"doc":"What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information.\n","ref":"dsl-reactor.html#reactor-around-argument-source","title":"Reactor.reactor.around.argument.source","type":"DSL"},{"doc":"The name of the argument which will be used as the key in the `arguments` map passed to the implementation.\n","ref":"dsl-reactor.html#reactor-around-argument-name","title":"Reactor.reactor.around.argument.name","type":"DSL"},{"doc":"Specifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.\n","ref":"dsl-reactor.html#reactor-around-argument","title":"Reactor.reactor.around.argument","type":"DSL"},{"doc":"Whether the emitted steps should be allowed to run asynchronously.\n","ref":"dsl-reactor.html#reactor-around-allow_async?","title":"Reactor.reactor.around.allow_async?","type":"DSL"},{"doc":"The around function. See `Reactor.Step.Around` for more information.\n","ref":"dsl-reactor.html#reactor-around-fun","title":"Reactor.reactor.around.fun","type":"DSL"},{"doc":"A unique name for the group of steps.\n","ref":"dsl-reactor.html#reactor-around-name","title":"Reactor.reactor.around.name","type":"DSL"},{"doc":"Wrap a function around a group of steps.\n","ref":"dsl-reactor.html#reactor-around","title":"Reactor.reactor.around","type":"DSL"},{"doc":"The middleware to be added to the Reactor.\n","ref":"dsl-reactor.html#reactor-middlewares-middleware-module","title":"Reactor.reactor.middlewares.middleware.module","type":"DSL"},{"doc":"Name a middleware to be added to the Reactor.","ref":"dsl-reactor.html#reactor-middlewares-middleware","title":"Reactor.reactor.middlewares.middleware","type":"DSL"},{"doc":"Middleware to be added to the Reactor","ref":"dsl-reactor.html#reactor-middlewares","title":"Reactor.reactor.middlewares","type":"DSL"},{"doc":"Specify which step result to return upon completion.\n","ref":"dsl-reactor.html#reactor-return","title":"Reactor.reactor.return","type":"DSL"},{"doc":"The top-level reactor DSL","ref":"dsl-reactor.html#reactor","title":"Reactor.reactor","type":"DSL"},{"doc":"Reactor is a dynamic, concurrent, dependency resolving saga orchestrator.","ref":"Reactor.html","title":"Reactor","type":"module"},{"doc":"You can construct a reactor using the `Reactor` Spark DSL:\n\n```elixir\ndefmodule HelloWorldReactor do\n  @moduledoc false\n  use Reactor\n\n  input :whom\n\n  step :greet, Greeter do\n    argument :whom, input(:whom)\n  end\n\n  return :greet\nend\n```\n\n    iex> Reactor.run(HelloWorldReactor, %{whom: \"Dear Reader\"})\n    {:ok, \"Hello, Dear Reader!\"}\n\nor you can build it programmatically:\n\n    iex> reactor = Builder.new()\n    ...> {:ok, reactor} = Builder.add_input(reactor, :whom)\n    ...> {:ok, reactor} = Builder.add_step(reactor, :greet, Greeter, whom: {:input, :whom})\n    ...> {:ok, reactor} = Builder.return(reactor, :greet)\n    ...> Reactor.run(reactor, %{whom: nil})\n    {:ok, \"Hello, World!\"}","ref":"Reactor.html#module-usage","title":"Usage - Reactor","type":"module"},{"doc":"* `:extensions` (list of module that adopts `Spark.Dsl.Extension`) - A list of DSL extensions to add to the `Spark.Dsl`\n\n* `:otp_app` (`t:atom/0`) - The otp_app to use for any application configurable options\n\n* `:fragments` (list of `t:module/0`) - Fragments to include in the `Spark.Dsl`. See the fragments guide for more.","ref":"Reactor.html#module-options","title":"Options - Reactor","type":"module"},{"doc":"A guard which returns true if the value is a Reactor struct","ref":"Reactor.html#is_reactor/1","title":"Reactor.is_reactor/1","type":"macro"},{"doc":"Attempt to run a Reactor.","ref":"Reactor.html#run/4","title":"Reactor.run/4","type":"function"},{"doc":"* `reactor` - The Reactor to run, either a Reactor DSL module, or a Reactor\n  struct.\n* `inputs` - A map of values passed in to satisfy the Reactor's expected\n  inputs.\n* `context` - An arbitrary map that will be merged into the Reactor context\n  and passed into each step.","ref":"Reactor.html#run/4-arguments","title":"Arguments - Reactor.run/4","type":"function"},{"doc":"* `:max_concurrency` (`t:pos_integer/0`) - The maximum number of processes to use to run the Reactor\n\n* `:timeout` - How long to allow the Reactor to run for The default value is `:infinity`.\n\n* `:max_iterations` - The maximum number of times to allow the Reactor to loop The default value is `:infinity`.\n\n* `:async_option` (`t:boolean/0`) - Whether to allow the Reactor to start processes The default value is `true`.","ref":"Reactor.html#run/4-options","title":"Options - Reactor.run/4","type":"function"},{"doc":"Raising version of `run/4`.","ref":"Reactor.html#run!/4","title":"Reactor.run!/4","type":"function"},{"doc":"When set to `false` forces the Reactor to run every step synchronously,\nregardless of the step configuration.\n\nDefaults to `true`.","ref":"Reactor.html#t:async_option/0","title":"Reactor.async_option/0","type":"type"},{"doc":"Use a `Reactor.Executor.ConcurrencyTracker.pool_key` to allow this Reactor to\nshare it's concurrency pool with other Reactor instances.\n\nIf you do not specify one then the Reactor will initialise a new pool and\nplace it in it's context for any child Reactors to re-use.\n\nOnly used if `async?` is set to `true`.","ref":"Reactor.html#t:concurrency_key_option/0","title":"Reactor.concurrency_key_option/0","type":"type"},{"doc":"","ref":"Reactor.html#t:context/0","title":"Reactor.context/0","type":"type"},{"doc":"","ref":"Reactor.html#t:context_arg/0","title":"Reactor.context_arg/0","type":"type"},{"doc":"How long to wait for asynchronous steps to complete when halting.\n\nDefaults to 5000ms.","ref":"Reactor.html#t:halt_timeout_option/0","title":"Reactor.halt_timeout_option/0","type":"type"},{"doc":"","ref":"Reactor.html#t:inputs/0","title":"Reactor.inputs/0","type":"type"},{"doc":"Specify the maximum number of asynchronous steps which can be run in parallel.\n\nDefaults to the result of `System.schedulers_online/0`.  Only used if\n`async?` is set to `true`.","ref":"Reactor.html#t:max_concurrency_option/0","title":"Reactor.max_concurrency_option/0","type":"type"},{"doc":"The maximum number of iterations which after which the Reactor will halt.\n\nDefaults to `:infinity`.","ref":"Reactor.html#t:max_iterations_option/0","title":"Reactor.max_iterations_option/0","type":"type"},{"doc":"","ref":"Reactor.html#t:options/0","title":"Reactor.options/0","type":"type"},{"doc":"","ref":"Reactor.html#t:state/0","title":"Reactor.state/0","type":"type"},{"doc":"","ref":"Reactor.html#t:t/0","title":"Reactor.t/0","type":"type"},{"doc":"Specify the amount of execution time after which to halt processing.\n\nNote that this is not a hard limit. The Reactor will stop when the first step\ncompletes _after_ the timeout has expired.\n\nDefaults to `:infinity`.","ref":"Reactor.html#t:timeout_option/0","title":"Reactor.timeout_option/0","type":"type"},{"doc":"The struct used to store `argument` DSL entities.\n\nSee `d:Reactor.step.argument`.","ref":"Reactor.Dsl.Argument.html","title":"Reactor.Dsl.Argument","type":"module"},{"doc":"The `element` template helper for the Reactor DSL.","ref":"Reactor.Dsl.Argument.html#element/2","title":"Reactor.Dsl.Argument.element/2","type":"function"},{"doc":"```elixir\ndefmodule ExampleReactor do\n  use Reactor\n\n  input :numbers\n\n  map :double_numbers do\n    source input(:numbers)\n\n    step :double do\n      argument :number, element(:double_numbers)\n\n      run fn args, _, _ ->\n        {:ok, args.number * 2}\n      end\n    end\n\n    return :double\n  end\nend\n```","ref":"Reactor.Dsl.Argument.html#element/2-example","title":"Example - Reactor.Dsl.Argument.element/2","type":"function"},{"doc":"The `input` template helper for the Reactor DSL.","ref":"Reactor.Dsl.Argument.html#input/2","title":"Reactor.Dsl.Argument.input/2","type":"function"},{"doc":"```elixir\ndefmodule ExampleReactor do\n  use Reactor\n\n  input :name\n\n  step :greet do\n    # here: --------↓↓↓↓↓\n    argument :name, input(:name)\n    run fn\n      %{name: nil}, _, _ -> {:ok, \"Hello, World!\"}\n      %{name: name}, _, _ -> {:ok, \"Hello, #{name}!\"}\n    end\n  end\nend\n```","ref":"Reactor.Dsl.Argument.html#input/2-example","title":"Example - Reactor.Dsl.Argument.input/2","type":"function"},{"doc":"You can provide a list of keys to extract from a data structure, similar to\n`Kernel.get_in/2` with the condition that the input value is either a struct\nor implements the `Access` protocol.","ref":"Reactor.Dsl.Argument.html#input/2-extracting-nested-values","title":"Extracting nested values - Reactor.Dsl.Argument.input/2","type":"function"},{"doc":"The `result` template helper for the Reactor DSL.","ref":"Reactor.Dsl.Argument.html#result/2","title":"Reactor.Dsl.Argument.result/2","type":"function"},{"doc":"```elixir\ndefmodule ExampleReactor do\n  use Reactor\n\n  step :whom do\n    run fn ->\n      {:ok, Enum.random([\"Marty\", \"Doc\", \"Jennifer\", \"Lorraine\", \"George\", nil])}\n    end\n  end\n\n  step :greet do\n    # here: --------↓↓↓↓↓↓\n    argument :name, result(:whom)\n    run fn\n      %{name: nil}, _, _ -> {:ok, \"Hello, World!\"}\n      %{name: name}, _, _ -> {:ok, \"Hello, #{name}!\"}\n    end\n  end\nend\n```","ref":"Reactor.Dsl.Argument.html#result/2-example","title":"Example - Reactor.Dsl.Argument.result/2","type":"function"},{"doc":"You can provide a list of keys to extract from a data structure, similar to\n`Kernel.get_in/2` with the condition that the result is either a struct or\nimplements the `Access` protocol.","ref":"Reactor.Dsl.Argument.html#result/2-extracting-nested-values","title":"Extracting nested values - Reactor.Dsl.Argument.result/2","type":"function"},{"doc":"The `value` template helper for the Reactor DSL.","ref":"Reactor.Dsl.Argument.html#value/1","title":"Reactor.Dsl.Argument.value/1","type":"function"},{"doc":"```elixir\ndefmodule ExampleReactor do\n  use Reactor\n\n  input :number\n\n  step :times_three do\n    argument :lhs, input(:number)\n    # here: -------↓↓↓↓↓\n    argument :rhs, value(3)\n\n    run fn args, _, _ ->\n      {:ok, args.lhs * args.rhs}\n    end\n  end\nend\n```","ref":"Reactor.Dsl.Argument.html#value/1-example","title":"Example - Reactor.Dsl.Argument.value/1","type":"function"},{"doc":"","ref":"Reactor.Dsl.Argument.html#t:t/0","title":"Reactor.Dsl.Argument.t/0","type":"type"},{"doc":"The `around` DSL entity struct.\n\nSee `d:Reactor.around`.","ref":"Reactor.Dsl.Around.html","title":"Reactor.Dsl.Around","type":"module"},{"doc":"","ref":"Reactor.Dsl.Around.html#t:t/0","title":"Reactor.Dsl.Around.t/0","type":"type"},{"doc":"A protocol which DSL entities must implement.","ref":"Reactor.Dsl.Build.html","title":"Reactor.Dsl.Build","type":"protocol"},{"doc":"Build an entity into a Reactor.\n\nThis function is called during conversion of a DSL module into a Reactor\nstruct.  This allows extensions to specify the behaviour of how they want\nto alter the structure of the Reactor.","ref":"Reactor.Dsl.Build.html#build/2","title":"Reactor.Dsl.Build.build/2","type":"function"},{"doc":"Perform any after-compilation verification that is needed to make the entity\nwork.\n\nSee `Spark.Dsl.Verifier` for more information.","ref":"Reactor.Dsl.Build.html#verify/2","title":"Reactor.Dsl.Build.verify/2","type":"function"},{"doc":"All the types that implement this protocol.","ref":"Reactor.Dsl.Build.html#t:t/0","title":"Reactor.Dsl.Build.t/0","type":"type"},{"doc":"The struct used to store collect DSL entities.\n\nSee `d:Reactor.collect`.","ref":"Reactor.Dsl.Collect.html","title":"Reactor.Dsl.Collect","type":"module"},{"doc":"","ref":"Reactor.Dsl.Collect.html#t:t/0","title":"Reactor.Dsl.Collect.t/0","type":"type"},{"doc":"The `compose` DSL entity struct.\n\nSee the `d:Reactor.compose`.","ref":"Reactor.Dsl.Compose.html","title":"Reactor.Dsl.Compose","type":"module"},{"doc":"","ref":"Reactor.Dsl.Compose.html#t:t/0","title":"Reactor.Dsl.Compose.t/0","type":"type"},{"doc":"The `debug` DSL entity struct.\n\nSee `d:Reactor.debug`.","ref":"Reactor.Dsl.Debug.html","title":"Reactor.Dsl.Debug","type":"module"},{"doc":"","ref":"Reactor.Dsl.Debug.html#t:t/0","title":"Reactor.Dsl.Debug.t/0","type":"type"},{"doc":"The `group` DSL entity struct.\n\nSee `d:Reactor.group`.","ref":"Reactor.Dsl.Group.html","title":"Reactor.Dsl.Group","type":"module"},{"doc":"","ref":"Reactor.Dsl.Group.html#t:t/0","title":"Reactor.Dsl.Group.t/0","type":"type"},{"doc":"Introspection for the Reactor DSL.","ref":"Reactor.Dsl.Info.html","title":"Reactor.Dsl.Info","type":"module"},{"doc":"reactor DSL entities","ref":"Reactor.Dsl.Info.html#reactor/1","title":"Reactor.Dsl.Info.reactor/1","type":"function"},{"doc":"reactor.middlewares DSL entities","ref":"Reactor.Dsl.Info.html#reactor_middlewares/1","title":"Reactor.Dsl.Info.reactor_middlewares/1","type":"function"},{"doc":"reactor DSL options\n\nReturns a map containing the and any configured or default values.","ref":"Reactor.Dsl.Info.html#reactor_options/1","title":"Reactor.Dsl.Info.reactor_options/1","type":"function"},{"doc":"Specify which step result to return upon completion.","ref":"Reactor.Dsl.Info.html#reactor_return/1","title":"Reactor.Dsl.Info.reactor_return/1","type":"function"},{"doc":"Specify which step result to return upon completion.","ref":"Reactor.Dsl.Info.html#reactor_return!/1","title":"Reactor.Dsl.Info.reactor_return!/1","type":"function"},{"doc":"Convert a reactor DSL module into a reactor struct.","ref":"Reactor.Dsl.Info.html#to_struct/1","title":"Reactor.Dsl.Info.to_struct/1","type":"function"},{"doc":"Raising version of `to_struct/1`.","ref":"Reactor.Dsl.Info.html#to_struct!/1","title":"Reactor.Dsl.Info.to_struct!/1","type":"function"},{"doc":"The struct used to store input DSL entities.\n\nSee `d:Reactor.input`.","ref":"Reactor.Dsl.Input.html","title":"Reactor.Dsl.Input","type":"module"},{"doc":"","ref":"Reactor.Dsl.Input.html#t:t/0","title":"Reactor.Dsl.Input.t/0","type":"type"},{"doc":"The `map` DSL entity struct.\n\nSee `d:Reactor.map`.","ref":"Reactor.Dsl.Map.html","title":"Reactor.Dsl.Map","type":"module"},{"doc":"","ref":"Reactor.Dsl.Map.html#t:t/0","title":"Reactor.Dsl.Map.t/0","type":"type"},{"doc":"The `middleware` DSL entity struct.\n\nSee `d:Reactor.middleware.middleware`.","ref":"Reactor.Dsl.Middleware.html","title":"Reactor.Dsl.Middleware","type":"module"},{"doc":"","ref":"Reactor.Dsl.Middleware.html#t:t/0","title":"Reactor.Dsl.Middleware.t/0","type":"type"},{"doc":"The struct used to store step DSL entities.\n\nSee `d:Reactor.step`.","ref":"Reactor.Dsl.Step.html","title":"Reactor.Dsl.Step","type":"module"},{"doc":"","ref":"Reactor.Dsl.Step.html#t:t/0","title":"Reactor.Dsl.Step.t/0","type":"type"},{"doc":"The `switch` DSL entity struct.\n\nSee `d:Reactor.switch`.","ref":"Reactor.Dsl.Switch.html","title":"Reactor.Dsl.Switch","type":"module"},{"doc":"","ref":"Reactor.Dsl.Switch.html#t:t/0","title":"Reactor.Dsl.Switch.t/0","type":"type"},{"doc":"The `default` DSL entity struct.\n\nSee `d:Reactor.switch.default`.","ref":"Reactor.Dsl.Switch.Default.html","title":"Reactor.Dsl.Switch.Default","type":"module"},{"doc":"","ref":"Reactor.Dsl.Switch.Default.html#t:t/0","title":"Reactor.Dsl.Switch.Default.t/0","type":"type"},{"doc":"The `matches?` DSL entity struct.\n\nSee `d:Reactor.switch.matches?`.","ref":"Reactor.Dsl.Switch.Match.html","title":"Reactor.Dsl.Switch.Match","type":"module"},{"doc":"","ref":"Reactor.Dsl.Switch.Match.html#t:t/0","title":"Reactor.Dsl.Switch.Match.t/0","type":"type"},{"doc":"Runs `Reactor.Dsl.Build.verify/2` for all the entities in the reactor.","ref":"Reactor.Dsl.Verifier.html","title":"Reactor.Dsl.Verifier","type":"module"},{"doc":"The struct used to store `wait_for` DSL entities.\n\nSee `d:Reactor.step.wait_for`.","ref":"Reactor.Dsl.WaitFor.html","title":"Reactor.Dsl.WaitFor","type":"module"},{"doc":"","ref":"Reactor.Dsl.WaitFor.html#t:t/0","title":"Reactor.Dsl.WaitFor.t/0","type":"type"},{"doc":"The Step behaviour and struct.\n\nImplement this behaviour to make steps for your Reactor.","ref":"Reactor.Step.html","title":"Reactor.Step","type":"behaviour"},{"doc":"Is the step able to be run asynchronously?","ref":"Reactor.Step.html#async?/1","title":"Reactor.Step.async?/1","type":"function"},{"doc":"Detect if the step can be run asynchronously at runtime.\n\n> This callback is automatically defined by `use Reactor.Step` however you're\n> free to override it if you need a specific behaviour.\n\nThis callback is called when Reactor is deciding whether to run a step\nasynchronously.\n\nThe default implementation of this callback checks returns the the value of\nthe steps's `async?` key if it is boolean, or calls it with the steps's\noptions if it is a function.","ref":"Reactor.Step.html#c:async?/1","title":"Reactor.Step.async?/1","type":"callback"},{"doc":"Find out of a step has a capability.","ref":"Reactor.Step.html#can?/2","title":"Reactor.Step.can?/2","type":"function"},{"doc":"Detect the capabilities of the step at runtime.\n\n> This callback is automatically defined by `use Reactor.Step` however you're\n> free to override it if you need specific behaviour.\n\nWhenever Reactor would like to either undo a change made by the step, or\ncompensate a step failure this callback is called to detect whether the step\nmodule is capable of the desired action.\n\nThe default implementation of this callback checks to see if the optional\ncallback is defined on the current module.","ref":"Reactor.Step.html#c:can?/2","title":"Reactor.Step.can?/2","type":"callback"},{"doc":"Compensate a step","ref":"Reactor.Step.html#compensate/4","title":"Reactor.Step.compensate/4","type":"function"},{"doc":"Compensate for the failure of the step.\n\n> Do not implement this callback if your step doesn't support compensation.\n\nIf `run/3` returned an error then this callback will be called the error\nreason and the original arguments.\n\nThis provides you the opportunity to handle the error in a number of ways and\ndirect the reactor as to what to do next.","ref":"Reactor.Step.html#c:compensate/4","title":"Reactor.Step.compensate/4","type":"callback"},{"doc":"- `reason` - the error reason returned from `c:run/3`.\n  - `arguments` - the arguments passed to the step.\n  - `context` - the reactor context.\n  - `options` - a keyword list of options provided to the step (if any).","ref":"Reactor.Step.html#c:compensate/4-arguments","title":"Arguments - Reactor.Step.compensate/4","type":"callback"},{"doc":"- `{:continue, value}` if you're able to provide a valid result for the step\n    (perhaps by re-running the original computation) then return that within a\n    `:continue` tuple and execution will continue as planned.\n  - `:ok` the step was successfully compensated and the reactor should\n    continue undoing upstream changes.\n  - `:retry` or `{:retry, reason}` if you would like the reactor to attempt to\n    re-run the step. You can optionally supply an error reason which will be\n    used in the event that the step runs out of retries, otherwise a\n    `Reactor.Error.Invalid.RetriesExceededError` will be used.\n  - `{:error, reason}` if compensation was unsuccessful.","ref":"Reactor.Step.html#c:compensate/4-return-values","title":"Return values - Reactor.Step.compensate/4","type":"callback"},{"doc":"Execute a step.","ref":"Reactor.Step.html#run/3","title":"Reactor.Step.run/3","type":"function"},{"doc":"Execute the step.\n\nThis is the function that implements the behaviour you wish to execute.  You\nwill receive arguments as per the `t:Step.t` definition along with their\ncorresponding values as a map and a copy of the current reactor context.","ref":"Reactor.Step.html#c:run/3","title":"Reactor.Step.run/3","type":"callback"},{"doc":"- `arguments` - A map of arguments as per the `t:Step.t` definition we're\n    called from.\n  - `context` - The reactor context.\n  - `options` - A keyword list of options provided to the step (if any).","ref":"Reactor.Step.html#c:run/3-arguments","title":"Arguments - Reactor.Step.run/3","type":"callback"},{"doc":"- `{:ok, value}` the step completed successfully it returns the value in an\n    ok tuple.\n  - `{:ok, value, [step]}` the step completed successfully and wants to add\n    new steps to the reactor.\n  - `{:error, reason}` the if step failed, return an error tuple.\n  - `:retry` or `{:retry, reason}` the step failed, but is retryable.  You can\n    optionally supply an error reason which will be used in the event that the\n    step runs out of retries, otherwise a `Reactor.Error.RetriesExceededError`\n    will be used.\n  - `{:halt, reason}` terminate (or pause) reactor execution.  If there are\n    actively running steps the reactor will wait for them to finish and then\n    return the incomplete state for later resumption.","ref":"Reactor.Step.html#c:run/3-return-values","title":"Return values - Reactor.Step.run/3","type":"callback"},{"doc":"Undo a step","ref":"Reactor.Step.html#undo/4","title":"Reactor.Step.undo/4","type":"function"},{"doc":"Undo a previously successful execution of the step.\n\n> Do not implement this callback if your step doesn't support undoing.\n\nThis callback is called when the reactor encounters an unhandled error later\nin it's execution run and must undo the work previously done.","ref":"Reactor.Step.html#c:undo/4","title":"Reactor.Step.undo/4","type":"callback"},{"doc":"- `value` - the return value of the previously successful call to `c:run/3`.\n  - `arguments` - the arguments passed to the step.\n  - `context` - the reactor context.\n  - `options` - a keyword list of options provided to the step (if any).","ref":"Reactor.Step.html#c:undo/4-arguments","title":"Arguments - Reactor.Step.undo/4","type":"callback"},{"doc":"- `:ok` the step was successfully undo and the reactor should continue\n    rolling back.\n  - `{:error, reason}` there was an error while attempting to compensate.  The\n    reactor will collect the error and continue rolling back.\n  - `:retry` if you would like the reactor to attempt to undo the again later\n    - possibly in the case of a network failure for example.","ref":"Reactor.Step.html#c:undo/4-return-values","title":"Return values - Reactor.Step.undo/4","type":"callback"},{"doc":"Optional capabilities which may be implemented by the step module.\n\nThis allows us to optimise out calls steps which cannot be undone, etc.","ref":"Reactor.Step.html#t:capability/0","title":"Reactor.Step.capability/0","type":"type"},{"doc":"Possible valid return values for the `c:compensate/4` callback.","ref":"Reactor.Step.html#t:compensate_result/0","title":"Reactor.Step.compensate_result/0","type":"type"},{"doc":"Possible valid return values for the `c:run/3` callback.","ref":"Reactor.Step.html#t:run_result/0","title":"Reactor.Step.run_result/0","type":"type"},{"doc":"","ref":"Reactor.Step.html#t:step/0","title":"Reactor.Step.step/0","type":"type"},{"doc":"","ref":"Reactor.Step.html#t:t/0","title":"Reactor.Step.t/0","type":"type"},{"doc":"Possible valid return values for the `c:undo/4` callback.","ref":"Reactor.Step.html#t:undo_result/0","title":"Reactor.Step.undo_result/0","type":"type"},{"doc":"The built-in step for executing in-line DSL anonymous functions.","ref":"Reactor.Step.AnonFn.html","title":"Reactor.Step.AnonFn","type":"module"},{"doc":"* `run` - a one or two arity function or MFA which will be called as the run\n  function of the step.\n* `compensate` - a one to three arity function or MFA which will be called as\n  the compensate function of the step.  Optional.\n* `undo` - a one to three arity function or MFA which will be called as the\n  undo function of this step.  Optional.","ref":"Reactor.Step.AnonFn.html#module-options","title":"Options - Reactor.Step.AnonFn","type":"module"},{"doc":"Wrap the execution of a number of steps in a function.\n\nThis allows you to provide custom context and filter the provided steps as\nneeded.","ref":"Reactor.Step.Around.html","title":"Reactor.Step.Around","type":"module"},{"doc":"* `fun` - a four-arity function that will be called when executing this step.\n* `steps` - a list of steps which are will be provided to the above mentioned\n  function.\n* `allow_async?` - a boolean indicating whether the nested steps can be\n  executed asynchronously or must remain within the current process.","ref":"Reactor.Step.Around.html#module-options","title":"Options - Reactor.Step.Around","type":"module"},{"doc":"Your around function will be called by this step and will be passed the\nfollowing arguments:\n\n* `arguments` - the arguments passed to the step.\n* `context` - the context passed to the step.\n* `steps` - the list of steps passed in the options.\n* `callback` - a 3 arity function that you can call to execute steps.\n\nThis provides you the opportunity to modify the arguments, context and list of\nsteps to be executed.  You then can call the callback with the modified\narguments, context and steps and they will be executed in a Reactor of their\nown.  The callback will return `{:ok, results}` where results is a map of all\nof the step results by name, or an error tuple.\n\nYou can then modify the result in any way before returning it as the return of\nthe around step.","ref":"Reactor.Step.Around.html#module-wrapper-function","title":"Wrapper function - Reactor.Step.Around","type":"module"},{"doc":"The callback function will spawn a separate Reactor and run provided steps to\ncompletion using `arguments` as input.\n\nIt expects the following three arguments to be passed:\n\n1. `arguments` - a map of arguments to be used as input to the nested Reactor.\n2. `context` - the context passed to the nested Reactor.\n3. `steps` - the list of steps which will be executed in the nested Reactor.","ref":"Reactor.Step.Around.html#module-callback-function","title":"Callback function - Reactor.Step.Around","type":"module"},{"doc":"You could use a function like that below to cause some steps to be executed\ninside an Ecto database transaction.\n\n```elixir\ndef in_transaction(arguments, context, steps, callback) do\n  MyApp.Repo.transaction(fn ->\n    case callback.(arguments, context, steps) do\n      {:ok, results} -> result\n      {:error, reason} -> raise reason\n    end\n  end)\nend\n```","ref":"Reactor.Step.Around.html#module-example","title":"Example - Reactor.Step.Around","type":"module"},{"doc":"","ref":"Reactor.Step.Around.html#around/4","title":"Reactor.Step.Around.around/4","type":"function"},{"doc":"Should the inner Reactor be allowed to run tasks asynchronously?\n\nOptional. Defaults to `true`.","ref":"Reactor.Step.Around.html#t:allow_async_option/0","title":"Reactor.Step.Around.allow_async_option/0","type":"type"},{"doc":"The type signature for the \"around\" function.","ref":"Reactor.Step.Around.html#t:around_fun/0","title":"Reactor.Step.Around.around_fun/0","type":"type"},{"doc":"The type signature for the provided callback function.","ref":"Reactor.Step.Around.html#t:callback/0","title":"Reactor.Step.Around.callback/0","type":"type"},{"doc":"The MFA or 4-arity function which this step will call.","ref":"Reactor.Step.Around.html#t:function_option/0","title":"Reactor.Step.Around.function_option/0","type":"type"},{"doc":"","ref":"Reactor.Step.Around.html#t:options/0","title":"Reactor.Step.Around.options/0","type":"type"},{"doc":"The initial steps to pass into the \"around\" function.\n\nOptional.","ref":"Reactor.Step.Around.html#t:steps_option/0","title":"Reactor.Step.Around.steps_option/0","type":"type"},{"doc":"A built-in step which can embed one reactor inside another.\n\nThis is different to the `Builder.compose` and DSL `compose` methods.  Those\nmethods build a new reactor by combining the steps of the two input reactors,\nwhereas this step expands the provided reactor at runtime and dynamically\ninserts it's steps into the running reactor.\n\nIf emitting the reactor's steps into the current reactor would be recursive,\nthen the reactor is directly executed within the step using `Reactor.run/4`.","ref":"Reactor.Step.Compose.html","title":"Reactor.Step.Compose","type":"module"},{"doc":"When doing run-time composition of Reactors we need to dynamically rewrite any\ndynamically emitted steps to have the correct namespace.\n\nYes, this gets hairy, fast.","ref":"Reactor.Step.ComposeWrapper.html","title":"Reactor.Step.ComposeWrapper","type":"module"},{"doc":"* `original` - the original value of the Step's `impl` key.\n  * `prefix` - a list of values to be placed in the `name` before the original\n    value.\n\n> #### Tip {: .tip}\n>\n> This is dynamically injected into steps by `Reactor.Step.Compose`.\n>\n> Most likely you will never need to use this step directly.","ref":"Reactor.Step.ComposeWrapper.html#module-options","title":"Options - Reactor.Step.ComposeWrapper","type":"module"},{"doc":"A very simple step which sends debug information to `Logger`.","ref":"Reactor.Step.Debug.html","title":"Reactor.Step.Debug","type":"module"},{"doc":"* `level` - the log level to use.","ref":"Reactor.Step.Debug.html#module-options","title":"Options - Reactor.Step.Debug","type":"module"},{"doc":"","ref":"Reactor.Step.Debug.html#t:level_option/0","title":"Reactor.Step.Debug.level_option/0","type":"type"},{"doc":"","ref":"Reactor.Step.Debug.html#t:options/0","title":"Reactor.Step.Debug.options/0","type":"type"},{"doc":"Wrap the execution of a number of steps with before/after functions.\n\nUnlike `Reactor.Step.Around`, this step doesn't need to run a nested Reactor\ninstance, but instead can emit the steps directly into the parent Reactor.","ref":"Reactor.Step.Group.html","title":"Reactor.Step.Group","type":"module"},{"doc":"* `before` - a three-arity function that will be called before running any\n  child steps.\n* `after` - a three-arity function that will be called after running any\n  emitted steps.\n* `allow_async?` - a boolean indicating whether the emitted steps can be\n  executed asynchronously or must remain within the current process.","ref":"Reactor.Step.Group.html#module-options","title":"Options - Reactor.Step.Group","type":"module"},{"doc":"The before function will be passed the following arguments:\n\n1. `arguments` - the values of any step arguments needed by the group.\n2. `context` - the Reactor context.\n3. `steps` - the list of steps passed in the options.\n\nThis provides you the opportunity to modify the arguments, context and list of\nsteps to be executed.\n\nThe successful return value should be `{:ok, arguments, context, steps}`.  The\nreturned arguments will be used to provide any `input` arguments to nested\nsteps.","ref":"Reactor.Step.Group.html#module-before-function","title":"Before function - Reactor.Step.Group","type":"module"},{"doc":"```elixir\ndef no_time_travel(arguments, context, steps) do\n  steps = steps\n    |> Enum.filter(&(&1.name == :program_time_circuits))\n\n  arguments = arguments\n    |> Map.delete(:destination_time)\n\n  {:ok, arguments, context, steps}\nend\n```","ref":"Reactor.Step.Group.html#module-example","title":"Example - Reactor.Step.Group","type":"module"},{"doc":"The after function will be called with a single argument; a map of the nested\nstep results.\n\nThe successful return value should be `{:ok, any}` where `any` will be treated\nas the result of the group.\n\n```elixir\ndef find_current_year(results) do\n  case Map.fetch(results, :time_circuits) do\n    {:ok, %{present_time: present_time}} -> {:ok, present_time.year}\n    _ -> {:error, \"Unable to read the present time from the time circuits\"}\n  end\nend\n```","ref":"Reactor.Step.Group.html#module-after-function","title":"After function - Reactor.Step.Group","type":"module"},{"doc":"The after function.","ref":"Reactor.Step.Group.html#t:after_fun/0","title":"Reactor.Step.Group.after_fun/0","type":"type"},{"doc":"The MFA or 1-arity function which this step will call after successfully\nrunning the steps.","ref":"Reactor.Step.Group.html#t:after_option/0","title":"Reactor.Step.Group.after_option/0","type":"type"},{"doc":"Should the emitted steps be allowed to run asynchronously?\n\nOptional. Defaults to `true`.","ref":"Reactor.Step.Group.html#t:allow_async_option/0","title":"Reactor.Step.Group.allow_async_option/0","type":"type"},{"doc":"The before function.","ref":"Reactor.Step.Group.html#t:before_fun/0","title":"Reactor.Step.Group.before_fun/0","type":"type"},{"doc":"The MFA or 3-arity function which this step will call before running any\nsteps.","ref":"Reactor.Step.Group.html#t:before_option/0","title":"Reactor.Step.Group.before_option/0","type":"type"},{"doc":"","ref":"Reactor.Step.Group.html#t:options/0","title":"Reactor.Step.Group.options/0","type":"type"},{"doc":"The initial steps to pass into the \"before\" function.\n\nOptional.","ref":"Reactor.Step.Group.html#t:steps_option/0","title":"Reactor.Step.Group.steps_option/0","type":"type"},{"doc":"Given an iterable input run the provided steps for each element and collect\nthe results into a new value.\n\n> #### A note on ordering {: .tip}\n>\n> If your application doesn't need the results back in the same order that\n> they were provided then setting `strict_ordering?` to `false` will increase\n> performance - especially on large input sets.","ref":"Reactor.Step.Map.html","title":"Reactor.Step.Map","type":"module"},{"doc":"* `:state` - Required. The current execution state of the map.  This is required because it's recursive.\n   Valid values are :init, :iterating\n\n* `:batch_size` (`t:pos_integer/0`) - The number of elements to consume off the source when emitting steps. The default value is `100`.\n\n* `:steps` (list of struct of type `Reactor.Step`) - Required. The steps to use when mapping source elements.\n\n* `:return` (`t:atom/0`) - Required. The name of the step whose result will be used as the new value for each element.\n\n* `:strict_ordering?` (`t:boolean/0`) - Whether the mapped values must be returned in the same order that they were provided. The default value is `true`.\n\n* `:allow_async?` (`t:boolean/0`) - Whether the emitted steps should be allowed to run asynchronously. The default value is `true`.\n\n* `:descendant_step_names` (struct of type `MapSet`) - The cached names of all descendant steps to aid rewriting. You don't need to provide this value - it is calculated by the init pass.\n\n* `:extra_arguments` (list of struct of type `Reactor.Argument`) - Extra arguments to be passed by to every nested step.","ref":"Reactor.Step.Map.html#module-options","title":"Options - Reactor.Step.Map","type":"module"},{"doc":"A very simple step which simply returns all it's arguments unchanged.","ref":"Reactor.Step.ReturnAllArguments.html","title":"Reactor.Step.ReturnAllArguments","type":"module"},{"doc":"A very simple step which simply returns the named argument, if provided.","ref":"Reactor.Step.ReturnArgument.html","title":"Reactor.Step.ReturnArgument","type":"module"},{"doc":"* `argument` - the name of the argument to return.","ref":"Reactor.Step.ReturnArgument.html#module-options","title":"Options. - Reactor.Step.ReturnArgument","type":"module"},{"doc":"Conditionally decide which steps should be run at runtime.","ref":"Reactor.Step.Switch.html","title":"Reactor.Step.Switch","type":"module"},{"doc":"* `matches` - a list of match consisting of predicates and a list of steps to\n  execute if the predicate returns a truthy value.  See `t:matches` for more\n  information.  Required.\n* `default` - a list of steps to execute if none of the predicates match.\n  Optional.\n* `allow_async?` - a boolean indicating whether to allow the steps to be\n  executed asynchronously.  Optional.  Defaults to `true`.\n* `on` - the name of the argument to pass into the predicates.  If this\n  argument is not provided to this step, then an error will be returned.","ref":"Reactor.Step.Switch.html#module-options","title":"Options - Reactor.Step.Switch","type":"module"},{"doc":"Each of the predicates in `matches` are tried in order, until either one\nreturns a truthy value, or all the matches are exhausted.\n\nIf there is a match, then the matching steps are emitted into the parent\nrunning Reactor.\n\nIn the case that no match is found, then the steps provided in the `default`\noption are emitted.  If no default is provided, then an error is returned.\n\n> #### Tip {: .tip}\n>\n> Execution of predicates stops once the first match is found.  This means\n> that if multiple predicates potentially match, the subsequent ones will\n> never be called.","ref":"Reactor.Step.Switch.html#module-branching-behaviour","title":"Branching behaviour - Reactor.Step.Switch","type":"module"},{"doc":"By default the step returns `nil` as it's result.\n\nYou can have the step return the result of a branch by adding a step to the\nbranch with the same name as the switch which returns the expected value.\nThis will be handled by normal Reactor step emission rules.","ref":"Reactor.Step.Switch.html#module-returning","title":"Returning - Reactor.Step.Switch","type":"module"},{"doc":"","ref":"Reactor.Step.Switch.html#t:allow_async_option/0","title":"Reactor.Step.Switch.allow_async_option/0","type":"type"},{"doc":"","ref":"Reactor.Step.Switch.html#t:default_option/0","title":"Reactor.Step.Switch.default_option/0","type":"type"},{"doc":"","ref":"Reactor.Step.Switch.html#t:match_option/0","title":"Reactor.Step.Switch.match_option/0","type":"type"},{"doc":"A list of predicates and steps to execute if the predicate returns a truthy\nvalue.","ref":"Reactor.Step.Switch.html#t:matches/0","title":"Reactor.Step.Switch.matches/0","type":"type"},{"doc":"","ref":"Reactor.Step.Switch.html#t:on_option/0","title":"Reactor.Step.Switch.on_option/0","type":"type"},{"doc":"","ref":"Reactor.Step.Switch.html#t:options/0","title":"Reactor.Step.Switch.options/0","type":"type"},{"doc":"A predicate is a 1-arity function.  It can return anything.  Any result which\nis not `nil` or `false` is considered true.","ref":"Reactor.Step.Switch.html#t:predicate/0","title":"Reactor.Step.Switch.predicate/0","type":"type"},{"doc":"The built-in step for executing input and argument transformations.\n\nExpects a single argument named `value` which contains the value to be\ntransformed.","ref":"Reactor.Step.Transform.html","title":"Reactor.Step.Transform","type":"module"},{"doc":"* `fun` - a one or two arity function or MFA to use to modify the `value`\n  argument.\n\n> #### Tip {: .tip}\n>\n> This step is emitted by the builder when an argument needs to be transformed\n> before being passed into a step.\n>\n> Most likely you will never need to use this step directly.","ref":"Reactor.Step.Transform.html#module-options","title":"Options - Reactor.Step.Transform","type":"module"},{"doc":"A built-in step which applies a transformation function to all it's arguments.\n\nThe returned map is used as the arguments to the step, instead of the step's\ndefined arguments.\n\n\n> #### Tip {: .tip}\n>\n> This step will be emitted by the builder when a step wants to transform all\n> it's arguments.\n>\n> Most likely you will never need to use this step directly.","ref":"Reactor.Step.TransformAll.html","title":"Reactor.Step.TransformAll","type":"module"},{"doc":"The Middleware behaviour.\n\nBy implementing this behaviour you can modify the internal state of the\nReactor during startup, execution and shutdown.\n\nMiddlewares can be added to the reactor either with the `middlewares` DSL\nsection or by the `add_middleware/2`, etc, functions in `Reactor.Builder`.\n\nAll callbacks in this behaviour are optional so you can define only the parts\nyou need for your feature.","ref":"Reactor.Middleware.html","title":"Reactor.Middleware","type":"behaviour"},{"doc":"The complete callback will be called with the successful result of the\nReactor.\n\nThis gives you the opportunity to modify the return value or to perform clean\nup of any non-reactor-managed resources (eg notifications).\n\nNote that these callbacks are called in an arbitrary order meaning that the\nresult value passed may have already been altered by another callback.\n\nIf any callback returns an error then any remaining callbacks will not\nbe called.","ref":"Reactor.Middleware.html#c:complete/2","title":"Reactor.Middleware.complete/2","type":"callback"},{"doc":"The error callback will be called the final error value(s) of the Reactor.\n\nThis gives you the opportunity to modify the return value or to perform clean\nup of any non-reactor-managed resources (eg notifications).\n\nNote that these callbacks are called in an arbitrary order meaning that the\nerror value passed may have already been altered by another callback.\n\nHere a return value of `:ok` will continue calls to other callbacks without\nmodifying the error value.","ref":"Reactor.Middleware.html#c:error/2","title":"Reactor.Middleware.error/2","type":"callback"},{"doc":"Receive events about the execution of the Reactor.\n\nThis callback will block the Reactor, so it's encouraged that you do anything\nexpensive in another process.","ref":"Reactor.Middleware.html#c:event/3","title":"Reactor.Middleware.event/3","type":"callback"},{"doc":"Called before starting an asynchronous step in order to retrieve any context\ninformation that needs to be passed into the new process.\n\nThis is most likely used by tracers to copy span information from the parent\nprocess to the child process.","ref":"Reactor.Middleware.html#c:get_process_context/0","title":"Reactor.Middleware.get_process_context/0","type":"callback"},{"doc":"The halt callback will be called with the Reactor context when halting.\n\nThis allows you to clean up any non-reactor-managed resources or modify the\ncontext for later re-use by a future `init/1` callback.","ref":"Reactor.Middleware.html#c:halt/1","title":"Reactor.Middleware.halt/1","type":"callback"},{"doc":"The init callback will be called with the Reactor context when starting up.\n\nThis gives you the opportunity to modify the context or to perform any\ninitialisation of any non-reactor-managed resources (eg notifications).","ref":"Reactor.Middleware.html#c:init/1","title":"Reactor.Middleware.init/1","type":"callback"},{"doc":"Called inside a new asynchronous step in order to set context information into\nthe new process.\n\nThis is most likely used by tracers to copy span information from the parent\nprocess to the child process.","ref":"Reactor.Middleware.html#c:set_process_context/1","title":"Reactor.Middleware.set_process_context/1","type":"callback"},{"doc":"","ref":"Reactor.Middleware.html#t:context/0","title":"Reactor.Middleware.context/0","type":"type"},{"doc":"","ref":"Reactor.Middleware.html#t:error_or_errors/0","title":"Reactor.Middleware.error_or_errors/0","type":"type"},{"doc":"","ref":"Reactor.Middleware.html#t:result/0","title":"Reactor.Middleware.result/0","type":"type"},{"doc":"","ref":"Reactor.Middleware.html#t:step_event/0","title":"Reactor.Middleware.step_event/0","type":"type"},{"doc":"","ref":"Reactor.Middleware.html#t:t/0","title":"Reactor.Middleware.t/0","type":"type"},{"doc":"A Reactor middleware that emits telemetry events.\n\nThe following events are emitted:\n\n* `[:reactor, :run, :start]`\n* `[:reactor, :run, :stop]`\n* `[:reactor, :step, :run, :start]`\n* `[:reactor, :step, :run, :stop]`\n* `[:reactor, :step, :process, :start]`\n* `[:reactor, :step, :process, :stop]`\n* `[:reactor, :step, :compensate, :start]`\n* `[:reactor, :step, :compensate, :stop]`\n* `[:reactor, :step, :undo, :start]`\n* `[:reactor, :step, :undo, :stop]`","ref":"Reactor.Middleware.Telemetry.html","title":"Reactor.Middleware.Telemetry","type":"module"},{"doc":"Uses `splode` to manage various classes of error.","ref":"Reactor.Error.html","title":"Reactor.Error","type":"module"},{"doc":"Convenience wrapper around `use Splode.Error`","ref":"Reactor.Error.html#__using__/1","title":"Reactor.Error.__using__/1","type":"macro"},{"doc":"","ref":"Reactor.Error.html#splode_error?/2","title":"Reactor.Error.splode_error?/2","type":"function"},{"doc":"","ref":"Reactor.Error.html#t:class/0","title":"Reactor.Error.class/0","type":"type"},{"doc":"","ref":"Reactor.Error.html#t:class_module/0","title":"Reactor.Error.class_module/0","type":"type"},{"doc":"","ref":"Reactor.Error.html#t:error_class/0","title":"Reactor.Error.error_class/0","type":"type"},{"doc":"","ref":"Reactor.Error.html#t:t/0","title":"Reactor.Error.t/0","type":"type"},{"doc":"The [Splode error class](e:splode:get-started-with-splode.html#error-classes)\nfor Reactor-caused errors.","ref":"Reactor.Error.Internal.html","title":"Reactor.Error.Internal","type":"exception"},{"doc":"","ref":"Reactor.Error.Internal.html#exception/0","title":"Reactor.Error.Internal.exception/0","type":"function"},{"doc":"This error is returned when two Reactors cannot be composed together.","ref":"Reactor.Error.Internal.ComposeError.html","title":"Reactor.Error.Internal.ComposeError","type":"exception"},{"doc":"","ref":"Reactor.Error.Internal.ComposeError.html#exception/0","title":"Reactor.Error.Internal.ComposeError.exception/0","type":"function"},{"doc":"This error is returned when the Reactor's return name doesn't match any of the\nknown step results.","ref":"Reactor.Error.Internal.MissingReturnResultError.html","title":"Reactor.Error.Internal.MissingReturnResultError","type":"exception"},{"doc":"","ref":"Reactor.Error.Internal.MissingReturnResultError.html#exception/0","title":"Reactor.Error.Internal.MissingReturnResultError.exception/0","type":"function"},{"doc":"This error is returned when the step graph cannot be built.","ref":"Reactor.Error.Internal.PlanError.html","title":"Reactor.Error.Internal.PlanError","type":"exception"},{"doc":"","ref":"Reactor.Error.Internal.PlanError.html#exception/0","title":"Reactor.Error.Internal.PlanError.exception/0","type":"function"},{"doc":"An error that should never happen.","ref":"Reactor.Error.Internal.UnreachableError.html","title":"Reactor.Error.Internal.UnreachableError","type":"exception"},{"doc":"","ref":"Reactor.Error.Internal.UnreachableError.html#exception/0","title":"Reactor.Error.Internal.UnreachableError.exception/0","type":"function"},{"doc":"Create an unreachable error.","ref":"Reactor.Error.Internal.UnreachableError.html#unreachable/1","title":"Reactor.Error.Internal.UnreachableError.unreachable/1","type":"macro"},{"doc":"Bang version of `unreachable/1`.","ref":"Reactor.Error.Internal.UnreachableError.html#unreachable!/1","title":"Reactor.Error.Internal.UnreachableError.unreachable!/1","type":"macro"},{"doc":"The [Splode error class](e:splode:get-started-with-splode.html#error-classes)\nfor user-caused errors.","ref":"Reactor.Error.Invalid.html","title":"Reactor.Error.Invalid","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.html#exception/0","title":"Reactor.Error.Invalid.exception/0","type":"function"},{"doc":"This error is returned when an argument cannot have a subpath applied to it.","ref":"Reactor.Error.Invalid.ArgumentSubpathError.html","title":"Reactor.Error.Invalid.ArgumentSubpathError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.ArgumentSubpathError.html#exception/0","title":"Reactor.Error.Invalid.ArgumentSubpathError.exception/0","type":"function"},{"doc":"This error is returned when an error occurs during step compensation.\n\nIts `error` key will contain the error that was raised or returned by the\n`c:Step.compensate/4` callback.","ref":"Reactor.Error.Invalid.CompensateStepError.html","title":"Reactor.Error.Invalid.CompensateStepError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.CompensateStepError.html#exception/0","title":"Reactor.Error.Invalid.CompensateStepError.exception/0","type":"function"},{"doc":"This error is returned when a step returns an invalid result.","ref":"Reactor.Error.Invalid.InvalidResultError.html","title":"Reactor.Error.Invalid.InvalidResultError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.InvalidResultError.html#exception/0","title":"Reactor.Error.Invalid.InvalidResultError.exception/0","type":"function"},{"doc":"This error is returned when an expected argument is not passed to a step.","ref":"Reactor.Error.Invalid.MissingArgumentError.html","title":"Reactor.Error.Invalid.MissingArgumentError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.MissingArgumentError.html#exception/0","title":"Reactor.Error.Invalid.MissingArgumentError.exception/0","type":"function"},{"doc":"Error raised when a required Reactor input is missing.","ref":"Reactor.Error.Invalid.MissingInputError.html","title":"Reactor.Error.Invalid.MissingInputError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.MissingInputError.html#exception/0","title":"Reactor.Error.Invalid.MissingInputError.exception/0","type":"function"},{"doc":"This error is returned when a step attempts to consume an intermediate result\nwhich is not present in the Reactor state.","ref":"Reactor.Error.Invalid.MissingResultError.html","title":"Reactor.Error.Invalid.MissingResultError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.MissingResultError.html#exception/0","title":"Reactor.Error.Invalid.MissingResultError.exception/0","type":"function"},{"doc":"This error is returned when a step attempts to retry more times that is\nallowed.","ref":"Reactor.Error.Invalid.RetriesExceededError.html","title":"Reactor.Error.Invalid.RetriesExceededError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.RetriesExceededError.html#exception/0","title":"Reactor.Error.Invalid.RetriesExceededError.exception/0","type":"function"},{"doc":"This error is returned when an error occurs during step execution.\n\nIts `error` key will contain the error that was raised or returned by the\n`c:Step.run/3` callback.","ref":"Reactor.Error.Invalid.RunStepError.html","title":"Reactor.Error.Invalid.RunStepError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.RunStepError.html#exception/0","title":"Reactor.Error.Invalid.RunStepError.exception/0","type":"function"},{"doc":"An error which occurs when building and running transforms.","ref":"Reactor.Error.Invalid.TransformError.html","title":"Reactor.Error.Invalid.TransformError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.TransformError.html#exception/0","title":"Reactor.Error.Invalid.TransformError.exception/0","type":"function"},{"doc":"An error used when a step runs out of retry events and no other error is\nthrown.","ref":"Reactor.Error.Invalid.UndoRetriesExceededError.html","title":"Reactor.Error.Invalid.UndoRetriesExceededError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.UndoRetriesExceededError.html#exception/0","title":"Reactor.Error.Invalid.UndoRetriesExceededError.exception/0","type":"function"},{"doc":"This error is returned when an error occurs when attempting to undo step execution.\n\nIts `error` key will contain the error that was raised or returned by the\n`c:Step.undo/4` callback.","ref":"Reactor.Error.Invalid.UndoStepError.html","title":"Reactor.Error.Invalid.UndoStepError","type":"exception"},{"doc":"","ref":"Reactor.Error.Invalid.UndoStepError.html#exception/0","title":"Reactor.Error.Invalid.UndoStepError.exception/0","type":"function"},{"doc":"The [Splode error class](e:splode:get-started-with-splode.html#error-classes)\nfor unknown errors.","ref":"Reactor.Error.Unknown.html","title":"Reactor.Error.Unknown","type":"exception"},{"doc":"","ref":"Reactor.Error.Unknown.html#exception/0","title":"Reactor.Error.Unknown.exception/0","type":"function"},{"doc":"An error used to wrap unknown errors.","ref":"Reactor.Error.Unknown.UnknownError.html","title":"Reactor.Error.Unknown.UnknownError","type":"exception"},{"doc":"","ref":"Reactor.Error.Unknown.UnknownError.html#exception/0","title":"Reactor.Error.Unknown.UnknownError.exception/0","type":"function"},{"doc":"The [Splode error class](e:splode:get-started-with-splode.html#error-classes)\nfor validation errors.","ref":"Reactor.Error.Validation.html","title":"Reactor.Error.Validation","type":"exception"},{"doc":"","ref":"Reactor.Error.Validation.html#exception/0","title":"Reactor.Error.Validation.exception/0","type":"function"},{"doc":"An error returned when a Reactor cannot be validated because of a missing\nreturn value.","ref":"Reactor.Error.Validation.MissingReturnError.html","title":"Reactor.Error.Validation.MissingReturnError","type":"exception"},{"doc":"","ref":"Reactor.Error.Validation.MissingReturnError.html#exception/0","title":"Reactor.Error.Validation.MissingReturnError.exception/0","type":"function"},{"doc":"An error returned when a Reactor is in an unexpected state.","ref":"Reactor.Error.Validation.StateError.html","title":"Reactor.Error.Validation.StateError","type":"exception"},{"doc":"","ref":"Reactor.Error.Validation.StateError.html#exception/0","title":"Reactor.Error.Validation.StateError.exception/0","type":"function"},{"doc":"Build a new Reactor programmatically.\n\nYou don't _have_ to use the Reactor DSL to create a Reactor.  The functions in\nthis module allow you to define a Reactor programmatically.  This is\nespecially useful if you need to create a reactor dynamically (maybe based on\na UI such as [React Flow](https://reactflow.dev/)).","ref":"Reactor.Builder.html","title":"Reactor.Builder","type":"module"},{"doc":"```elixir\nreactor = Builder.new()\n{:ok, reactor} = Builder.add_input(reactor, :name)\nargument = Argument.from_input(:name)\n{:ok, reactor} = Builder.add_step(reactor, :greet, [argument])\n{:ok, reactor} = Builder.return(reactor, :greet)\n```","ref":"Reactor.Builder.html#module-example","title":"Example - Reactor.Builder","type":"module"},{"doc":"Add a named input to the Reactor.\n\nThis both places the input in the Reactor for later input validation and adds\nsteps to the Reactor which will emit and (possibly) transform the input.","ref":"Reactor.Builder.html#add_input/3","title":"Reactor.Builder.add_input/3","type":"function"},{"doc":"Raising version of `add_input/2..3`.","ref":"Reactor.Builder.html#add_input!/3","title":"Reactor.Builder.add_input!/3","type":"function"},{"doc":"Add a middleware to the Reactor.\n\nReturns an error if the middleware is already present on the Reactor.","ref":"Reactor.Builder.html#add_middleware/2","title":"Reactor.Builder.add_middleware/2","type":"function"},{"doc":"Raising version of `add_middleware/2`.","ref":"Reactor.Builder.html#add_middleware!/2","title":"Reactor.Builder.add_middleware!/2","type":"function"},{"doc":"Add a step to the Reactor.\n\nAdd a new step to the Reactor.  Rewrites input arguments to use the result of\nthe input steps and injects transformation steps as required.","ref":"Reactor.Builder.html#add_step/5","title":"Reactor.Builder.add_step/5","type":"function"},{"doc":"Raising version of `add_step/3..5`.","ref":"Reactor.Builder.html#add_step!/5","title":"Reactor.Builder.add_step!/5","type":"function"},{"doc":"Compose another Reactor inside this one.\n\nWhenever possible this function will extract the steps from inner Reactor and\nplace them inside the parent Reactor.  In order to achieve this the composer\nwill rename the steps to ensure that there are no conflicts.\n\nIf you're attempting to create a recursive Reactor (ie compose a Reactor\nwithin itself) then this will be detected and runtime composition will be used\ninstead.  See `Reactor.Step.Compose` for more details.","ref":"Reactor.Builder.html#compose/4","title":"Reactor.Builder.compose/4","type":"function"},{"doc":"Raising version of `compose/4`.","ref":"Reactor.Builder.html#compose!/4","title":"Reactor.Builder.compose!/4","type":"function"},{"doc":"Ensure that a middleware is present on the Reactor.","ref":"Reactor.Builder.html#ensure_middleware/2","title":"Reactor.Builder.ensure_middleware/2","type":"function"},{"doc":"Raising version of `ensure_middleware/2`.","ref":"Reactor.Builder.html#ensure_middleware!/2","title":"Reactor.Builder.ensure_middleware!/2","type":"function"},{"doc":"Build a new, empty Reactor.\n\nOptionally an identifier for the Reactor. This is primarily used for recursive\ncomposition tracking.","ref":"Reactor.Builder.html#new/1","title":"Reactor.Builder.new/1","type":"function"},{"doc":"Build a step which can be added to a reactor at runtime.\n\nNote that the built step doesn't support transformations - you should add an\nadditional step to do the transformation needed (this is what `add_step/5`\ndoes anyway).","ref":"Reactor.Builder.html#new_step/4","title":"Reactor.Builder.new_step/4","type":"function"},{"doc":"Raising version of `new_step/2..4`.","ref":"Reactor.Builder.html#new_step!/4","title":"Reactor.Builder.new_step!/4","type":"function"},{"doc":"Specify the return value of the Reactor.\n\nThe return value must be the name of a step.","ref":"Reactor.Builder.html#return/2","title":"Reactor.Builder.return/2","type":"function"},{"doc":"Raising version of `return/2`.","ref":"Reactor.Builder.html#return!/2","title":"Reactor.Builder.return!/2","type":"function"},{"doc":"Optionally transform all the arguments into new arguments","ref":"Reactor.Builder.html#t:arguments_transform/0","title":"Reactor.Builder.arguments_transform/0","type":"type"},{"doc":"Should the step be run asynchronously?","ref":"Reactor.Builder.html#t:async?/0","title":"Reactor.Builder.async?/0","type":"type"},{"doc":"Optional context which will be merged with the reactor context when calling this step.","ref":"Reactor.Builder.html#t:context/0","title":"Reactor.Builder.context/0","type":"type"},{"doc":"","ref":"Reactor.Builder.html#t:impl/0","title":"Reactor.Builder.impl/0","type":"type"},{"doc":"How many times is the step allowed to retry?","ref":"Reactor.Builder.html#t:max_retries/0","title":"Reactor.Builder.max_retries/0","type":"type"},{"doc":"","ref":"Reactor.Builder.html#t:ref/0","title":"Reactor.Builder.ref/0","type":"type"},{"doc":"","ref":"Reactor.Builder.html#t:step_argument/0","title":"Reactor.Builder.step_argument/0","type":"type"},{"doc":"","ref":"Reactor.Builder.html#t:step_options/0","title":"Reactor.Builder.step_options/0","type":"type"},{"doc":"Handle composition of Reactors for the builder.\n\nThe composition logic was getting complicated enough that it seemed sensible\nto extract it from the builder - if only to aid readability.\n\nYou should not use this module directly, but instead use\n`Reactor.Builder.compose/4`.","ref":"Reactor.Builder.Compose.html","title":"Reactor.Builder.Compose","type":"module"},{"doc":"Compose another Reactor inside this one.","ref":"Reactor.Builder.Compose.html#compose/4","title":"Reactor.Builder.Compose.compose/4","type":"function"},{"doc":"","ref":"Reactor.Builder.Compose.html#do_static_compose/4","title":"Reactor.Builder.Compose.do_static_compose/4","type":"function"},{"doc":"Handle adding inputs to Reactors for the builder.\n\nYou should not use this module directly, but instead use\n`Reactor.Builder.add_input/3`.","ref":"Reactor.Builder.Input.html","title":"Reactor.Builder.Input","type":"module"},{"doc":"Add a named input to the reactor.","ref":"Reactor.Builder.Input.html#add_input/3","title":"Reactor.Builder.Input.add_input/3","type":"function"},{"doc":"Handle building and adding steps to Reactors for the builder.\n\nYou should not use this module directly, but instead use\n`Reactor.Builder.new_step/4` and `Reactor.Builder.add_step/5`.","ref":"Reactor.Builder.Step.html","title":"Reactor.Builder.Step","type":"module"},{"doc":"Build and add a new step to a Reactor.","ref":"Reactor.Builder.Step.html#add_step/5","title":"Reactor.Builder.Step.add_step/5","type":"function"},{"doc":"* `reactor` - An existing Reactor struct to add the step to.\n* `name` - The proposed name of the new step.\n* `impl` - A module implementing the `Reactor.Step` behaviour (or a tuple\n  containing the module and options).\n* `arguments` - A list of `Reactor.Argument` structs or shorthand keyword\n  lists.","ref":"Reactor.Builder.Step.html#add_step/5-arguments","title":"Arguments - Reactor.Builder.Step.add_step/5","type":"function"},{"doc":"* `:async?` (`t:boolean/0`) - Allow the step to be run asynchronously? The default value is `true`.\n\n* `:max_retries` - The maximum number of times the step can ask to be retried The default value is `100`.\n\n* `:transform` - A function which can modify all incoming arguments\n\n* `:context` (`t:map/0`) - Context which will be merged with the reactor context when calling this step\n\n* `:ref` - What sort of step reference to generate Valid values are :step_name, :make_ref The default value is `:make_ref`.","ref":"Reactor.Builder.Step.html#add_step/5-options","title":"Options - Reactor.Builder.Step.add_step/5","type":"function"},{"doc":"Dynamically build a new step for later use.\n\nYou're most likely to use this when dynamically returning new steps from an\nexisting step.","ref":"Reactor.Builder.Step.html#new_step/4","title":"Reactor.Builder.Step.new_step/4","type":"function"},{"doc":"* `name` - The name of the new step.\n* `impl` - A module implementing the `Reactor.Step` behaviour (or a tuple\n  containing the module and options).\n* `arguments` - A list of `Reactor.Argument` structs or shorthand keyword\n  lists.","ref":"Reactor.Builder.Step.html#new_step/4-arguments","title":"Arguments - Reactor.Builder.Step.new_step/4","type":"function"},{"doc":"* `:async?` (`t:boolean/0`) - Allow the step to be run asynchronously? The default value is `true`.\n\n* `:max_retries` - The maximum number of times the step can ask to be retried The default value is `100`.\n\n* `:transform` - A function which can modify all incoming arguments\n\n* `:context` (`t:map/0`) - Context which will be merged with the reactor context when calling this step\n\n* `:ref` - What sort of step reference to generate Valid values are :step_name, :make_ref The default value is `:make_ref`.","ref":"Reactor.Builder.Step.html#new_step/4-options","title":"Options - Reactor.Builder.Step.new_step/4","type":"function"},{"doc":"A step argument.","ref":"Reactor.Argument.html","title":"Reactor.Argument","type":"module"},{"doc":"Build an argument which refers to to an element within a map step with an optional transformation applied.","ref":"Reactor.Argument.html#from_element/3","title":"Reactor.Argument.from_element/3","type":"function"},{"doc":"iex> Argument.from_element(:argument_name, &Atom.to_string/1)","ref":"Reactor.Argument.html#from_element/3-example","title":"Example - Reactor.Argument.from_element/3","type":"function"},{"doc":"Build an argument which refers to a reactor input with an optional\ntransformation applied.","ref":"Reactor.Argument.html#from_input/3","title":"Reactor.Argument.from_input/3","type":"function"},{"doc":"iex> Argument.from_input(:argument_name, :input_name, &String.to_integer/1)","ref":"Reactor.Argument.html#from_input/3-example","title":"Example - Reactor.Argument.from_input/3","type":"function"},{"doc":"Build an argument which refers to the result of another step with an optional\ntransformation applied.","ref":"Reactor.Argument.html#from_result/3","title":"Reactor.Argument.from_result/3","type":"function"},{"doc":"iex> Argument.from_result(:argument_name, :step_name, &Atom.to_string/1)","ref":"Reactor.Argument.html#from_result/3-example","title":"Example - Reactor.Argument.from_result/3","type":"function"},{"doc":"Build an argument directly from a template.","ref":"Reactor.Argument.html#from_template/3","title":"Reactor.Argument.from_template/3","type":"function"},{"doc":"iex> Argument.from_template(:argument_name, Reactor.Dsl.Argument.input(:input_name))","ref":"Reactor.Argument.html#from_template/3-example","title":"Example - Reactor.Argument.from_template/3","type":"function"},{"doc":"Build an argument which refers to a statically defined value.","ref":"Reactor.Argument.html#from_value/3","title":"Reactor.Argument.from_value/3","type":"function"},{"doc":"iex> Argument.from_value(:argument_name, 10)","ref":"Reactor.Argument.html#from_value/3-example","title":"Example - Reactor.Argument.from_value/3","type":"function"},{"doc":"Validate that the argument source has a sub_path","ref":"Reactor.Argument.html#has_sub_path/1","title":"Reactor.Argument.has_sub_path/1","type":"macro"},{"doc":"Validate that the argument has a transform.","ref":"Reactor.Argument.html#has_transform/1","title":"Reactor.Argument.has_transform/1","type":"macro"},{"doc":"Validate that the argument is an Argument struct.","ref":"Reactor.Argument.html#is_argument/1","title":"Reactor.Argument.is_argument/1","type":"macro"},{"doc":"Validate that the argument contains an element.","ref":"Reactor.Argument.html#is_from_element/1","title":"Reactor.Argument.is_from_element/1","type":"macro"},{"doc":"Validate that the argument refers to a reactor input.","ref":"Reactor.Argument.html#is_from_input/1","title":"Reactor.Argument.is_from_input/1","type":"macro"},{"doc":"Validate that the argument refers to a step result.","ref":"Reactor.Argument.html#is_from_result/1","title":"Reactor.Argument.is_from_result/1","type":"macro"},{"doc":"Validate that the argument contains a static value.","ref":"Reactor.Argument.html#is_from_value/1","title":"Reactor.Argument.is_from_value/1","type":"macro"},{"doc":"Set a sub-path on the argument.","ref":"Reactor.Argument.html#sub_path/2","title":"Reactor.Argument.sub_path/2","type":"function"},{"doc":"iex> Argument.from_value(:example, :value)\n    ...> |> Argument.sub_path([:nested, :values])","ref":"Reactor.Argument.html#sub_path/2-example","title":"Example - Reactor.Argument.sub_path/2","type":"function"},{"doc":"","ref":"Reactor.Argument.html#t:t/0","title":"Reactor.Argument.t/0","type":"type"},{"doc":"A protocol which can be used to convert something into an argument.","ref":"Reactor.Argument.Build.html","title":"Reactor.Argument.Build","type":"protocol"},{"doc":"Convert the input into an argument.","ref":"Reactor.Argument.Build.html#build/1","title":"Reactor.Argument.Build.build/1","type":"function"},{"doc":"All the types that implement this protocol.","ref":"Reactor.Argument.Build.html#t:t/0","title":"Reactor.Argument.Build.t/0","type":"type"},{"doc":"The Reactor executor.\n\nThe executor handles the main loop of running a Reactor.\n\nThe algorithm is somewhat confusing, so here it is in pseudocode:\n\n1. Find any async tasks (from a previous loop) which are completed. Either\n   recurse or continue if none are found.\n2. Find any async steps in the plan which are ready to run (they have no\n   in-edges in the graph) and start as many as possible (given the constraints\n   of `max_concurrency` and the state of the concurrency pool).  Either start\n   over, or continue if none are found.\n3. Find a single synchronous step which is ready to run and execute it. If\n   there was one then recurse, otherwise continue.\n4. Check if there are no more steps left in the plan (there are zero\n   vertices).  If so, collect the return value and exit, otherwise recurse.\n\nWhenever a step is run, whether run synchronously or asynchronously, the\nfollowing happens:\n\n1. When the step is successful:\n  a. If the step is undoable (ie `Step.can?(module, :undo)?` returns `true`)\n     then the step and the result are stored in the Reactor's undo stack.\n  b. If the result is depended upon by another step (the graph has out-edges\n     for the step) _or_ the step is asking the reactor to halt then the\n     result is stored in the Reactor's intermediate results.\n  c. The step is removed from the graph (along with it's out-edges, freeing\n     up it's dependents to run).\n2. When the step is unsuccessful (returns an error tuple or raises):\n  a. If the step can be compensated then compensation is attempted up to five\n     times before giving up.\n  b. The reactor iterates it's undo stack calling undo on each step.\n3. When a step or compensation asks for a retry then the step is placed back\n   in the graph to be run again next iteration.","ref":"Reactor.Executor.html","title":"Reactor.Executor","type":"module"},{"doc":"Run a reactor.\n\nProvided a Reactor which has been planned and the correct inputs, then run\nthe Reactor until completion, halting or failure.\n\nYou probably shouldn't call this directly, but use `Reactor.run/4` instead.","ref":"Reactor.Executor.html#run/4","title":"Reactor.Executor.run/4","type":"function"},{"doc":"Handle the asynchronous execution of a batch of steps, along with any\nmutations to the reactor or execution state.","ref":"Reactor.Executor.Async.html","title":"Reactor.Executor.Async","type":"module"},{"doc":"When the Reactor needs to shut down for any reason, we need to await all the\ncurrently running asynchronous steps and delete any task vertices.","ref":"Reactor.Executor.Async.html#collect_remaining_tasks_for_shutdown/2","title":"Reactor.Executor.Async.collect_remaining_tasks_for_shutdown/2","type":"function"},{"doc":"Handle zero or one completed async steps and then decide what to do.","ref":"Reactor.Executor.Async.html#handle_completed_steps/2","title":"Reactor.Executor.Async.handle_completed_steps/2","type":"function"},{"doc":"Start as many of the provided steps as possible.\n\nTakes into account he maximum concurrency and available work slots.","ref":"Reactor.Executor.Async.html#start_steps/4","title":"Reactor.Executor.Async.start_steps/4","type":"function"},{"doc":"Manage shared concurrency pools for multiple Reactors.\n\nWhen running a Reactor you can pass the `concurrency_key` option, which will\ncause the Reactor to use the specified pool to ensure that the combined\nReactors never exceed the pool's available concurrency limit.\n\nThis avoids nested Reactors spawning too many workers and thrashing the\nsystem.\n\nThe process calling `allocate_pool/1` is monitored, and when it terminates\nit's allocation is removed.  Any processes which are using that pool will\nnot be able to allocate any new resources.","ref":"Reactor.Executor.ConcurrencyTracker.html","title":"Reactor.Executor.ConcurrencyTracker","type":"module"},{"doc":"Attempt to acquire a number of concurrency allocations from the pool.\n\nReturns `{:ok, n}` where `n` was the number of slots that were actually\nallocated.  It's important to note that whilst you may request `16` slots, if\nthere is only `3` available, then this function will return `{:ok, 3}` and you\nmust abide by it.\n\nIt is possible for this function to return `{:ok, 0}` if there is no slots\navailable.","ref":"Reactor.Executor.ConcurrencyTracker.html#acquire/2","title":"Reactor.Executor.ConcurrencyTracker.acquire/2","type":"function"},{"doc":"Allocate a new concurrency pool and set the maximum limit.","ref":"Reactor.Executor.ConcurrencyTracker.html#allocate_pool/1","title":"Reactor.Executor.ConcurrencyTracker.allocate_pool/1","type":"function"},{"doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Reactor.Executor.ConcurrencyTracker.html#child_spec/1","title":"Reactor.Executor.ConcurrencyTracker.child_spec/1","type":"function"},{"doc":"Release concurrency allocation back to the pool.","ref":"Reactor.Executor.ConcurrencyTracker.html#release/2","title":"Reactor.Executor.ConcurrencyTracker.release/2","type":"function"},{"doc":"Release the concurrency pool.\n\nThis deletes the pool, however doesn't affect any processes currently using\nit.  No more resources can be acquired by users of the pool key.","ref":"Reactor.Executor.ConcurrencyTracker.html#release_pool/1","title":"Reactor.Executor.ConcurrencyTracker.release_pool/1","type":"function"},{"doc":"Report the available and maximum concurrency for a pool.","ref":"Reactor.Executor.ConcurrencyTracker.html#status/1","title":"Reactor.Executor.ConcurrencyTracker.status/1","type":"function"},{"doc":"","ref":"Reactor.Executor.ConcurrencyTracker.html#t:pool_key/0","title":"Reactor.Executor.ConcurrencyTracker.pool_key/0","type":"type"},{"doc":"","ref":"Reactor.Executor.ConcurrencyTracker.html#t:record/0","title":"Reactor.Executor.ConcurrencyTracker.record/0","type":"type"},{"doc":"Handles the execution of reactor middleware hooks.","ref":"Reactor.Executor.Hooks.html","title":"Reactor.Executor.Hooks","type":"module"},{"doc":"Run the completion hooks allowing the result to be replaced","ref":"Reactor.Executor.Hooks.html#complete/3","title":"Reactor.Executor.Hooks.complete/3","type":"function"},{"doc":"Run the error hooks allowing the error to be replaced","ref":"Reactor.Executor.Hooks.html#error/3","title":"Reactor.Executor.Hooks.error/3","type":"function"},{"doc":"Emit a step event.","ref":"Reactor.Executor.Hooks.html#event/4","title":"Reactor.Executor.Hooks.event/4","type":"function"},{"doc":"Run any get_process_context hooks","ref":"Reactor.Executor.Hooks.html#get_process_contexts/1","title":"Reactor.Executor.Hooks.get_process_contexts/1","type":"function"},{"doc":"Run the halt hooks collecting the new context as it goes","ref":"Reactor.Executor.Hooks.html#halt/2","title":"Reactor.Executor.Hooks.halt/2","type":"function"},{"doc":"Run the init hooks collecting the new context as it goes","ref":"Reactor.Executor.Hooks.html#init/2","title":"Reactor.Executor.Hooks.init/2","type":"function"},{"doc":"Run set_process_context hooks given the result of `get_process_contexts/1`","ref":"Reactor.Executor.Hooks.html#set_process_contexts/1","title":"Reactor.Executor.Hooks.set_process_contexts/1","type":"function"},{"doc":"Handle argument checking and state setup for a Reactor run.","ref":"Reactor.Executor.Init.html","title":"Reactor.Executor.Init","type":"module"},{"doc":"Contains the reactor execution state.\n\nThis is run-time only information.","ref":"Reactor.Executor.State.html","title":"Reactor.Executor.State","type":"module"},{"doc":"","ref":"Reactor.Executor.State.html#t:t/0","title":"Reactor.Executor.State.t/0","type":"type"},{"doc":"Run an individual step, including compensation if possible.","ref":"Reactor.Executor.StepRunner.html","title":"Reactor.Executor.StepRunner","type":"module"},{"doc":"Collect the arguments and and run a step, with compensation if required.","ref":"Reactor.Executor.StepRunner.html#run/4","title":"Reactor.Executor.StepRunner.run/4","type":"function"},{"doc":"Run a step inside a task.\n\nThis is a simple wrapper around `run/4` except that it emits more events.","ref":"Reactor.Executor.StepRunner.html#run_async/5","title":"Reactor.Executor.StepRunner.run_async/5","type":"function"},{"doc":"Undo a step if possible.","ref":"Reactor.Executor.StepRunner.html#undo/5","title":"Reactor.Executor.StepRunner.undo/5","type":"function"},{"doc":"Handle the synchronous execution of a single step, along with any mutations to\nthe reactor or execution state.","ref":"Reactor.Executor.Sync.html","title":"Reactor.Executor.Sync","type":"module"},{"doc":"Try and run a step synchronously.","ref":"Reactor.Executor.Sync.html#run/3","title":"Reactor.Executor.Sync.run/3","type":"function"},{"doc":"Introspection for the Reactor DSL.","ref":"Reactor.Info.html","title":"Reactor.Info","type":"module"},{"doc":"reactor DSL entities","ref":"Reactor.Info.html#reactor/1","title":"Reactor.Info.reactor/1","type":"function"},{"doc":"reactor.middlewares DSL entities","ref":"Reactor.Info.html#reactor_middlewares/1","title":"Reactor.Info.reactor_middlewares/1","type":"function"},{"doc":"reactor DSL options\n\nReturns a map containing the and any configured or default values.","ref":"Reactor.Info.html#reactor_options/1","title":"Reactor.Info.reactor_options/1","type":"function"},{"doc":"Specify which step result to return upon completion.","ref":"Reactor.Info.html#reactor_return/1","title":"Reactor.Info.reactor_return/1","type":"function"},{"doc":"Specify which step result to return upon completion.","ref":"Reactor.Info.html#reactor_return!/1","title":"Reactor.Info.reactor_return!/1","type":"function"},{"doc":"Convert a reactor DSL module into a reactor struct.","ref":"Reactor.Info.html#to_struct/1","title":"Reactor.Info.to_struct/1","type":"function"},{"doc":"Raising version of `to_struct/1`.","ref":"Reactor.Info.html#to_struct!/1","title":"Reactor.Info.to_struct!/1","type":"function"},{"doc":"Build an execution plan for a Reactor.\n\nConverts any unplanned steps into vertices in a graph with directed edges\nbetween them representing their dependencies (arguments).","ref":"Reactor.Planner.html","title":"Reactor.Planner","type":"module"},{"doc":"Build an execution plan for a Reactor.\n\nBuilds a graph of the step dependencies, resolves them and then builds an execution plan.","ref":"Reactor.Planner.html#plan/1","title":"Reactor.Planner.plan/1","type":"function"},{"doc":"Raising version of `plan/1`.","ref":"Reactor.Planner.html#plan!/1","title":"Reactor.Planner.plan!/1","type":"function"},{"doc":"Templates used to refer to some sort of computed value.","ref":"Reactor.Template.html","title":"Reactor.Template","type":"module"},{"doc":"A guard for element templates","ref":"Reactor.Template.html#is_element_template/1","title":"Reactor.Template.is_element_template/1","type":"macro"},{"doc":"A guard for input templates","ref":"Reactor.Template.html#is_input_template/1","title":"Reactor.Template.is_input_template/1","type":"macro"},{"doc":"A guard for result templates","ref":"Reactor.Template.html#is_result_template/1","title":"Reactor.Template.is_result_template/1","type":"macro"},{"doc":"A guard to detect all template types","ref":"Reactor.Template.html#is_template/1","title":"Reactor.Template.is_template/1","type":"macro"},{"doc":"A guard for value templates","ref":"Reactor.Template.html#is_value_template/1","title":"Reactor.Template.is_value_template/1","type":"macro"},{"doc":"The type for use in option schemas","ref":"Reactor.Template.html#type/0","title":"Reactor.Template.type/0","type":"function"},{"doc":"","ref":"Reactor.Template.html#t:t/0","title":"Reactor.Template.t/0","type":"type"},{"doc":"The `element` template.","ref":"Reactor.Template.Element.html","title":"Reactor.Template.Element","type":"module"},{"doc":"","ref":"Reactor.Template.Element.html#t:t/0","title":"Reactor.Template.Element.t/0","type":"type"},{"doc":"The `input` template.","ref":"Reactor.Template.Input.html","title":"Reactor.Template.Input","type":"module"},{"doc":"","ref":"Reactor.Template.Input.html#t:t/0","title":"Reactor.Template.Input.t/0","type":"type"},{"doc":"The `result` template.","ref":"Reactor.Template.Result.html","title":"Reactor.Template.Result","type":"module"},{"doc":"","ref":"Reactor.Template.Result.html#t:t/0","title":"Reactor.Template.Result.t/0","type":"type"},{"doc":"A statically `value` template.","ref":"Reactor.Template.Value.html","title":"Reactor.Template.Value","type":"module"},{"doc":"","ref":"Reactor.Template.Value.html#t:t/0","title":"Reactor.Template.Value.t/0","type":"type"},{"doc":"# Reactor\n\n![Elixir CI](https://github.com/ash-project/reactor/actions/workflows/elixir.yml/badge.svg)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Hex version badge](https://img.shields.io/hexpm/v/reactor.svg)](https://hex.pm/packages/reactor)\n\nReactor is a dynamic, concurrent, dependency resolving saga orchestrator.\n\nWoah. That's a lot. Let's break it down:\n\n- **Saga orchestrator** A [saga][saga pattern] is a way of providing\n  transaction-like semantics across multiple distinct resources.\n- **Dependency resolving** reactor allows you to describe the dependencies\n  between your saga steps using _arguments_ which are converted into a\n  [DAG][dag] and used to compute execution order.\n- **Concurrent** unless otherwise specified reactor will run as many steps as\n  possible concurrently whilst taking into account the results of the dependency\n  resolution.\n- **Dynamic** whilst you can define a reactor statically using our awesome DSL,\n  you can also build workflows dynamically - and even add steps while the\n  reactor is running.\n\n[saga pattern](https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga)","ref":"readme.html","title":"Read Me","type":"extras"},{"doc":"Thanks to [Alembic Pty Ltd](https://alembic.com.au/) for sponsoring a portion of\nthis project's development.","ref":"readme.html#sponsors","title":"Sponsors - Read Me","type":"extras"},{"doc":"The package can be installed by adding `reactor` to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:reactor, \"~> 0.9.1\"}\n  ]\nend\n```","ref":"readme.html#installation","title":"Installation - Read Me","type":"extras"},{"doc":"Documentation for the latest release will be [available on\nhexdocs](https://hexdocs.pm/reactor) and for the [`main`\nbranch](https://ash-project.github.io/reactor).","ref":"readme.html#documentation","title":"Documentation - Read Me","type":"extras"},{"doc":"- To contribute updates, fixes or new features please fork and open a\n  pull-request against `main`.\n- Please use [conventional\n  commits](https://www.conventionalcommits.org/en/v1.0.0/) - this allows us to\n  dynamically generate the changelog.\n- Feel free to ask any questions on the `#reactor` channel on the [Ash\n  Discord](https://discord.gg/D7FNG2q).","ref":"readme.html#contributing","title":"Contributing - Read Me","type":"extras"},{"doc":"`reactor` is licensed under the terms of the [MIT\nlicense](https://opensource.org/licenses/MIT). See the [`LICENSE` file in this\nrepository](https://github.com/ash-project/reactor/blob/main/LICENSE)\nfor details.\n\n[saga pattern]: https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga\n[dag]: https://en.wikipedia.org/wiki/Directed_acyclic_graph","ref":"readme.html#licence","title":"Licence - Read Me","type":"extras"},{"doc":"# Getting started with Reactor\n\nReactor is a lot of things:\n\n- A [saga orchestrator](https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf).\n- A [composable DSL](https://hexdocs.pm/reactor/Reactor.html) for creating workflows.\n- A [builder](https://hexdocs.pm/reactor/Reactor.Builder.html) for dynamically creating workflows.\n- Capable of mixing concurrent and serialised workflows.\n- Resolves dependencies between tasks using a [directed acyclic graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph).\n\nLet's start by breaking down what each of these features are, and how we can use them.","ref":"getting-started-with-reactor.html","title":"Getting started with Reactor","type":"extras"},{"doc":"If you've been building apps long enough you will have used database transactions. They're amazing. Basically, if you put all your changes in a transaction and there's a failure then the transaction gets rolled back and the system is not left in an inconsistent state. This is great when you're working with a single database, but in the modern world we often have to integrate with [many](https://www.postgresql.org/) [different](https://www.mongodb.com/) [kinds](https://redis.io/) [of](https://cassandra.apache.org/_/index.html) [data](https://aws.amazon.com/redshift/) [stores](https://clickhouse.com/) and [as](https://www.salesforce.com/) [many](https://stripe.com/) [different](https://www.twilio.com/en-us) [SaaS](https://www.xero.com/) [products](https://www.vendhq.com/).\n\nOften we need to orchestrate a \"transaction\" across multiple services at once; for example:\n\n1. Register a new user\n2. Create a Stripe customer\n3. Create a Stripe subscription\n4. Send a transactional welcome email via SendGrid\n5. Track the conversion in Salesforce\n\nIf any of these steps fails we may want to retry or roll back depending on what failed and whether it's recoverable. Reactor allows us to do this by defining the `Reactor.Step` behaviour:\n\n```elixir\ndefmodule MyApp.CreateStripeSubscriptionStep do\n  use Reactor.Step\n\n  @impl true\n  def run(arguments, context, options) do\n    Stripe.Subscription.create(arguments.stripe_customer_id, items: [plan: arguments.stripe_plan_id])\n  end\n\n  @impl true\n  def compensate(%{code: :network_error}, arguments, context, options) do\n    :retry\n  end\n\n  def compensate(error, arguments, context, options) do\n    :ok\n  end\n\n  @impl true\n  def undo(subscription, arguments, context, options) do\n    case Stripe.Subscription.delete(subscription) do\n      {:ok, _} -> :ok\n      {:error, reason} -> {:error, reason}\n    end\n  end\nend\n```\n\nHere we've defined a step that tries to create a new Stripe subscription. If that fails then we have defined `compensate/4` check whether it was a network error, and if so ask the Reactor to retry, otherwise we return `:ok` because the subscription wasn't created so we don't have to do any other clean up. Lastly, we define `undo/4` to delete the subscription if the Reactor asks us to undo our work - which it will do if a step later in the workflow fails.\n\nHow do you compose these steps together you ask? Let's discuss that in the next section.","ref":"getting-started-with-reactor.html#transaction-like-semantics-with-sagas","title":"Transaction-like semantics with Sagas - Getting started with Reactor","type":"extras"},{"doc":"Reactor uses [`spark`](https://hexdocs.pm/spark/get-started-with-spark.html) to define an easy to use (and easy to extend) DSL for defining workflows. Let's start with an example:\n\n```elixir\ndefmodule MyApp.RegisterUserReactor do\n  use Reactor\n\n  input :email\n  input :password\n  input :plan_name\n\n  step :register_user, MyApp.RegisterUserStep do\n    argument :email, input(:email)\n    argument :password, input(:password)\n  end\n\n  step :create_stripe_customer, MyApp.CreateStripeCustomerStep do\n    argument :email, input(:email)\n  end\n\n  step :find_stripe_plan, MyApp.FindStripePlanStep do\n    argument :plan_name, input(:plan_name)\n  end\n\n  step :create_stripe_subscription, MyApp.CreateStripeSubscriptionStep do\n    argument :customer_id do\n      source result(:create_stripe_customer)\n      transform &(&1.id)\n    end\n\n    argument :plan_id do\n      source result(:get_stripe_plan)\n      transform &(&1.id)\n    end\n  end\n\n  step :send_welcome_email, MyApp.SendWelcomeEmailStep do\n    argument :email, input(:email)\n    argument :_subscription, result(:create_stripe_subscription)\n  end\n\n  step :track_conversion, MyApp.TrackSalesforceConversionStep do\n    argument :email, input(:email)\n    argument :plan_name, input(:plan_name)\n    argument :_welcome_email, result(:send_welcome_email)\n  end\n\n  return :register_user\nend\n```\n\nHere we've defined a Reactor that performs the steps needed for the user registration example above.\n\nHere we define the steps that need to be performed and describe the dependencies between them by way of arguments.\n\n> #### Beware of ordering {: .warning}\n>\n> Whilst the order of the steps in the example makes sense logically it has no\n> effect on the order that the Reactor will execute them in. This is the\n> fundamental difference between Reactor and other Saga tools in the Elixir\n> ecosystem.\n\nThe Reactor will put the steps into a graph with the steps as vertices and the arguments as edges and will find any that have no inbound edges and run as many of them at once as possible. This means that `:register_user`, `:create_stripe_customer` and `:find_stripe_plan` will all execute simultaneously, after which `:create_stripe_subscription`, then `:send_welcome_email` and `:track_conversion` will run. Notice that `:send_welcome_email` and `:track_conversion` have arguments that depend on the results of previews steps that they don't necessarily need, however we want to ensure that they don't run until all the important steps are complete (it's hard to unsend an email!)","ref":"getting-started-with-reactor.html#composing-steps-with-the-reactor-dsl","title":"Composing steps with the Reactor DSL - Getting started with Reactor","type":"extras"},{"doc":"While using the DSL makes it extremely easy to build a static workflow, sometimes you need the flexibility to build a workflow based on a set of criteria that may not be known at compile time (for example if you're using user input to build the workflow).\n\nEvery Reactor is ultimately an instance of the `Reactor` struct (you can use `Reactor.Info.to_struct(MyApp.RegisterUserReactor)` to see the one for the DSL Reactor above). The functions in `Reactor.Builder` can be used to create an identical workflow:\n\n    iex> reactor = Reactor.Builder.new()\n    ...> {:ok, reactor} = Reactor.Builder.add_input(reactor, :email)\n    ...> {:ok, reactor} = Reactor.Builder.add_input(reactor, :password)\n    ...> {:ok, reactor} = Reactor.Builder.add_input(reactor, :plan_name)\n    ...> {:ok, reactor} = Reactor.Builder.add_step(reactor, :register_user, MyApp.RegisterUserStep, email: {:input, :email}, password: {:input, :password})\n    # etc...","ref":"getting-started-with-reactor.html#building-workflows-programmatically","title":"Building workflows programmatically - Getting started with Reactor","type":"extras"},{"doc":"If you look at the `Reactor.Step` struct, you'll see that it has an `async?` field. This is available as a step DSL option, and as an option to `add_step/5`. It defaults to `true`, however if you set it to `false` Reactor will run the step synchronously. Note that it will only run synchronous steps when it has run out of async steps which can be started. Other than that caveat, Reactor will follow the same ordering rules as specified above.","ref":"getting-started-with-reactor.html#mixing-concurrent-and-synchronous-workflow-steps","title":"Mixing concurrent and synchronous workflow steps - Getting started with Reactor","type":"extras"},{"doc":"You can pass either a Reactor DSL module or a Reactor struct straight into the `Reactor.run/1..4` function.","ref":"getting-started-with-reactor.html#running-your-reactor","title":"Running your Reactor - Getting started with Reactor","type":"extras"},{"doc":"Any step in the flow can return `{:halt, value}` instead of `{:ok, value}`. When this happens Reactor will wait for any running asynchronous steps to finish and then halt the Reactor returning `{:halted, reactor}`. Later on you can resume the Reactor by passing the halted reactor to the `Reactor.run/1..4` function.","ref":"getting-started-with-reactor.html#halting-and-resuming-workflows","title":"Halting and resuming workflows - Getting started with Reactor","type":"extras"},{"doc":"Any step can return `{:ok, value, additional_steps}` instead of just `{:ok, value}` and those new steps will be added to the graph and have their dependencies calculated automatically. `additional_steps` should be a list of `Reactor.Step` structs, which you can create with `Reactor.Builder.new_step/2..4`.\n\nThere are a couple of additional things to be aware of when steps at run time:\n\n1. If you add steps that induce a cyclic dependency then the Reactor will commence an undo, just as if a step had failed.\n2. Steps can have the same name as other steps and their intermediate results will be replaced.\n3. You are allowed to make dependency cycles in the very specific case of a new\n   step relying on it's own output.","ref":"getting-started-with-reactor.html#dynamically-adding-steps-at-reactor-run-time","title":"Dynamically adding steps at Reactor run time - Getting started with Reactor","type":"extras"},{"doc":"<!--\nThis file was generated by Spark. Do not edit it by hand.\n-->\n# DSL: Reactor.Dsl","ref":"dsl-reactor.html","title":"DSL: Reactor.Dsl","type":"extras"},{"doc":"The top-level reactor DSL","ref":"dsl-reactor.html#reactor","title":"reactor - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [middlewares](#reactor-middlewares)\n   * middleware\n * [around](#reactor-around)\n   * argument\n   * wait_for\n * [collect](#reactor-collect)\n   * argument\n   * wait_for\n * [compose](#reactor-compose)\n   * argument\n   * wait_for\n * [debug](#reactor-debug)\n   * argument\n   * wait_for\n * [group](#reactor-group)\n   * argument\n   * wait_for\n * [input](#reactor-input)\n * [map](#reactor-map)\n   * argument\n   * wait_for\n * [step](#reactor-step)\n   * argument\n   * wait_for\n * [switch](#reactor-switch)\n   * matches?\n\n   * default","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`return`](#reactor-return){: #reactor-return } | `atom` |  | Specify which step result to return upon completion. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"Middleware to be added to the Reactor","ref":"dsl-reactor.html#reactor-middlewares","title":"reactor.middlewares - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [middleware](#reactor-middlewares-middleware)","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nmiddleware module\n```\n\n\nName a middleware to be added to the Reactor.","ref":"dsl-reactor.html#reactor-middlewares-middleware","title":"reactor.middlewares.middleware - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`module`](#reactor-middlewares-middleware-module){: #reactor-middlewares-middleware-module .spark-required} | `module` |  | The middleware to be added to the Reactor. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Middleware`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\naround name, fun \\\\ nil\n```\n\n\nWrap a function around a group of steps.","ref":"dsl-reactor.html#reactor-around","title":"reactor.around - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [argument](#reactor-around-argument)\n * [wait_for](#reactor-around-wait_for)","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-around-name){: #reactor-around-name .spark-required} | `atom` |  | A unique name for the group of steps. |\n| [`fun`](#reactor-around-fun){: #reactor-around-fun .spark-required} | `(any, any, any, any -> any) \\| mfa` |  | The around function. See `Reactor.Step.Around` for more information. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`allow_async?`](#reactor-around-allow_async?){: #reactor-around-allow_async? } | `boolean` | `false` | Whether the emitted steps should be allowed to run asynchronously. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nargument name, source \\\\ nil\n```\n\n\nSpecifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.","ref":"dsl-reactor.html#reactor-around-argument","title":"reactor.around.argument - DSL: Reactor.Dsl","type":"extras"},{"doc":"```\nargument :name, input(:name)\n\n```\n\n```\nargument :year, input(:date, [:year])\n\n```\n\n```\nargument :user, result(:create_user)\n\n```\n\n```\nargument :user_id, result(:create_user) do\n  transform & &1.id\nend\n\n```\n\n```\nargument :user_id, result(:create_user, [:id])\n\n```\n\n```\nargument :three, value(3)\n\n```","ref":"dsl-reactor.html#examples","title":"Examples - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-around-argument-name){: #reactor-around-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |\n| [`source`](#reactor-around-argument-source){: #reactor-around-argument-source .spark-required} | `Reactor.Template.Element \\| Reactor.Template.Input \\| Reactor.Template.Result \\| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`transform`](#reactor-around-argument-transform){: #reactor-around-argument-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Argument`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nwait_for names\n```\n\n\nWait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`","ref":"dsl-reactor.html#reactor-around-wait_for","title":"reactor.around.wait_for - DSL: Reactor.Dsl","type":"extras"},{"doc":"```\nwait_for :create_user\n```","ref":"dsl-reactor.html#examples","title":"Examples - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`names`](#reactor-around-wait_for-names){: #reactor-around-wait_for-names .spark-required} | `atom \\| list(atom)` |  | The name of the step to wait for. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.WaitFor`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Around`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\ncollect name\n```\n\n\nA Reactor step which simply collects and returns it's arguments.\n\nArguments can optionally be transformed before returning.","ref":"dsl-reactor.html#reactor-collect","title":"reactor.collect - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [argument](#reactor-collect-argument)\n * [wait_for](#reactor-collect-wait_for)","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"```\ncollect :latest_release_uri do\n  argument :repository, input(:repository)\n  argument :organisation, input(:organisation)\n\n  transform fn inputs ->\n    %{uri: \"https://api.github.com/repos/#{inputs.organisation}/#{inputs.repository}/releases/latest\"}\n  end\nend\n\n```","ref":"dsl-reactor.html#examples","title":"Examples - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-collect-name){: #reactor-collect-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`transform`](#reactor-collect-transform){: #reactor-collect-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the entire argument map before it is returned. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nargument name, source \\\\ nil\n```\n\n\nSpecifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.","ref":"dsl-reactor.html#reactor-collect-argument","title":"reactor.collect.argument - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-collect-argument-name){: #reactor-collect-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |\n| [`source`](#reactor-collect-argument-source){: #reactor-collect-argument-source .spark-required} | `Reactor.Template.Element \\| Reactor.Template.Input \\| Reactor.Template.Result \\| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`transform`](#reactor-collect-argument-transform){: #reactor-collect-argument-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nwait_for names\n```\n\n\nWait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`","ref":"dsl-reactor.html#reactor-collect-wait_for","title":"reactor.collect.wait_for - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`names`](#reactor-collect-wait_for-names){: #reactor-collect-wait_for-names .spark-required} | `atom \\| list(atom)` |  | The name of the step to wait for. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Collect`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\ncompose name, reactor\n```\n\n\nCompose another Reactor into this one.\n\nAllows place another Reactor into this one as if it were a single step.","ref":"dsl-reactor.html#reactor-compose","title":"reactor.compose - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [argument](#reactor-compose-argument)\n * [wait_for](#reactor-compose-wait_for)","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-compose-name){: #reactor-compose-name .spark-required} | `atom` |  | A unique name for the step. Allows the result of the composed reactor to be depended upon by steps in this reactor. |\n| [`reactor`](#reactor-compose-reactor){: #reactor-compose-reactor .spark-required} | `Reactor \\| module` |  | The reactor module or struct to compose upon. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nargument name, source \\\\ nil\n```\n\n\nSpecifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.","ref":"dsl-reactor.html#reactor-compose-argument","title":"reactor.compose.argument - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-compose-argument-name){: #reactor-compose-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |\n| [`source`](#reactor-compose-argument-source){: #reactor-compose-argument-source .spark-required} | `Reactor.Template.Element \\| Reactor.Template.Input \\| Reactor.Template.Result \\| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`transform`](#reactor-compose-argument-transform){: #reactor-compose-argument-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nwait_for names\n```\n\n\nWait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`","ref":"dsl-reactor.html#reactor-compose-wait_for","title":"reactor.compose.wait_for - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`names`](#reactor-compose-wait_for-names){: #reactor-compose-wait_for-names .spark-required} | `atom \\| list(atom)` |  | The name of the step to wait for. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Compose`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\ndebug name\n```\n\n\nInserts a step which will send debug information to the `Logger`.","ref":"dsl-reactor.html#reactor-debug","title":"reactor.debug - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [argument](#reactor-debug-argument)\n * [wait_for](#reactor-debug-wait_for)","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"```\ndebug :debug do\n  argument :suss, result(:suss_step)\nend\n\n```","ref":"dsl-reactor.html#examples","title":"Examples - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-debug-name){: #reactor-debug-name .spark-required} | `atom` |  | A unique identifier for the step. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`level`](#reactor-debug-level){: #reactor-debug-level } | `:emergency \\| :alert \\| :critical \\| :error \\| :warning \\| :notice \\| :info \\| :debug` | `:debug` | The log level to send the debug information to. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nargument name, source \\\\ nil\n```\n\n\nSpecifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.","ref":"dsl-reactor.html#reactor-debug-argument","title":"reactor.debug.argument - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-debug-argument-name){: #reactor-debug-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |\n| [`source`](#reactor-debug-argument-source){: #reactor-debug-argument-source .spark-required} | `Reactor.Template.Element \\| Reactor.Template.Input \\| Reactor.Template.Result \\| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`transform`](#reactor-debug-argument-transform){: #reactor-debug-argument-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nwait_for names\n```\n\n\nWait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`","ref":"dsl-reactor.html#reactor-debug-wait_for","title":"reactor.debug.wait_for - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`names`](#reactor-debug-wait_for-names){: #reactor-debug-wait_for-names .spark-required} | `atom \\| list(atom)` |  | The name of the step to wait for. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Debug`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\ngroup name\n```\n\n\nCall functions before and after a group of steps.","ref":"dsl-reactor.html#reactor-group","title":"reactor.group - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [argument](#reactor-group-argument)\n * [wait_for](#reactor-group-wait_for)","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-group-name){: #reactor-group-name .spark-required} | `atom` |  | A unique name for the group of steps. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`before_all`](#reactor-group-before_all){: #reactor-group-before_all .spark-required} | `(any, any, any -> any) \\| mfa` |  | The before function. See `Reactor.Step.Group` for more information. |\n| [`after_all`](#reactor-group-after_all){: #reactor-group-after_all .spark-required} | `(any -> any) \\| mfa` |  | The after function. See `Reactor.Step.Group` for more information. |\n| [`allow_async?`](#reactor-group-allow_async?){: #reactor-group-allow_async? } | `boolean` | `true` | Whether the emitted steps should be allowed to run asynchronously. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nargument name, source \\\\ nil\n```\n\n\nSpecifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.","ref":"dsl-reactor.html#reactor-group-argument","title":"reactor.group.argument - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-group-argument-name){: #reactor-group-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |\n| [`source`](#reactor-group-argument-source){: #reactor-group-argument-source .spark-required} | `Reactor.Template.Element \\| Reactor.Template.Input \\| Reactor.Template.Result \\| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`transform`](#reactor-group-argument-transform){: #reactor-group-argument-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nwait_for names\n```\n\n\nWait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`","ref":"dsl-reactor.html#reactor-group-wait_for","title":"reactor.group.wait_for - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`names`](#reactor-group-wait_for-names){: #reactor-group-wait_for-names .spark-required} | `atom \\| list(atom)` |  | The name of the step to wait for. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Group`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\ninput name\n```\n\n\nSpecifies an input to the Reactor.\n\nAn input is a value passed in to the Reactor when executing.\nIf a Reactor were a function, these would be it's arguments.\n\nInputs can be transformed with an arbitrary function before being passed\nto any steps.","ref":"dsl-reactor.html#reactor-input","title":"reactor.input - DSL: Reactor.Dsl","type":"extras"},{"doc":"```\ninput :name\n\n```\n\n```\ninput :age do\n  transform &String.to_integer/1\nend\n\n```","ref":"dsl-reactor.html#examples","title":"Examples - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-input-name){: #reactor-input-name .spark-required} | `atom` |  | A unique name for this input. Used to allow steps to depend on it. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`transform`](#reactor-input-transform){: #reactor-input-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the input before it is passed to any steps. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Input`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nmap name\n```\n\n\nExecute nested steps for every item of an iterator.\n\nAllows you to \"map over\" a collection applying a some steps to each element,\nreturning a list of new values.  The input collection must be bounded - ie you\ncannot pass infinite streams into this step or it will just loop forever - and\nbecause it has to keep the results from each batch will eventually just use up\nall available RAM.\n\nUnder the hood we use `Iter` to handle lazy iteration of the collection.  This\nmeans that you can pass an `Iter.t` or any value for which `Iter.IntoIterable`\nis implemented.\n\n> #### A note on ordering {: .tip}\n>\n> If your application doesn't need the results back in the same order that they\n> were provided then setting `strict_ordering?` to `false` will increase\n> performance - especially on large input sets.","ref":"dsl-reactor.html#reactor-map","title":"reactor.map - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [argument](#reactor-map-argument)\n * [wait_for](#reactor-map-wait_for)","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"```\nmap :double_numbers do\n  input input(:numbers)\n\n  step :double do\n    argument :number, element(:double_numbers)\n\n    run %{number: number}, _, _ ->\n      {:ok, number * 2}\n    end\n  end\nend\n\n```\n\n```\nstep :get_subscriptions do\n  run _, _, _ ->\n    Stripe.Subscription.list()\n  end\nend\n\nmap :cancel_subscriptions do\n  input result(:get_subscriptions)\n\n  step :cancel do\n    argument :sub_id, element(:cancel_subscriptions, [:id])\n\n    run fn args, _, _ ->\n      Stripe.Subscription.cancel(arg.sub_id, %{prorate: true, invoice_now: true})\n    end\n  end\n\n  return :cancel\nend\n\n```","ref":"dsl-reactor.html#examples","title":"Examples - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-map-name){: #reactor-map-name .spark-required} | `atom` |  | A unique name for the step. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`source`](#reactor-map-source){: #reactor-map-source .spark-required} | `Reactor.Template.Element \\| Reactor.Template.Input \\| Reactor.Template.Result \\| Reactor.Template.Value` |  | The iterator or enumerable to use as the source of the iteration. |\n| [`allow_async?`](#reactor-map-allow_async?){: #reactor-map-allow_async? } | `boolean` | `false` | Whether the emitted steps should be allowed to run asynchronously. |\n| [`batch_size`](#reactor-map-batch_size){: #reactor-map-batch_size } | `pos_integer` | `100` | The number of items to consume off the source when emitting steps. |\n| [`return`](#reactor-map-return){: #reactor-map-return } | `atom` |  | The name of the nested step to use as the return value. |\n| [`strict_ordering?`](#reactor-map-strict_ordering?){: #reactor-map-strict_ordering? } | `boolean` | `true` | Whether the mapped values must be returned in the same order that they were provided. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nargument name, source \\\\ nil\n```\n\n\nSpecifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.","ref":"dsl-reactor.html#reactor-map-argument","title":"reactor.map.argument - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-map-argument-name){: #reactor-map-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |\n| [`source`](#reactor-map-argument-source){: #reactor-map-argument-source .spark-required} | `Reactor.Template.Element \\| Reactor.Template.Input \\| Reactor.Template.Result \\| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`transform`](#reactor-map-argument-transform){: #reactor-map-argument-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nwait_for names\n```\n\n\nWait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`","ref":"dsl-reactor.html#reactor-map-wait_for","title":"reactor.map.wait_for - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`names`](#reactor-map-wait_for-names){: #reactor-map-wait_for-names .spark-required} | `atom \\| list(atom)` |  | The name of the step to wait for. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Map`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nstep name, impl \\\\ nil\n```\n\n\nSpecifies a Reactor step.\n\nSteps are the unit of work in a Reactor.  Reactor will calculate the\ndependencies graph between the steps and execute as many as it can in each\niteration.\n\nSee the `Reactor.Step` behaviour for more information.","ref":"dsl-reactor.html#reactor-step","title":"reactor.step - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [argument](#reactor-step-argument)\n * [wait_for](#reactor-step-wait_for)","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"```\nstep :create_user, MyApp.Steps.CreateUser do\n  argument :username, input(:username)\n  argument :password_hash, result(:hash_password)\nend\n\n```\n\n```\nstep :hash_password do\n  argument :password, input(:password)\n\n  run fn %{password: password}, _ ->\n    {:ok, Bcrypt.hash_pwd_salt(password)}\n  end\nend\n\n```","ref":"dsl-reactor.html#examples","title":"Examples - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-step-name){: #reactor-step-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps. |\n| [`impl`](#reactor-step-impl){: #reactor-step-impl } | `module \\| nil` |  | A module that implements the `Reactor.Step` behaviour that provides the implementation. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`run`](#reactor-step-run){: #reactor-step-run } | `(any -> any) \\| mfa \\| (any, any -> any) \\| mfa` |  | Provide an anonymous function which implements the `run/3` callback. Cannot be provided at the same time as the `impl` argument. |\n| [`undo`](#reactor-step-undo){: #reactor-step-undo } | `(any -> any) \\| mfa \\| (any, any -> any) \\| mfa \\| (any, any, any -> any) \\| mfa` |  | Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument. |\n| [`compensate`](#reactor-step-compensate){: #reactor-step-compensate } | `(any -> any) \\| mfa \\| (any, any -> any) \\| mfa \\| (any, any, any -> any) \\| mfa` |  | Provide an anonymous function which implements the `undo/4` callback. Cannot be provided at the same time as the `impl` argument. |\n| [`max_retries`](#reactor-step-max_retries){: #reactor-step-max_retries } | `:infinity \\| non_neg_integer` | `:infinity` | The maximum number of times that the step can be retried before failing. Only used when the result of the `compensate/4` callback is `:retry`. |\n| [`async?`](#reactor-step-async?){: #reactor-step-async? } | `boolean` | `true` | When set to true the step will be executed asynchronously via Reactor's `TaskSupervisor`. |\n| [`transform`](#reactor-step-transform){: #reactor-step-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the entire argument map before it is passed to the step. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nargument name, source \\\\ nil\n```\n\n\nSpecifies an argument to a Reactor step.\n\nEach argument is a value which is either the result of another step, or an input value.\n\nIndividual arguments can be transformed with an arbitrary function before\nbeing passed to any steps.","ref":"dsl-reactor.html#reactor-step-argument","title":"reactor.step.argument - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-step-argument-name){: #reactor-step-argument-name .spark-required} | `atom` |  | The name of the argument which will be used as the key in the `arguments` map passed to the implementation. |\n| [`source`](#reactor-step-argument-source){: #reactor-step-argument-source .spark-required} | `Reactor.Template.Element \\| Reactor.Template.Input \\| Reactor.Template.Result \\| Reactor.Template.Value` |  | What to use as the source of the argument. See `Reactor.Dsl.Argument` for more information. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`transform`](#reactor-step-argument-transform){: #reactor-step-argument-transform } | `(any -> any) \\| module \\| nil` |  | An optional transformation function which can be used to modify the argument before it is passed to the step. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nwait_for names\n```\n\n\nWait for the named step to complete before allowing this one to start.\n\nDesugars to `argument :_, result(step_to_wait_for)`","ref":"dsl-reactor.html#reactor-step-wait_for","title":"reactor.step.wait_for - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`names`](#reactor-step-wait_for-names){: #reactor-step-wait_for-names .spark-required} | `atom \\| list(atom)` |  | The name of the step to wait for. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Step`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nswitch name\n```\n\n\nUse a predicate to determine which steps should be executed.","ref":"dsl-reactor.html#reactor-switch","title":"reactor.switch - DSL: Reactor.Dsl","type":"extras"},{"doc":"* [matches?](#reactor-switch-matches?)\n\n * [default](#reactor-switch-default)","ref":"dsl-reactor.html#nested-dsls","title":"Nested DSLs - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`name`](#reactor-switch-name){: #reactor-switch-name .spark-required} | `atom` |  | A unique name for the switch. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`on`](#reactor-switch-on){: #reactor-switch-on .spark-required} | `Reactor.Template.Element \\| Reactor.Template.Input \\| Reactor.Template.Result \\| Reactor.Template.Value` |  | The value to match against. |\n| [`allow_async?`](#reactor-switch-allow_async?){: #reactor-switch-allow_async? } | `boolean` | `true` | Whether the emitted steps should be allowed to run asynchronously. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"```elixir\nmatches? predicate\n```\n\n\nA group of steps to run when the predicate matches.","ref":"dsl-reactor.html#reactor-switch-matches","title":"reactor.switch.matches? - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`predicate`](#reactor-switch-matches?-predicate){: #reactor-switch-matches?-predicate .spark-required} | `(any -> any) \\| mfa` |  | A one-arity function which is used to match the switch input. If the switch returns a truthy value, then the nested steps will be run. |","ref":"dsl-reactor.html#arguments","title":"Arguments - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`allow_async?`](#reactor-switch-matches?-allow_async?){: #reactor-switch-matches?-allow_async? } | `boolean` | `true` | Whether the emitted steps should be allowed to run asynchronously. |\n| [`return`](#reactor-switch-matches?-return){: #reactor-switch-matches?-return } | `atom` |  | Specify which step result to return upon completion. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Switch.Match`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"If none of the `matches?` branches match the input, then the `default`\nsteps will be run if provided.","ref":"dsl-reactor.html#reactor-switch-default","title":"reactor.switch.default - DSL: Reactor.Dsl","type":"extras"},{"doc":"| Name | Type | Default | Docs |\n|------|------|---------|------|\n| [`return`](#reactor-switch-default-return){: #reactor-switch-default-return } | `atom` |  | Specify which step result to return upon completion. |","ref":"dsl-reactor.html#options","title":"Options - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Switch.Default`","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"},{"doc":"Target: `Reactor.Dsl.Switch`\n\n\n\n\n\n .spark-required::after { content: \"*\"; color: red !important; }","ref":"dsl-reactor.html#introspection","title":"Introspection - DSL: Reactor.Dsl","type":"extras"}],"producer":{"name":"ex_doc","version":[48,46,51,52,46,50]}}